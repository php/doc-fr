<?xml version='1.0' encoding='iso-8859-1'?>
<!-- $Revision: 1.30 $ -->
<!-- EN-Revision: 1.55 Maintainer: yannick Status: ready -->
<!-- Purpose: database.abstract -->
<!-- Membership: pecl, bundled -->
<!-- Reviewed: yes -->

<reference id="ref.pdo">
 <title>Fonctions PDO</title>
 <titleabbrev>PDO</titleabbrev>

 <partintro>
  <section id="pdo.intro">
   &reftitle.intro;
   <para>
    L'extension <acronym>PHP Data Objects</acronym> (PDO) définit
    une excellente interface pour accéder à une base de données depuis &php;.
    Chaque pilote de base de données implémenté dans l'interface PDO peut utiliser
    des fonctionnalités spécifiques de chacune des bases de données
    en utilisant des extensions de fonctions. Notez que vous ne pouvez
    exécuter aucune fonction de base de données en utilisant l'extension PDO
    par elle-même ; vous devez utiliser un <link linkend="pdo.drivers">driver
    PDO spécifique à la base de données</link> pour accéder au serveur de base
    de données.
   </para>
   <para>
    PDO fournit une interface d'abstraction à l'accès de données, ce qui signifie que vous utilisez
    les mêmes fonctions pour exécuter des requêtes ou récupérer les données quelque
    soit la base de données utilisée. PDO ne fournit <emphasis>pas</emphasis>
    une abstraction de base de données : il ne réécrit pas le SQL, n'émule pas des fonctionnalités
    manquantes. Vous devriez utiliser une interface d'abstraction complète si vous avez
    besoin de cela.
   </para>
   <para>
    PDO est fournit avec &php; 5.1 et est disponible en tant qu'extension PECL pour &php; 5.0 ;
    PDO requiert les nouvelles fonctionnalités OO fournies par &php; 5 et donc, ne fonctionne
    pas avec les versions antérieures de &php;.
   </para>
  </section>

  &reference.pdo.configure;

  &reference.pdo.ini;

  <section id="pdo.drivers">
   <title>Drivers PDO</title>
   <para>
    Les drivers suivants sont actuellement implémentés dans l'interface PDO :
    <informaltable>
     <tgroup cols='2'>
      <thead>
       <row>
        <entry>Nom du driver</entry>
        <entry>Bases de données supportées</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><link linkend="ref.pdo-dblib">PDO_DBLIB</link></entry>
        <entry>FreeTDS / Microsoft SQL Server / Sybase</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-firebird">PDO_FIREBIRD</link></entry>
        <entry>Firebird/Interbase 6</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-ibm">PDO_IBM</link></entry>
        <entry>IBM DB2</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-informix">PDO_INFORMIX</link></entry>
        <entry>IBM Informix Dynamic Server</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-mysql">PDO_MYSQL</link></entry>
        <entry>MySQL 3.x/4.x/5.x</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-oci">PDO_OCI</link></entry>
        <entry>Oracle Call Interface</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-odbc">PDO_ODBC</link></entry>
        <entry>ODBC v3 (IBM DB2 unixODBC et win32 ODBC)</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-pgsql">PDO_PGSQL</link></entry>
        <entry>PostgreSQL</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-sqlite">PDO_SQLITE</link></entry>
        <entry>SQLite 3 et SQLite 2</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </section>

  <section id='pdo.connections'>
   <title>Connexions et gestionnaire de connexion</title>
   <para>
    Les connexions sont établies en créant des instances de la classe de base de PDO.
    Peut importe quel driver vous voulez utiliser ; vous utilisez toujours le nom
    de la classe PDO. Le constructeur accepte des paramètres pour spécifier
    la source de la base de données (connue en tant que DSN) et optionnellement,
    le nom d'utilisateur et le mot de passe (s'il y en a un).
   </para>
   <para>
    <example>
     <title>Connexion à MySQL</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    S'il y a des erreurs de connexion, un objet <literal>PDOException</literal>
    est lancé. Vous pouvez attraper cette exception si vous voulez gérer
    cette erreur, ou laisser le gestionnaire global d'exception défini
    via la fonction <function>set_exception_handler</function> la traiter.
   </para>
   <para>
    <example>
     <title>Gestion des erreurs de connexion</title>
     <programlisting role='php'>
<![CDATA[
<?php
try {
   $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
   foreach ($dbh->query('SELECT * from FOO') as $row) {
      print_r($row);
   }
   $dbh = null;
} catch (PDOException $e) {
print "Erreur ! : " . $e->getMessage() . "<br/>";
die();
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <para>
     Si votre application n'attrape pas les exceptions lancées depuis le constructeur PDO,
     l'action par défaut du moteur zend est de terminer le script et d'afficher une trace.
     Cette trace devrait révéler des détails complets sur la connexion à la base de données,
     incluant le nom d'utilisateur et le mot de passe. Il en est donc de votre responsabilité
     d'attraper cette exception, soit explicitement (via l'instruction <literal>catch</literal>)
     ou implicitement via la fonction <function>set_exception_handler</function>.
    </para>
   </warning>
   <para>
    Lorsque la connexion à la base de données a réussi, une instance de la classe
    PDO est retournée à votre script. La connexion est active tant que l'objet PDO
    l'est. Pour clore la connexion, vous devez détruire l'objet en vous assurant que
    toutes ses références sont effacées. Vous pouvez faire cela en assignant &null;
    à la variable gérant l'objet. Si vous ne le faites pas explicitement, &php; fermera
    automatiquement la connexion lorsque le script arrivera à la fin.
   </para>
   <para>
    <example>
     <title>Fermeture d'une connexion</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
// utiliser la connexion ici


// et maintenant, fermez-la !
$dbh = null;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Beaucoup d'applications web utilisent des connexions persistantes aux serveurs
    de base de données. Les connexions persistantes ne sont pas fermées à la fin du
    script, mais sont mises en cache et réutilisées lorsqu'un autre script demande une connexion
    en utilisant les mêmes paramètres. Le cache des connexions persistantes
    vous permet d'éviter d'établir une nouvelle connexion à chaque fois qu'un
    script doit accéder à une base de données, rendant l'application web plus rapide.
   </para>
   <para>
    <example>
     <title>Connexions persistantes</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
   PDO::ATTR_PERSISTENT => true
));
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Si vous utilisez le driver PDO ODBC et que votre bibliothèque ODBC supporte
     le pool de connexion ODBC (unixODBC et Windows le supportent tous les deux ;
     peut être plus), alors il est recommandé de ne pas utiliser les connexions persistantes
     PDO mais plutôt laisser le pool de connexion ODBC mettre en cache les connexions.
     Le pool de connexion ODBC est partagé avec les autres modules dans le processus ;
     si PDO met en cache la connexion, alors cette connexion ne sera jamais retournée
     par le pool de connexion ODBC, faisant que plusieurs connexions sont créées pour
     les autres modules.
    </para>
   </note>
  </section>

  <section id='pdo.transactions'>
   <title>Transactions et validation automatique (auto-commit)</title>
   <para>
    Maintenant que vous êtes connecté via PDO, vous devez comprendre
    comment PDO gère les transactions avant d'exécuter des requêtes. Si vous n'avez
    jamais utilisé les transactions, elles offrent 4 fonctionnalités majeures :
    Atomicité, Consistance, Isolation et Durabilité (ACID). En d'autres termes,
    n'importe quel travail mené à bien dans une transaction, même s'il est effectué
    par étapes, est garanti d'être appliqué à la base de données sans risque, et sans
    interférence pour les autres connexions, quand il est validé. Le travail des transactions
    peut également être automatiquement annulé à votre demande (en supposant que
    vous n'avez encore rien validé), ce qui rend la gestion des erreurs bien plus
    simple dans vos scripts.
   </para>
   <para>
    Les transactions sont typiquement implémentées pour appliquer
    toutes vos modifications en une seule fois ; ceci a le bel effet d'éprouver
    drastiquement l'efficacité de vos mises à jour. Dans d'autres termes,
    les transactions rendent vos scripts plus rapides et potentiellement plus
    robustes (vous devez les utiliser correctement pour avoir ces bénéfices).
   </para>
   <para>
    Malheureusement, toutes les bases de données ne supportent pas les transactions,
    donc, PDO doit s'exécuter en mode "auto-commit" lorsque vous ouvrez pour la première
    fois la connexion. Le mode "auto-commit" signifie que toutes les requêtes que vous
    exécutez ont leurs transactions implicites, si la base de données le supporte ou
    aucune transaction si la base de données ne les supporte pas. Si vous avez besoin
    d'une transaction, vous devez utiliser la méthode <xref linkend="function.PDO-beginTransaction" />
    pour l'initialiser. Si le driver utilisé ne supporte pas les transactions, une exception
    PDO sera lancée (en accord avec votre gestionnaire d'erreurs : ceci est toujours
    une erreur sérieuse). Une fois que vous êtes dans une transaction, vous devez utiliser
    la fonction <xref linkend="function.PDO-commit" /> ou la fonction <xref linkend="function.PDO-rollBack" />
    pour la terminer, suivant le succès de votre code durant la transaction.
   </para>
   <para>
    Lorsque le script se termine ou lorsque la connexion est sur le point de se fermer,
    si vous avez une transaction en cours, PDO l'annulera automatiquement.
    Ceci est une mesure de sécurité afin de garantir la consistance de vos données
    dans le cas où le script se termine d'une façon inattendue. Si vous ne validez pas
    explicitement la transaction, alors, on présume que quelque chose s'est mal passé
    et l'annulation de la transaction intervient afin de garantir la sécurité de vos données.
   </para>
   <warning>
    <para>
     L'annulation automatique intervient si vous avez initialisé la transaction via
     <xref linkend="function.PDO-beginTransaction" />. Si vous avez manuellement
     exécuté une requête qui commence une transaction, PDO n'a aucun moyen de
     le savoir et donc, n'annulera pas automatiquement cette transaction si quelque
     chose s'est mal passé.
    </para>
   </warning>
   <para>
    <example>
     <title>Exécution d'un groupe dans une transaction</title>
     <para>
      Dans l'exemple suivant, supposons que nous allons créer un jeu d'entrées
      pour un nouvel employé, dont le numéro d'ID sera 23.
      En plus des données basiques sur cette personne, nous devons également
      lui enregistrer son salaire. Il est très simple d'effectuer deux mises à jour
      séparées, mais en les enfermant dans les appels des fonctions
      <xref linkend="function.PDO-beginTransaction" /> et
      <xref linkend="function.PDO-commit" />, nous garantissons que personne
      ne pourra voir ces modifications tant qu'elles ne seront pas complètes.
      Si quelque chose tourne mal, le bloc de capture annulera toutes les
      modifications effectuées depuis le début de la transaction et affichera
      un message d'erreur.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
try {
    $dbh = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2',
        array(PDO::ATTR_PERSISTENT => true));
    echo "Connecté\n";
    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $dbh->beginTransaction();
    $dbh->exec("insert into staff (id, first, last) values (23, 'Joe', 'Bloggs')");
    $dbh->exec("insert into salarychange (id, amount, changedate) 
    values (23, 50000, NOW())");
    $dbh->commit();

} catch (Exception $e) {
    $dbh->rollBack();
    echo "Échec : " . $e->getMessage();
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vous n'êtes pas limité dans le nombre de mises à jour dans une transaction ;
    vous pouvez également y effectuer des requêtes complexes et bien sûr, utiliser
    ces informations pour construire d'autres mises à jour et requêtes ; durant l'activité
    de la transaction, vous êtes garanti que personne d'autre ne peut effectuer des
    modifications alors que vous êtes au milieu de vos modifications. En réalité,
    ceci n'est pas 100% correct, mais cela reste une très bonne introduction aux
    transactions.
   </para>
  </section>

  <section id='pdo.prepared-statements'>
   <title>Requêtes préparées et procédures stockées</title>
   <para>
    La plupart des bases de données supportent le concept des requêtes préparées.
    Qu'est-ce donc ? Vous pouvez les voir comme une sorte de modèle compilé
    pour le SQL que vous voulez exécuter, qui peut être personnalisé en utilisant
    des variables en guise de paramètres. Les requêtes préparées offrent
    deux fonctionnalités essentielles :
   </para>
   <itemizedlist>
    <listitem>
     <simpara>
      La requête ne doit être analysée (ou préparée) qu'une seule fois, mais peut
      être exécutée plusieurs fois avec des paramètres identiques ou différents.
      Lorsque la requête est préparée, la base de données va analyser, compiler
      et optimiser son plan pour exécuter la requête. Pour les requêtes complexes,
      ce processus peut prendre assez de temps, ce qui peut ralentir vos applications
      si vous devez répéter la même requête plusieurs fois avec différents paramètres.
      En utilisant les requêtes préparées, vous évitez ainsi de répéter le cycle
      analyser/compilation/optimisation. Pour résumer, les requêtes préparées
      utilisent moins de ressources et s'exécutent plus rapidement.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les paramètres pour préparer les requêtes n'ont pas besoin d'être entre
      guillemets ; le driver le gère pour vous. Si votre application utilise exclusivement
      les requêtes préparées, vous pouvez être sûr qu'aucune injection SQL
      n'est possible (Cependant, si vous construisez d'autres parties de la requête
      en vous basant sur des entrées utilisateurs, vous continuez à prendre un risque).
     </simpara>
    </listitem>
   </itemizedlist>
   <para>
    Les requêtes préparées sont tellement pratiques que c'est l'unique fonctionnalité
    que PDO émule pour les drivers qui ne les supportent pas. Ceci assure de pouvoir
    utiliser la même technique pour accéder aux données, sans se soucier des capacités
    de la base de données.
   </para>
   <para>
    <example>
     <title>Insertions répétitives en utilisant les requêtes préparées</title>
     <simpara>
      Cet exemple effectue une requête INSERT en y substituant un
      <literal>nom</literal> et une <literal>valeur</literal> pour les marqueurs nommés.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (nom, valeur) VALUES (:nom, :valeur)");
$stmt->bindParam(':nom', $nom);
$stmt->bindParam(':valeur', $valeur);

// insertion d'une ligne
$nom = 'one';
$valeur = 1;
$stmt->execute();

// insertion d'une autre ligne avec des valeurs différentes
$nom = 'two';
$valeur = 2;
$stmt->execute();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Insertions répétées en utilisant des requêtes réparées</title>
     <simpara>
      Cet exemple effectue une requête INSERT en y substituant un <literal>nom</literal>
      et une <literal>valeur</literal> pour les marqueurs <literal>?</literal>.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (nom, valeur) VALUES (?, ?)");
$stmt->bindParam(1, $nom);
$stmt->bindParam(2, $valeur);

// insertion d'une ligne
$nom = 'one';
$valeur = 1;
$stmt->execute();

// insertion d'une autre ligne avec différentes valeurs
$nom = 'two';
$valeur = 2;
$stmt->execute();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Récupération des données en utilisant des requêtes préparées</title>
     <simpara>
      Cet exemple récupère des données basées sur la valeur d'une clé fournie
      par un formulaire. L'entrée utilisateur est automatiquement échappée, il n'y a
      donc aucun risque d'attaque par injection SQL.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where nom = ?");
if ($stmt->execute(array($_GET['nom']))) {
while ($row = $stmt->fetch()) {
print_r($row);
}
}
?>
         ]]>
     </programlisting>
    </example>
   </para>
   <para>
    Si le driver de la base de données le supporte, vous pouvez également lier
    des paramètres aussi bien pour l'entrée que pour la sortie. Les paramètres de sortie
    sont utilisés typiquement pour récupérer les valeurs d'une procédure stockée.
    Les paramètres de sortie sont un peu plus complexe à utiliser que les paramètres d'entrée
    car vous devez savoir la longueur d'un paramètre donné pourra atteindre lorsque vous
    le liez. Si la valeur retournée est plus longue que la taille qui vous auriez suggéré,
    une erreur sera émise.
   </para>

   <para>
    <example>
     <title>Appel d'une procédure stockée avec un paramètre de sortie</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("CALL sp_returns_string(?)");
$stmt->bindParam(1, $return_value, PDO::PARAM_STR, 4000);

// Appel de la procédure stockée
$stmt->execute();

print "La procédure a retourné : $return_value\n";
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Vous devez également spécifier les paramètres qui gèrent les valeurs
    aussi bien pour l'entrée que pour la sortie ; la syntaxe est similaire aux
    paramètres de sortie. Dans le prochain exemple, la chaîne 'Bonjour' est passée
    à la procédure stockée et lorsqu'elle retourne la valeur, 'Bonjour' est remplacée
    par la valeur retournée par la procédure.
   </para>

   <para>
    <example>
     <title>Appel d'une procédure stockée avec un paramètre d'entrée/sortie</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("CALL sp_takes_string_returns_string(?)");
$value = 'Bonjour';
$stmt->bindParam(1, $value, PDO::PARAM_STR|PDO::PARAM_INPUT_OUTPUT, 4000); 

// appel de la procédure stockée
$stmt->execute();

print "La procédure a retourné : $value\n";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Utilisation invalide de marqueur</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where nom LIKE '%?%'");
$stmt->execute(array($_GET['nom']));

// un marqueur doit être utilisé à la place d'une valeur complète
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where nom LIKE ?");
$stmt->execute(array("%$_GET[nom]%"));
?>
]]>
     </programlisting>
    </example>
   </para>
  </section>

  <section id='pdo.error-handling'>
   <title>Erreurs et gestionnaire des erreurs</title>
   <para>
    PDO offre la possibilité de gérer les erreurs de 3 façons différentes, pour
    coller au mieux au style de votre application.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <constant>PDO::ERRMODE_SILENT</constant>
     </para>
     <para>
      C'est le mode par défaut. PDO définit simplement le code erreur pour vous
      afin de l'inspecter en utilisant les méthodes <xref linkend="function.PDO-errorCode" />
      et <xref linkend="function.PDO-errorInfo" /> sur la requête ou sur les objets
      de la base de données ; si l'erreur est issue d'un appel à un objet de requête,
      vous devriez invoquer les méthodes <xref linkend="function.PDOStatement-errorCode" />
      ou <xref linkend="function.PDOStatement-errorInfo" /> sur cet objet. Si l'erreur
      est issue d'un appel sur un objet de la base de données, vous devriez invoquer
      à la place les méthodes de cet objet.
     </para>
    </listitem>
    <listitem>
     <para>
      <constant>PDO::ERRMODE_WARNING</constant>
     </para>
     <para>
      En plus de définir le code erreur, PDO émettra un message de niveau E_WARNING.
      Ce comportement est très utile lors de la phase de test/débogage, si vous voulez
      juste voir le problème qui survient sans pour autant stopper le flot de l'application.
     </para>
    </listitem>
    <listitem>
     <para>
      <constant>PDO::ERRMODE_EXCEPTION</constant>
     </para>
     <para>
      En plus de définir le code erreur, PDO lancera une exception
      <classname>PDOException</classname> et y définit ces propriétés
      pour refléter le code erreur et l'information sur l'erreur. Ce comportement
      est utile également durant la période de débogage car il va stopper
      l'application à l'endroit même de l'erreur et pointer l'endroit où
      se trouve potentiellement l'erreur dans votre code (souvenez-vous :
      les transactions sont automatiquement annulées si l'exception fait
      que le script se termine).
     </para>
     <para>
      Le mode lançant des exceptions est également utile pour structurer
      la gestion de vos erreurs plus clairement que par la traditionnelle
      gestion des erreurs de &php; et avec moins de code, plutôt que le mode
      silencieux et l'analyse explicite des valeurs retournées par chaque appel
      à la base de données.
     </para>
     <para>
      Lisez la documentation sur les <link linkend='language.exceptions'>exceptions</link>
      pour plus de détails sur les exceptions en &php;.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    PDO standardise les codes erreurs en utilisant SQL-92 SQLSTATE ; les drivers
    individuels PDO sont responsables du mapping de leurs propres codes
    avec les codes SQLSTATE appropriées. La méthode <xref linkend="function.PDO-errorCode" />
    retourne un seul code SQLSTATE. Si vous avez besoin de plus d'informations sur
    une erreur, PDO fournit également la méthode <xref linkend="function.PDO-errorInfo" />
    qui retourne un tableau contenant le code SQLSTATE, le code erreur spécifique
    du driver et la chaîne erreur spécifique au driver.
   </para>
  </section>

  <section id='pdo.lobs'>
   <title>Les objets larges (LOBs)</title>
   <para>
    À un moment dans votre application, vous pourriez avoir besoin de stocker de
    larges données dans votre base de données. "Large" signifie typiquement
    des données d'environ 4ko ou plus, bien que certaines bases de données peuvent
    gérer plus de 32ko avant que les données deviennent "larges". Les objets larges
    peuvent être de nature textuelle ou binaire. PDO vous permet de travailler
    avec ce type de larges données en utilisant le code type
    <constant>PDO::PARAM_LOB</constant> dans vos appels aux fonctions
    <xref linkend="function.PDOStatement-bindParam" /> ou
    <xref linkend="function.PDOStatement-bindColumn" />.
    <constant>PDO::PARAM_LOB</constant> demande à PDO de mapper les données
    en un flux que vous pourrez manipuler en utilisant
    l'<link linkend='ref.stream'>API &php; sur les flux</link>.
   </para>
   <para>
   </para>
   <para>
    <example>
     <title>Affichage d'une image depuis une base de données</title>
     <para>
      Cet exemple lie un LOB dans une variable nommée $lob et l'envoie
      au navigateur en utilisant la fonction <function>fpassthru</function>.
      Étant donné qu'un LOB est représenté en un flux, les fonctions comme
      <function>fgets</function>, <function>fread</function> et
      <function>stream_get_contents</function> peuvent être utilisées sur ce flux.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2');
$stmt = $db->prepare("select contenttype, imagedata from images where id=?");
$stmt->execute(array($_GET['id']));
$stmt->bindColumn(1, $type, PDO::PARAM_STR, 256);
$stmt->bindColumn(2, $lob, PDO::PARAM_LOB);
$stmt->fetch(PDO::FETCH_BOUND);

header("Content-Type: $type");
fpassthru($lob);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Insertion d'une image dans une base de données</title>
     <para>
      Cet exemple ouvre un fichier et passe le pointeur de fichier à PDO
      pour l'insérer en tant que LOB. PDO fera son possible pour récupérer
      le contenu du fichier et l'insérer dans la base de données de la
      manière la plus efficace possible.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2');
$stmt = $db->prepare("insert into images (id, contenttype, imagedata) values (?, ?, ?)");
$id = get_new_id(); // fonction pour allouer un nouvel ID

// assumons que nous récupérons un fichier depuis un formulaire
// vous pouvez trouver plus de détails dans la documentation de PHP

$fp = fopen($_FILES['file']['tmp_name'], 'rb');

$stmt->bindParam(1, $id);
$stmt->bindParam(2, $_FILES['file']['type']);
$stmt->bindParam(3, $fp, PDO::PARAM_LOB);

$stmt->beginTransaction();
$stmt->execute();
$stmt->commit();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Insertion d'une image dans une base de données Oracle</title>
     <para>
      Oracle requiert une syntaxe légèrement différente pour y insérer un LOB
      depuis un fichier. Il est également essentiel d'effectuer votre insertion
      au sein d'une transaction, sinon, votre nouveau LOB sera inséré
      avec une longueur de zéro :
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('oci:', 'scott', 'tiger');
$stmt = $db->prepare("insert into images (id, contenttype, imagedata) " .
"VALUES (?, ?, EMPTY_BLOB()) RETURNING imagedata INTO ?");
$id = get_new_id(); // fonction pour allouer un nouvel ID

// assumons que nous récupérons un fichier depuis un formulaire
// vous pouvez trouver plus de détails dans la documentation de PHP

$fp = fopen($_FILES['file']['tmp_name'], 'rb');

$stmt->bindParam(1, $id);
$stmt->bindParam(2, $_FILES['file']['type']);
$stmt->bindParam(3, $fp, PDO::PARAM_LOB);

$stmt->beginTransaction();
$stmt->execute();
$stmt->commit();
?>
]]>
     </programlisting>
    </example>
   </para>
  </section>

  <section id='pdo.classes'>
   &reftitle.classes;
   <section id='pdo.class.PDO'>
    <title><classname>PDO</classname></title>
    <para>
     Représente une connexion entre &php; et un serveur de base de données.
    </para>
    <section id='pdo.class.PDO.constructor'>
     &reftitle.constructor;
     <itemizedlist>
      <listitem>
       <para>
        <link linkend='function.PDO-construct'>PDO</link> - construit un nouvel objet PDO
       </para>
      </listitem>
     </itemizedlist>
    </section>
    <section id='pdo.class.PDO.methods'>
     &reftitle.methods;
     <itemizedlist>
      <listitem>
       <para>
        <link linkend='function.PDO-beginTransaction'>beginTransaction</link>
        - commence une transaction
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-commit'>commit</link>
        - valide une transaction
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-errorCode'>errorCode</link>
        - récupère un code erreur, s'il y en a, depuis la base de données
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-errorInfo'>errorInfo</link>
        - récupère un tableau contenant les informations sur l'erreur, s'il y en a, depuis la base de données
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-exec'>exec</link>
        - exécute une requête SQL et retourne le nombre de lignes affectées
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-getAttribute'>getAttribute</link>
        - récupère un attribut d'une connexion à une base de données
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-lastInsertId'>lastInsertId</link>
        - récupère la valeur de la dernière ligne insérée dans une table
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-prepare'>prepare</link>
        - prépare une requête SQL pour exécution
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-query'>query</link>
        - exécute une requête SQL et retourne le jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-quote'>quote</link>
        - retourne une version protégée d'une chaîne pour utilisation dans une requête SQL
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-rollBack'>rollBack</link>
        - annule une transaction
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-setAttribute'>setAttribute</link>
        - définit un attribut d'une connexion à une base de données
       </para>
      </listitem>
     </itemizedlist>
    </section>
   </section>

   <section id='pdo.class.PDOStatement'>
    <title><classname>PDOStatement</classname></title>
    <para>
     Représente une requête préparée et, après exécution de la requête, un jeu
     de résultat associatif.
    </para>
    <section id='pdo.class.Statement.methods'>
     &reftitle.methods;
     <itemizedlist>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-bindColumn'>bindColumn</link>
        - lie une variable &php; à une colonne de sortie dans un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-bindParam'>bindParam</link>
        - lie une variable &php; à un paramètre dans une requête préparée
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-bindValue'>bindValue</link>
        - lie une valeur à un paramètre dans une requête préparée
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-closeCursor'>closeCursor</link>
        - ferme le curseur, autorisant la requête à être exécutée une nouvelle fois
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-columnCount'>columnCount</link>
        - retourne le nombre de colonnes dans un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-errorCode'>errorCode</link>
        - récupère le code erreur, s'il y en a, depuis une requête
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-errorInfo'>errorInfo</link>
        - récupère un tableau contenant les informations sur une erreur, s'il y en a,
        depuis une requête
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-execute'>execute</link>
        - exécute une requête préparée
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-fetch'>fetch</link>
        - récupère une ligne depuis un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-fetchAll'>fetchAll</link> 
        - récupère un tableau contenant toutes les lignes depuis un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-fetchColumn'>fetchColumn</link> 
        - retourne les données depuis une colonne d'un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-getAttribute'>getAttribute</link> 
        - récupère un attribut PDOStatement
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-getColumnMeta'>getColumnMeta</link> 
        - récupère les méta-informations pour une colonne d'un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-nextRowset'>nextRowset</link> 
        - récupère la ligne suivante (du jeu de résultats)
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-rowCount'>rowCount</link> 
        - retourne le nombre de lignes affectées par l'exécution d'une requête SQL
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-setAttribute'>setAttribute</link> 
        - définit un attribut PDOStatement
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-setFetchMode'>setFetchMode</link> 
        - définit le mode de récupération pour une PDOStatement
       </para>
      </listitem>
     </itemizedlist>
    </section>
   </section>

   <section id='pdo.class.PDOException'>
    <title><classname>PDOException</classname></title>
    <para>
     Représente une erreur émise par PDO. Vous ne devriez pas lancer une exception
     <classname>PDOException</classname> depuis votre propre code.
     Lisez la documentation sur les <link linkend='language.exceptions'>Exceptions</link>
     pour plus de détails sur les exceptions en &php;.
    </para>
    <example>
     <title>La classe PDOException</title>
     <programlisting role='php'>
<![CDATA[
<?php
class PDOException extends Exception
{
public $errorInfo = null;    // correspond à PDO::errorInfo()
// ou PDOStatement::errorInfo()
protected $message;          // message d'erreur textuel
// utiliser Exception::getMessage() pour y accéder
protected $code;             // code erreur SQLSTATE
// utiliser Exception::getCode() pour y accéder
}
?>
]]>
     </programlisting>
    </example>
   </section>
  </section>
  &reference.pdo.constants;
 </partintro>
 &reference.pdo.functions;
</reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->