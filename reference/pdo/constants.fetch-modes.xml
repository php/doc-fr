<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 86d3fb841e0206e2588896ad3c21432333535848 Maintainer: Fan2Shrek Status: ready -->
<!-- Reviewed: yes -->
<section xmlns="http://docbook.org/ns/docbook" xml:id="pdo.constants.fetch-modes">
 <title>Modes de récupération</title>

 <simpara>
  Voir <link linkend="pdo.constants.cursors">les constantes de curseur</link> pour les
  constantes de curseur <literal>PDO::FETCH_ORI_*</literal>.
 </simpara>

 <section xml:id="pdo.fetch-modes.basic" annotations="chunk:false">
  <title>Méthodes de récupération de base</title>
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Mode de récupération</entry>
      <entry>Résumé</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_DEFAULT</constant>
      </entry>
      <entry>
       Valeur spéciale pour utiliser le mode de récupération par défaut actuel.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_ASSOC</constant>
      </entry>
      <entry>
       Tableau indexé par le nom de colonne uniquement.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_BOTH</constant> (Défaut)
      </entry>
      <entry>
       Tableau indexé à la fois par le numéro de colonne et par le nom.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NAMED</constant>
      </entry>
      <entry>
       Variante de <constant>PDO::FETCH_ASSOC</constant> qui conserve les colonnes
       dupliquées.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NUM</constant>
      </entry>
      <entry>
       Tableau indexé par le numéro de colonne uniquement.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_COLUMN</constant>
      </entry>
      <entry>
       Une seule colonne.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_KEY_PAIR</constant>
      </entry>
      <entry>
       Paires de clés-valeurs, indexées par la première colonne.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_FUNC</constant>
      </entry>
      <entry>
       Utilise une fonction pour créer la valeur de retour.
       (seulement <methodname>PDOStatement::fetchAll</methodname>)
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_OBJ</constant>
      </entry>
      <entry>
       Objet anonyme (<classname>stdClass</classname>).
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASS</constant>
      </entry>
      <entry>
       Crée un objet d'une classe spécifiée.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.class-flags" annotations="chunk:false">
  <title>PDO::FETCH_CLASS options</title>

  <simpara>
   Ces modes sont utilisés pour implémenter des options lors de l'utilisation de
   <constant>PDO::FETCH_CLASS</constant>.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Mode de récupération</entry>
      <entry>Résumé</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASSTYPE</constant>
      </entry>
      <entry>
       Utilise la première colonne comme nom de classe.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_PROPS_LATE</constant>
      </entry>
      <entry>
       Appelle le constructeur avant de définir les propriétés.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_SERIALIZE</constant>
      </entry>
      <entry>
       Utilise les données PHP sérialisées. Obsolète depuis PHP 8.1.0.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.single" annotations="chunk:false">
  <title>Modes de résultat unique</title>

  <simpara>
   Les modes suivants ne peuvent pas être utilisés avec
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Mode de récupération</entry>
      <entry>Résumé</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_BOUND</constant>
      </entry>
      <entry>
       Lie les valeurs aux variables spécifiées.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_INTO</constant>
      </entry>
      <entry>
       Met à jour un objet existant.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_LAZY</constant>
      </entry>
      <entry>
       Récupération paresseuse via <classname>PDORow</classname> pour un accès
       de type tableau et objet.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.grouped" annotations="chunk:false">
  <title>
   Drapeaux spéciaux pour <methodname>PDOStatement::fetchAll</methodname>
  </title>

  <simpara>
   Les modes spéciaux suivants pour plusieurs résultats ne fonctionnent qu'avec
   <methodname>PDOStatement::fetchAll</methodname> et ne fonctionnent pas avec certains autres
   modes de récupération. Consultez la documentation complète pour plus de détails.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Mode de récupération</entry>
      <entry>Résumé</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_GROUP</constant>
      </entry>
      <entry>
       Les résultats sont regroupés par la première colonne.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_UNIQUE</constant>
      </entry>
      <entry>
       Les résultats sont (uniquement) indexés par la première colonne.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.duplicate-names" annotations="chunk:false">
  <title>Gestion des noms de colonnes dupliqués</title>
  <simpara>
   Il est possible que les résultats contiennent plusieurs colonnes utilisant le même nom.
   Par exemple, lors de la jointure de 2 tables contenant toutes deux une colonne avec le même
   nom.
  </simpara>
  <simpara>
   Étant donné que les structures PHP telles que les tableaux et les objets ne prennent pas en charge plusieurs clés
   ou propriétés utilisant le même nom, le tableau ou l'objet retourné contiendra
   uniquement 1 des valeurs utilisant le même nom.
  </simpara>
  <simpara>
   La valeur retournée pour un nom dupliqué donné doit être considérée comme
   indéfinie.
  </simpara>
  <simpara>
   Pour éviter ce problème, nommez explicitement les colonnes en utilisant un alias. Par exemple :
  </simpara>
  <informalexample>
   <programlisting role="sql">
<![CDATA[
SELECT table1.created_at AS t1_created_at,
       table2.created_at AS t2_created_at
FROM table1
JOIN table2 ON table1.table2id = table2.id
]]>
   </programlisting>
  </informalexample>
  <simpara>
   Voir également <constant>PDO::FETCH_NAMED</constant>,
   <constant>PDO::ATTR_FETCH_TABLE_NAMES</constant> et
   <constant>PDO::ATTR_FETCH_CATALOG_NAMES</constant>.
  </simpara>
 </section>

 <section xml:id="pdo.fetch-modes.default" annotations="chunk:false">
  <title>Définir le mode de récupération par défaut</title>
  <simpara>
   Il est possible de définir le mode de récupération par défaut pour toutes les requêtes en utilisant
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant> avec
   <methodname>PDO::__construct</methodname> or
   <methodname>PDO::setAttribute</methodname>.
  </simpara>
  <simpara>
   Le mode de récupération par défaut est initialement défini sur
   <methodname>PDOStatement::setFetchMode</methodname>.
   Cela affecte la réutilisation en tant que requête préparée et l'itération (en utilisant
   &foreach;).
  </simpara>
  <caution>
   <simpara>
    <methodname>PDOStatement::setAttribute</methodname> ne peut pas être utilisé pour définir le
    mode de récupération par défaut. Il n'accepte que les attributs spécifiques au pilote et ignore silencieusement
    les attributs qui ne sont pas reconnus.
   </simpara>
  </caution>
 </section>

 <section xml:id="pdo.constants.fetch-default" annotations="chunk:false">
  <title>PDO::FETCH_DEFAULT (<type>int</type>)</title>
  <simpara>
   Disponible depuis PHP 8.0.7.
  </simpara>
  <simpara>
   Ceci est une valeur spéciale qui utilise le mode de récupération par défaut actuel pour une
   <classname>PDOStatement</classname>. C'est particulièrement utile comme valeur par défaut
   pour les paramètres de méthode lors de l'extension de
   <classname>PDOStatement</classname> pour une utilisation avec
   <constant>PDO::ATTR_STATEMENT_CLASS</constant>.
  </simpara>
  <para>
   Cette valeur ne peut pas être utilisée avec
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant>.
  </para>
 </section>

 <section xml:id="pdo.constants.fetch-assoc" annotations="chunk:false">
  <title>PDO::FETCH_ASSOC (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_ASSOC</constant> retourne un tableau indexé par le nom de la colonne
   uniquement.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-both" annotations="chunk:false">
  <title>PDO::FETCH_BOTH (<type>int</type>)</title>
  <simpara>
   Ceci est le mode de récupération par défaut.
  </simpara>
  <simpara>
   <constant>PDO::FETCH_BOTH</constant> retourne un tableau indexé à la fois par le numéro de colonne
   et par le nom. Cela signifie que chaque valeur retournée est dupliquée pour chaque
   ligne de résultat.
  </simpara>
  <simpara>
   Le numéro de colonne commence à 0 et est déterminé par l'ordre des colonnes de résultat dans
   la requête, et non (par exemple) par l'ordre dans lequel les colonnes sont définies dans la table.
  </simpara>
  <note>
   <simpara>
    L'utilisation de l'index de colonne numérique n'est pas recommandée car cela peut changer lorsque
    la requête est modifiée, ou lorsque le schéma de la table est modifié lors de l'utilisation de
    <literal>SELECT *</literal>.
   </simpara>
  </note>
  <note>
   <simpara>
    Le nombre d'entrées indexées par le nom peut ne pas correspondre au nombre d'entrées
    indexées par le numéro dans les cas où plusieurs colonnes retournées utilisent le même
    nom.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_BOTH);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [id] => 104,
    [0] => 104,
    [name] => Chris,
    [1] => Chris,
    [country] => Ukraine,
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-named" annotations="chunk:false">
  <title>PDO::FETCH_NAMED (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NAMED</constant> renvoie des résultats dans le même format que
   <constant>PDO::FETCH_ASSOC</constant> sauf que lorsque plusieurs colonnes utilisent
   le même nom, toutes les valeurs sont retournées sous forme de liste.
  </simpara>
  <simpara>
   Pour plus d'informations sur la gestion des noms de colonnes dupliqués et les alternatives,
   voir la <link linkend="pdo.fetch-modes.duplicate-names">section sur la gestion
    des noms dupliqués</link> ci-dessus.
  </simpara>
  <simpara>
   L'ordre dans lequel les valeurs dupliquées sont retournées doit être considéré
   comme indéfini. Il n'y a aucun moyen de savoir d'où provient chaque valeur.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query(
    "SELECT users.*, referrer.name
     FROM users
     LEFT JOIN users AS referrer ON users.referred_by = referrer.userid
     WHERE userid = 109"
);
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 109
    [name] => Array
        (
            [0] => Toni
            [1] => Chris
        )
    [country] => Germany
    [referred_by] = 104
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-num" annotations="chunk:false">
  <title>PDO::FETCH_NUM (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NUM</constant> renvoie un tableau indexé par le numéro de colonne
   uniquement. Le numéro de colonne commence à 0 et est déterminé par l'ordre des colonnes de résultat dans
   la requête, et non (par exemple) par l'ordre dans lequel les colonnes sont définies dans la table.
  </simpara>
  <note>
   <simpara>
    L'utilisation de l'index de colonne numérique n'est pas recommandée car cela peut changer lorsque
    la requête est modifiée, ou lorsque le schéma de la table est modifié lors de l'utilisation de
    <literal>SELECT *</literal>.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => 104
    [1] => Chris
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-column" annotations="chunk:false">
  <title>PDO::FETCH_COLUMN (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_COLUMN</constant> renvoie des valeurs d'une seule colonne.
   Utilisez le deuxième argument pour <methodname>PDOStatement::setFetchMode</methodname>
   ou <methodname>PDOStatement::fetchAll</methodname> pour spécifier quelle colonne est
   retournée.
  </simpara>
  <simpara>
   Si la colonne spécifiée n'existe pas, une <classname>ValueError</classname>
   sera levée.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN);
print_r($row);

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN, 1);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Chris
    [1] => Jamie
    [2] => Robin
)

Array
(
    [0] => Ukraine
    [1] => England
    [2] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-key-pair" annotations="chunk:false">
  <title>PDO::FETCH_KEY_PAIR (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_KEY_PAIR</constant> renvoie des paires de valeurs, indexées par
   la première colonne. Les résultats doivent contenir uniquement 2 colonnes. Ce mode de récupération
   n'a de sens qu'avec <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <note>
   <simpara>
    Si la première colonne n'est pas unique, des valeurs seront perdues. Les valeurs perdues doivent
    être considérées comme indéfinies.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_KEY_PAIR);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Chris] => Ukraine
    [Jamie] => England
    [Robin] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-func" annotations="chunk:false">
  <title>PDO::FETCH_FUNC (<type>int</type>)</title>
  <simpara>
   Spécifiez une fonction pour créer la valeur retournée. Ce mode ne peut être utilisé
   qu'avec <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   La fonction reçoit les valeurs en tant que paramètres.
   Il n'y a aucun moyen de récupérer le nom de la colonne à laquelle une valeur donnée était associée.
   Il faut l'on assurer que l'ordre des colonnes dans la requête correspond
   à celui attendu par la fonction.
  </simpara>
  <note>
   <simpara>
    Les effets de <constant>PDO::FETCH_GROUP</constant> et
    <constant>PDO::FETCH_UNIQUE</constant> sont appliqués aux résultats avant que la
    fonction ne soit appelée.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function valueCreator($col1, $col2, $col3)
{
    return [
        'col1' => $col1,
        'col2' => strtoupper($col2),
        'col3' => $col3,
        'customKey' => 'customValue',
    ];
}

$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_FUNC, valueCreator(...));
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [col1] => 104
            [col2] => SAM
            [col3] => Ukraine
            [customKey] => customValue
        )

    [1] => Array
        (
            [col1] => 105
            [col2] => JAMIE
            [col3] => England
            [customKey] => customValue
        )

    [2] => Array
        (
            [col1] => 107
            [col2] => ROBIN
            [col3] => Germany
            [customKey] => customValue
        )

)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-obj" annotations="chunk:false">
  <title>PDO::FETCH_OBJ (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_OBJ</constant> renvoie un objet
   <classname>stdClass</classname>.
  </simpara>
  <simpara>
   Voir aussi <methodname>PDOStatement::fetchObject</methodname> et
   <constant>PDO::FETCH_CLASS</constant>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_OBJ);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
stdClass Object
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-class" annotations="chunk:false">
  <title>PDO::FETCH_CLASS (<type>int</type>)</title>
  <simpara>
   Renvoie un objet d'une classe spécifiée. Pour des comportements supplémentaires, voir les
   <link linkend="pdo.fetch-modes.class-flags">options de drapeau</link>.
  </simpara>
  <simpara>
   Si une propriété n'existe pas avec le nom d'une colonne retournée, elle sera
   déclarée dynamiquement. Ce comportement est obsolète et entraînera une erreur
   à partir de PHP 9.0.
  </simpara>
  <simpara>
   Voir aussi <methodname>PDOStatement::fetchObject</methodname>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-classtype" annotations="chunk:false">
  <title>PDO::FETCH_CLASSTYPE (<type>int</type>)</title>
  <simpara>
   Ce mode de récupération peut uniquement être utilisé en combinaison avec
   <constant>PDO::FETCH_CLASS</constant> (et
   <link linkend="pdo.fetch-modes.class-flags">ses autres options</link>).
  </simpara>
  <simpara>
   Lorsque ce mode de récupération est utilisé, PDO utilisera la première colonne
   retournée comme nom de la classe à retourner.
  </simpara>
  <simpara>
   Si la classe spécifiée ne peut pas être trouvée, un objet <classname>stdClass</classname>
   sera retourné, sans avertissement ni erreur.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT 'TestEntity', userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-props-late" annotations="chunk:false">
  <title>PDO::FETCH_PROPS_LATE (<type>int</type>)</title>
  <simpara>
   Ce mode de récupération peut uniquement être utilisé en combinaison avec
   <constant>PDO::FETCH_CLASS</constant> (et
   <link linkend="pdo.fetch-modes.class-flags">ses autres options</link>).
  </simpara>
  <simpara>
   Lorsque ce mode de récupération est utilisé, le constructeur sera appelé avant que
   les propriétés ne soient définies.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? No
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-serialize" annotations="chunk:false">
  <title>PDO::FETCH_SERIALIZE (<type>int</type>)</title>
  &warn.deprecated.feature-8-1-0;
  <simpara>
   Ce mode de récupération peut uniquement être utilisé en combinaison avec
   <constant>PDO::FETCH_CLASS</constant> (et
   <link linkend="pdo.fetch-modes.class-flags">ses autres options</link>).
  </simpara>
  <simpara>
   Lorsque ce mode de récupération est utilisé, la classe spécifiée doit être
   <interfacename>Serializable</interfacename>.
  </simpara>
  <caution>
   <simpara>
    Cette fonctionnalité ne prend pas en charge une chaîne contenant un objet
    sérialisé complet (avec <function>serialize</function>).
   </simpara>
  </caution>
  <caution>
   <simpara>
    Ce mode de récupération n'appelle pas le constructeur.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity implements Serializable
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with " . count(func_get_args()) . " args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }

    public function serialize()
    {
        return join(
            "|",
            [$this->userid, $this->name, $this->country, $this->referred_by_userid]
        );
    }

    public function unserialize(string $data)
    {
        $parts = explode("|", $data);
        $this->userid = (int) $parts[0];
        $this->name = $parts[1];
        $this->country = $parts[2];

        $refId = $parts[3];
        $this->referred_by_userid = ($refId === "" ? null : (int) $refId);
    }
}

print "Set up record (constructor called manually):\n";
$db->exec(
    "CREATE TABLE serialize (
        sdata TEXT
    )"
);

$origObj = new TestEntity();
$origObj->userid = 200;
$origObj->name = 'Seri';
$origObj->country = 'Syria';
$origObj->referred_by_userid = null;

$insert = $db->prepare("INSERT INTO serialize (sdata) VALUES (:sdata)");
$insert->execute(['sdata' => $origObj->serialize()]);

print "\nRetrieve result:\n";
$query = "SELECT sdata FROM serialize";
$stmt = $db->query($query);
// NOTE: Le constructeur n'est jamais appelé
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_SERIALIZE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Deprecated: TestEntity implements the Serializable interface, which is deprecated. Implement __serialize() and __unserialize() instead (or in addition, if support for old PHP versions is necessary) in Standard input code on line 2
Set up record (constructor called manually):
Constructor called with 0 args
Properties set when constructor called? No

Retrieve result:
Deprecated: PDOStatement::setFetchMode(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 58

Deprecated: PDOStatement::fetch(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 59
object(TestEntity)#5 (4) {
  ["userid"]=>
  int(200)
  ["name"]=>
  string(4) "Seri"
  ["country"]=>
  string(5) "Syria"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-bound" annotations="chunk:false">
  <title>PDO::FETCH_BOUND (<type>int</type>)</title>
  <simpara>
   Ce mode de récupération ne peut pas être utilisé avec
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Ce mode de récupération ne renvoie pas directement un résultat, mais lie des valeurs à
   des variables spécifiées avec <methodname>PDOStatement::bindColumn</methodname>. La
   méthode fetch appelée renvoie &true;.
  </simpara>
  <note>
   <simpara>
    Lors de l'utilisation d'instructions préparées, pour fonctionner correctement, les variables doivent être liées
    après l'exécution de la requête.
   </simpara>
  </note>
  <programlisting role="php">
<![CDATA[
<?php
$query = "SELECT users.userid, users.name, users.country, referrer.name
    FROM users
    LEFT JOIN users AS referrer ON users.referred_by_userid = referrer.userid";
$stmt = $db->prepare($query);
$stmt->execute();

$stmt->bindColumn('userid', $userId);
$stmt->bindColumn('name', $name);
$stmt->bindColumn('country', $country);
// Lie par position de colonne pour résoudre le nom de colonne dupliqué
// Pour éviter que cela ne casse si la requête est modifiée, utilisez un alias SQL à la place
// Par exemple : referrer.name AS referrer_name
$stmt->bindColumn(4, $referrerName);

while ($stmt->fetch(\PDO::FETCH_BOUND)) {
    print join("\t", [$userId, $name, $country, ($referrerName ?? 'NULL')]) . "\n";
}
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
104	Chris	Ukraine	NULL
105	Jamie	England	NULL
107	Robin	Germany	Chris
108	Sean	Ukraine	NULL
109	Toni	Germany	NULL
110	Toni	Germany	NULL
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-into" annotations="chunk:false">
  <title>PDO::FETCH_INTO (<type>int</type>)</title>
  <simpara>
   Ce mode de récupération ne peut pas être utilisé avec
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Ce mode de récupération met à jour les propriétés de l'objet spécifié. L'objet est
   renvoyé en cas de succès.
  </simpara>
  <simpara>
   Si une propriété n'existe pas avec le nom d'une colonne renvoyée, elle sera
   déclarée dynamiquement. Ce comportement est obsolète et entraînera une erreur
   à partir de PHP 9.0.
  </simpara>
  <simpara>
   Les propriétés doivent être <literal>public</literal> et ne peuvent pas être
   <literal>readonly</literal>.
  </simpara>
  <caution>
   <simpara>
    Il n'y a aucun moyen de changer l'objet à mettre à jour sans utiliser
    <methodname>PDOStatement::setFetchMode</methodname> entre la récupération de chaque
    enregistrement.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;
}

$obj = new TestEntity();
$stmt->setFetchMode(\PDO::FETCH_INTO, $obj);

$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-lazy" annotations="chunk:false">
  <title>PDO::FETCH_LAZY (<type>int</type>)</title>
  <simpara>
   Ce mode de récupération ne peut pas être utilisé avec
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Ce mode de récupération renvoie un objet <classname>PDORow</classname> qui fournit
   un accès à la fois de type tableau et de type objet aux valeurs (c'est-à-dire qu'il combine le comportement de
   <constant>PDO::FETCH_BOTH</constant> et
   <constant>PDO::FETCH_OBJ</constant>), récupérées de manière paresseuse.
  </simpara>
  <simpara>
   Cela peut fournir un accès efficace en mémoire (du côté PHP) aux résultats non mis en mémoire tampon
   sur le serveur de base de données. Que PDO utilise ou non un tampon côté client pour
   les résultats dépend du pilote spécifique à la base de données utilisé (et de sa configuration).
  </simpara>
  <caution>
   <simpara>
    <classname>PDORow</classname> renverra <literal>NULL</literal> sans
    aucun avertissement ou erreur lors de l'accès à des propriétés ou des clés qui ne sont pas définies.
    Cela peut rendre des erreurs telles que des fautes de frappe ou des requêtes ne renvoyant pas les données attendues
    plus difficiles à repérer et à déboguer.
   </simpara>
  </caution>
  <caution>
   <simpara>
    L'objet <classname>PDORow</classname> renvoyé est mis à jour chaque fois qu'un
    résultat est récupéré.
   </simpara>
  </caution>
  <programlisting role="php">
<![CDATA[
<?php
$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch(\PDO::FETCH_LAZY);

print "ID: ". $result[0] ."\n";
print "Name: {$result->name}\n";
print "Country: " . $result['country'] ."\n";
// Renvoie NULL. Aucun avertissement ou erreur n'est levé.
print "Does not exist: " . var_export($result->does_not_exist, true) . "\n";

$differentResult = $stmt->fetch(\PDO::FETCH_LAZY);
// L'objet PDORow précédemment récupéré pointe maintenant vers le nouveau résultat récupéré
print "ID: ". $result[0] ."\n";

]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
ID: 104
Name: Chris
Country: Ukraine
Does not exist: NULL
ID: 105
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-group" annotations="chunk:false">
  <title>PDO::FETCH_GROUP (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_GROUP</constant> renvoie des listes de tableaux associatifs,
   indexés par une colonne (non unique). Ce mode de récupération ne fonctionne qu'avec
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Lorsqu'il est combiné avec <constant>PDO::FETCH_UNIQUE</constant>, les deux modes utiliseront
   la même colonne, rendant la combinaison de ces modes inutile.
  </simpara>
  <simpara>
   Cette récupération doit être combinée avec l'un des
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant> ou
   <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   Si aucun mode de récupération de la liste ci-dessus n'est donné, le mode de récupération par défaut actuel
   pour la <classname>PDOStatement</classname> sera utilisé.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                )
        )
)
]]>
   </screen>
  </informalexample>
  <simpara>
   Dans l'exemple ci-dessus, il est notable que la première colonne est omise de
   l'array pour chaque ligne, n'étant disponible que comme clé. Elle peut être incluse en
   répétant la colonne, comme dans l'exemple suivant :
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name, country FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                    [country] => Ukraine
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                    [country] => Ukraine
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                    [country] => England
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                    [country] => Germany
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                    [country] => Germany
                )
        )
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-unique" annotations="chunk:false">
  <title>PDO::FETCH_UNIQUE (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_UNIQUE</constant> utilise la première colonne pour indexer les enregistrements,
   renvoyant 1 enregistrement par valeur d'index. Ce mode de récupération ne fonctionne qu'avec
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Lorsqu'il est combiné avec <constant>PDO::FETCH_GROUP</constant>, les deux modes utiliseront
   la même colonne, rendant la combinaison de ces modes inutile.
  </simpara>
  <simpara>
   Cette récupération doit être combinée avec l'un des
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant> ou
   <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   Si aucun mode de récupération de la liste ci-dessus n'est donné, le mode de récupération par défaut actuel
   pour la <classname>PDOStatement</classname> sera utilisé.
  </simpara>
  <simpara>
   Lorsqu'il est utilisé avec une colonne qui est connue pour être unique (comme l'ID d'enregistrement), ce
   mode offre la possibilité de renvoyer rapidement des résultats indexés par cette valeur.
  </simpara>
  <note>
   <simpara>
    Si la première colonne n'est pas unique, des valeurs seront perdues. La ou les valeur(s) qui sont
    perdues doivent être considérées comme indéfinies.
   </simpara>
  </note>
  <caution>
   <simpara>
    Le filtrage des enregistrements doit être effectué dans SQL si possible.La base de données utilisera
    des index pour optimiser ce processus et ne renvoyer que les enregistrements requis.
    Sélectionner plus d'enregistrements que nécessaire dans la base de données peut augmenter considérablement
    l'utilisation de la mémoire et le temps de requête pour des ensembles de résultats plus volumineux.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
  <simpara>
   Dans l'exemple ci-dessus, il est notable que la première colonne est omise du
   tableau pour chaque ligne, n'étant disponible que comme clé. Elle peut être incluse en
   répétant la colonne, comme dans l'exemple suivant :
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [userid] => 104
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [userid] => 105
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [userid] => 107
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
 </section>

</section>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
