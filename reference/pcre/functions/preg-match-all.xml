<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/pcre.xml, last change in rev 1.3 -->
<!-- last change to 'preg-match-all' in en/ tree in rev 1.2 -->
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>Expression r&eacute;guli&egrave;re globale</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>preg_match_all</methodname>
      <methodparam><type>string</type><parameter>pattern</parameter></methodparam>
      <methodparam><type>string</type><parameter>subject</parameter></methodparam>
      <methodparam><type>array</type><parameter>matches</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>preg_match_all</function> analyse <parameter>subject</parameter>
     pour trouver l'expression <parameter>pattern</parameter>
     et met les r&eacute;sultats dans <parameter>matches</parameter>,
     dans l'ordre sp&eacute;cifi&eacute; par <parameter>order</parameter>.
    </para>
    <para>
     Apr&egrave;s avoir trouv&eacute; un premier r&eacute;sultat,
     la recherche continue jusqu'&agrave; la fin de la cha&icirc;ne.
    </para>
    <para>
     <parameter>order</parameter> peut prendre une des deux valeurs suivantes 
     (notez bien qu'il est incoh&eacute;rent d'utiliser 
     <constant>PREG_PATTERN_ORDER</constant> avec 
     <constant>PREG_SET_ORDER</constant> ) :
     <variablelist>
      <varlistentry>
       <term><constant>PREG_PATTERN_ORDER</constant></term>
       <listitem>
        <para>
          L'ordre est tel que $matches[0] est un tableau qui
          contient les r&eacute;sultats qui satisfont le masque
          complet, $matches[1] est un tableau qui contient les
          r&eacute;sultats qui satisfont la premi&egrave;re
          parenth&egrave;se capturante, etc..
	 <example>
	  <title>Exemple avec <function>preg_match_all</function> 
	  et <constant>PREG_PATTERN_ORDER</constant>
	  </title>
	  <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<b>exemple : </b><div align=left>un test</div>", 
                 $out, 
                 PREG_PATTERN_ORDER);
  print $out[0][0].", ".$out[0][1]."\n";
  print $out[1][0].", ".$out[1][1]."\n";
?>
]]>


	  </programlisting>
	 </example>
	 Cet exemple va afficher :
	 <example>
      <title>Resultat avec <constant>PREG_PATTERN_ORDER</constant></title>
	   <literallayout>
	    <computeroutput>
 <![CDATA[
<b>exemple : </b>, <div align=left>un test</div>
exemple : , un test
]]>
	   </computeroutput>
      </literallayout>
	 </example>
      Ainsi, $out[0] est un tableau qui contient les r&eacute;sultats qui
      satisfont le masque complet, et $out[1] est un tableau qui contient
      les balises entre &gt; et &lt;.
 	 </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><constant>PREG_SET_ORDER</constant></term>
     <listitem>
	  <para>
        Les r&eacute;sultats sont class&eacute;s de telle
        fa&ccedil;on que $matches[0] contient la premi&egrave;re
        s&eacute;rie de r&eacute;sultat, $matches[1] contient la
        deuxi&egrave;me s&eacute;rie de r&eacute;sultat, etc...
	    <example>
  	     <title>Exemple avec <function>preg_match_all</function>
  	     et <constant>PREG_SET_ORDER</constant></title>
   	     <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<b>exemple : </b><div align=left>un test</div>", 
                 $out, 
                 PREG_SET_ORDER);
  print $out[0][0].", ".$out[0][1]."\n";
  print $out[1][0].", ".$out[1][1]."\n";
?>
]]>
	     </programlisting>
	    </example>
	    Cet exemple va afficher :
	    <example>
    	 <title>R&eacute;sultat avec <constant>PREG_SET_ORDER</constant></title>
   	     <programlisting role="php">
<![CDATA[
<b>exemple : </b>, exemple : 
<div align=left>un test</div>, un test
]]>	     
		 </programlisting>
	    </example>
 	    Dans ce cas, $matches[0] est la premi&egrave;re s&eacute;rie de
 	    r&eacute;sultat, et $matches[0][0] contient le texte qui satisfait
 	    le masque complet, $matches[0][1] contient le texte de la
 	    premi&egrave;re parenth&egrave;se capturante, etc... De m&ecirc;me,
 	    $matches[1] contient le texte qui satisfait le masque complet, etc...
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>PREG_OFFSET_CAPTURE</constant></term>
       <listitem>
        <simpara>
         Si cette option est activ&eacute;e, toutes les sous cha&icirc;nes qui satisfont
         le masque seront aussi identifi&eacute;es par leur offset. Notez que cela
         modifie le format de la valeur retourn&eacute;e , puisque chaque &eacute;l&eacute;ment
         de r&eacute;ponse devient un tableau contenant la sous-cha&icirc;ne r&eacute;sultat,
         &agrave; l'index <literal>0</literal> dans la cha&icirc;ne <parameter>subject</parameter> 
         constant <literal>1</literal>. Cette option a &eacute;t&eacute; ajout&eacute;e en &php; 4.3.0 .
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
      Si <parameter>order</parameter> est omis, PREG_PATTERN_ORDER est
      utilis&eacute; par d&eacute;faut.
    </para>
    <para>
     <function>preg_match_all</function> retourne le nombre de
     r&eacute;sultat qui satisfont le masque complet, ou &false;
     en cas d'&eacute;chec ou d'erreur.
    </para>
    <para>
     <example>
      <title>
        Extraction de tous les num&eacute;ros de t&eacute;l&eacute;phone d'un texte.
      </title>
      <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
               "Appelez 555-1212 ou 1-800-555-1212", $phones);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Recherche les couples de balises HTML (gourmand)</title>
      <programlisting role="php">
 <![CDATA[
<?php
// Cet exemple utilise les r&eacute;f&eacute;rences arri&egrave;res (\\2).
// Elles indiquent &agrave; l'analyseur qu'il doit trouver quelquechose qu'il
// a d&eacute;j&agrave; rep&eacute;r&eacute; un peu plus t&ocirc;t
// le nombre 2 indique que c'est le deuxi&egrave;me jeu de parenth&egrave;ses
// capturante qui doit &ecirc;tre utilis&eacute; (ici, ([\w]+)).
//  L'antislash est n&eacute;cessaire ici, car la cha&icirc;ne est entre guillemets doubles

  $html = "<B>Texte en gras</B><a href=salut.html>clique moi</a>";

preg_match_all ("/(<([\w]+)[^>]*>)(.*)(<\/\\2>)/", $html, $matches);

for ($i=0; $i< count($matches[0]); $i++) {
  echo "Trouv&eacute; : ".$matches[0][$i]."\n";
  echo "partie 1 : ".$matches[1][$i]."\n";
  echo "partie 2 : ".$matches[3][$i]."\n";
  echo "partie 3 : ".$matches[4][$i]."\n\n";
}
?>
]]>
      </programlisting>
     </example>
     Cet exemple va produire :
     <computeroutput>
 <![CDATA[
Trouv&eacute; : <B>Texte en gras</B>
partie 1 : <B>
partie 2 : Texte en gras
partie 3 : </B>

Trouv&eacute; : <a href=salut.html>clique moi</a>
partie 1 : <a href=salut.html>
partie 2 : clique moi
partie 3 : </a>
]]>
     </computeroutput>
    </para>
    <simpara>
     Voir aussi
     <function>preg_match</function>,
     <function>preg_replace</function> et
     <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
