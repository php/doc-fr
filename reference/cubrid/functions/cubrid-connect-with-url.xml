<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 22492de2eede0a31a4ac486489d5475e1536354d Maintainer: lacatoire Status: ready -->
<!-- Reviewed: no -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="function.cubrid-connect-with-url">
 <refnamediv>
  <refname>cubrid_connect_with_url</refname>
  <refpurpose>Établit l'environnement pour une connexion au serveur CUBRID</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>resource</type><methodname>cubrid_connect_with_url</methodname>
   <methodparam><type>string</type><parameter>conn_url</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>userid</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>passwd</parameter></methodparam>
   <methodparam choice="opt"><type>bool</type><parameter>new_link</parameter><initializer>&false;</initializer></methodparam>
  </methodsynopsis>
  <simpara>
   La fonction <function>cubrid_connect_with_url</function> est utilisée pour préparer
   l'environnement pour la connexion au serveur en utilisant les informations de connexion
   passées avec des arguments dans l'URL. Si la fonctionnalité HA est active pour CUBRID,
   il faut spécifier les informations de connexion du serveur de secours, qui sera utilisé
   comme backup lorsqu'une erreur survient. Si le nom d'utilisateur et le mot de passe
   ne sont pas fournis, alors la connexion "PUBLIC" sera établie par défaut.
  </simpara>
  <simpara>
   &lt;url&gt; ::= CUBRID:&lt;host&gt;:&lt;db_name&gt;:&lt;db_user&gt;:&lt;db_password&gt;:[?&lt;properties&gt;]
  </simpara>
  <simpara>
   &lt;properties&gt; ::= &lt;property&gt; [&amp;&lt;property&gt;]
  </simpara>
  <simpara>
   &lt;properties&gt; ::= alhosts=&lt;alternative_hosts&gt;[ &amp;rctime=&lt;time&gt;]
  </simpara>
  <simpara>
   &lt;properties&gt; ::= login_timeout=&lt;milli_sec&gt;
  </simpara>
  <simpara>
   &lt;properties&gt; ::= query_timeout=&lt;milli_sec&gt;
  </simpara>
  <simpara>
   &lt;properties&gt; ::= disconnect_on_query_timeout=true|false
  </simpara>
  <simpara>
   &lt;alternative_hosts&gt; ::= &lt;standby_broker1_host&gt;:&lt;port&gt; [,&lt;standby_broker2_host&gt;:&lt;port&gt;]
  </simpara>
  <simpara>
   &lt;host&gt; := HOSTNAME | IP_ADDR
  </simpara>
  <simpara>
   &lt;time&gt; := SECOND
  </simpara>
  <simpara>
   &lt;milli_sec&gt; := MILLI SECOND
  </simpara>
  <simplelist>
   <member>host : Un nom d'hôte ou une adresse IP vers la base de données principale</member>
   <member>db_name : Un nom de base de données</member>
   <member>db_user : Un nom d'utilisateur pour la base de données</member>
   <member>db_password : Le mot de passe associé à l'utilisateur</member>
   <member>
    alhosts : spécifie le courtier d'information pour le serveur de secours,
    qui sera utilisé comme backup lorsqu'il devient impossible de se connecter au
    serveur courant. Il est possible de spécifier plusieurs courtiers comme backup et la connexion
    aux courtiers se fera dans l'ordre d'alhosts
   </member>
   <member>
    rctime : un intervalle pendant lequel il sera tenté de se connecter
    au courtier actif lorsqu'une erreur survient. Après qu'une erreur est survenue,
    le système se connecte au courtier spécifié par althosts, met fin à la transaction,
    et tente une connexion au courtier actif de la base de données principale à chaque
    intervalle rctime. La valeur par défaut est 600 secondes.
   </member>
   <member>
    login_timeout : Valeur du délai maximal d'attente (unité : mseconde) pour l'identification
    à la base de données. Par défaut, cette valeur vaut 0, ce qui signifie que l'on attend
    indéfiniment.
   </member>
   <member>
    query_timeout : Valeur du délai maximal d'attente (unité : mseconde) pour l'exécution
    de la requête. Une fois cette valeur atteinte, un message pour annuler la requête
    envoyée au serveur est envoyé. La valeur retournée peut dépendre de la configuration
    de disconnect_on_query_timeout ; même si le message pour annuler
    la requête a été envoyé au serveur, la requête peut réussir.
   </member>
   <member>
    disconnect_on_query_timeout : Configure une valeur déterminant si l'on doit retourner
    immédiatement une erreur pour les fonctions exécutées après le délai maximal d'attente.
    La valeur par défaut est &false;.
   </member>
  </simplelist>
  <note>
   <simpara>
    Les caractères <literal>?</literal> et <literal>:</literal>
    utilisés comme identifiants dans les URLs de connexion PHP ne peuvent
    être inclus dans le mot de passe. Voici un exemple de mot de passe
    invalide, car utilisant les caractères "<literal>?:</literal>" dans l'URL de connexion.
   </simpara>
   <simpara>
    $url = "CUBRID:localhost:33000:tdb:dba:12?:?login_timeout=100";
   </simpara>
   <simpara>
    Les mots de passe contenant le caractère <literal>?</literal> ou le
    caractère <literal>:</literal> peuvent être passés en tant que paramètre séparé.
   </simpara>
   <simpara>
    $url = "CUBRID:localhost:33000:tbd:::?login_timeout=100";
   </simpara>
   <simpara>
    $conn = cubrid_connect_with_url($url, "dba", "12?");
   </simpara>
   <simpara>
    Si le nom d'utilisateur ou le mot de passe est vide, l'on ne doit
    pas supprimer les "<literal>:</literal>" ; voici un exemple :
   </simpara>
   <simpara>
    $url = "CUBRID:localhost:33000:demodb:::";
   </simpara>
  </note>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <variablelist>
   <varlistentry>
    <term><parameter>conn_url</parameter></term>
    <listitem><simpara>Une &string; contenant les informations de connexion au serveur.</simpara></listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>userid</parameter></term>
    <listitem><simpara>Le nom d'utilisateur de la base de données.</simpara></listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>passwd</parameter></term>
    <listitem><simpara>Le mot de passe de l'utilisateur.</simpara></listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>new_link</parameter></term>
    <listitem>
     <simpara>
      Si un second appel est effectué à la fonction
      <function>cubrid_connect_with_url</function> avec les mêmes arguments,
      aucune nouvelle connexion ne sera établie, et l'identifiant de la
      connexion déjà ouverte sera retourné à la place. Le paramètre
      <parameter>new_link</parameter> modifie ce comportement et fera que la fonction
      <function>cubrid_connect_with_url</function> ouvre toujours une nouvelle
      connexion, y compris si la fonction <function>cubrid_connect_with_url</function>
      a déjà été appelée avec les mêmes arguments.
     </simpara>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <simpara>
   Identifiant de connexion, en cas de succès,&return.falseforfailure;.
  </simpara>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Exemple avec <function>cubrid_connect_with_url</function></title>
   <programlisting role="php">
<![CDATA[
<?php
$conn_url = "CUBRID:localhost:33000:demodb:dba::";
$con = cubrid_connect_with_url($conn_url);

if ($con) {
   echo "Connexion avec succès.";
   cubrid_execute($con, "create table person(id int,name char(16))");
   $req =cubrid_execute($con, "insert into person values(1,'James')");

   if ($req) {
      cubrid_close_request($req);
      cubrid_commit($con);
   } else {
      cubrid_rollback($con);
   }
   cubrid_disconnect($con);
}
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Exemple avec <function>cubrid_connect_with_url</function></title>
   <programlisting role="php">
<![CDATA[
<?php
$conn_url = "CUBRID:127.0.0.1:33000:demodb:dba::?login_timeout=100";
$con = cubrid_connect_with_url ($conn_url);

if ($con) {
   echo "Connexion avec succès.";
   cubrid_execute($con, "create table person(id int,name char(16))");
   $req =cubrid_execute($con, "insert into person values(1,'James')");

   if ($req) {
      cubrid_close_request($req);
      cubrid_commit($con);
   } else {
      cubrid_rollback($con);
   }
   cubrid_disconnect($con);
}
?>
]]>
   </programlisting>
  </example>

 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <simplelist>
   <member><function>cubrid_connect</function></member>
   <member><function>cubrid_pconnect</function></member>
   <member><function>cubrid_pconnect_with_url</function></member>
   <member><function>cubrid_disconnect</function></member>
   <member><function>cubrid_close</function></member>
  </simplelist>
 </refsect1>

</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
