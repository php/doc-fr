<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 876a6a393125efc9d771cebdae1c02fec37c8ef7 Maintainer: Fan2Shrek Status: ready -->
<!-- Reviewed: yes -->
<reference xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="class.commonmark-cql" role="class">

 <title>La classe CommonMark\CQL</title>
 <titleabbrev>CommonMark\CQL</titleabbrev>

 <partintro>

<!-- {{{ CommonMark\Parser intro -->
  <section xml:id="commonmark-cql.intro">
   &reftitle.intro;
   <simpara>
    Le CommonMark Query Language est un DSL pour décrire comment voyager à travers un arbre de nœuds CommonMark implémenté comme un analyseur et un compilateur pour un petit ensemble d'instructions, et une machine virtuelle pour exécuter ces instructions.
   </simpara>
   <formalpara>
    <title>Chemins :</title>
     <para>
      Dans sa forme la plus simpliste, une requête CQL combine les chemins suivants et <literal>/</literal> pour décrire comment voyager à travers un arbre :
      <simplelist>
       <member>firstChild</member>
       <member>lastChild</member>
       <member>previous</member>
       <member>next</member>
       <member>parent</member>
      </simplelist>
      Par exemple, <literal>/firstChild/lastChild</literal> voyage au dernier nœud enfant du premier nœud enfant.
     </para>
   </formalpara>
   <formalpara>
   <title>Boucles</title>
   <para>
    CQL peut effectuer des boucles, par exemple à travers les enfants ou les frères et sœurs d'un nœud particulier, en utilisant le chemin <literal>children</literal>, ou <literal>siblings</literal>. Par exemple, <literal>/firstChild/children</literal> parcourra tous les enfants du premier nœud enfant.
   </para>
   </formalpara>
   <formalpara>
    <title>Sous-requêtes</title>
     <para>
      CQL peut être instruit de voyager en utilisant une sous-requête comme <literal>[/firstChild]</literal>. Par exemple, <literal>/firstChild/children[/firstChild]</literal> voyagera au premier nœud enfant de tous les enfants du premier nœud enfant.
     </para>
   </formalpara>
   <formalpara>
    <title>Contraintes de boucle</title>
     <para>
      En bouclant, CQL peut être instruit de restreindre le chemin parcouru aux nœuds d'un type particulier. Par exemple <literal>/children(BlockQuote)</literal> voyagera aux enfants d'un nœud où le type est <literal>BlockQuote</literal>. Les types suivants sont reconnus (insensibles à la casse) :
      <simplelist>
       <member>BlockQuote</member>
       <member>List</member>
       <member>Item</member>
       <member>CodeBlock</member>
       <member>HtmlBlock</member>
       <member>CustomBlock</member>
       <member>Paragraph</member>
       <member>Heading</member>
       <member>ThematicBreak</member>
       <member>Text</member>
       <member>SoftBreak</member>
       <member>LineBreak</member>
       <member>Code</member>
       <member>HtmlInline</member>
       <member>CustomInline</member>
       <member>Emphasis</member>
       <member>Strong</member>
       <member>Link</member>
       <member>Image</member>
      </simplelist>
      Les types peuvent être utilisés comme une union, par exemple <literal>/children(BlockQuote|List)</literal> voyagera aux enfants d'un nœud où le type est <literal>BlockQuote</literal> ou <literal>List</literal>. Les types, ou unions de types, peuvent également être niés. Par exemple <literal>/children(~BlockQuote)</literal> voyagera aux enfants d'un nœud où le type n'est pas <literal>BlockQuote</literal>, et <literal>/children(~BlockQuote|Paragraph)</literal> voyagera aux enfants d'un nœud où le type n'est pas <literal>BlockQuote</literal> ou <literal>Paragraph</literal>.
     </para>
   </formalpara>
   <formalpara>
    <title>Contraintes de chemins</title>
     <para>
      CQL peut être instruit de créer une boucle pour voyager à un nœud d'un type particulier, à un chemin particulier. Par exemple, <literal>/firstChild(BlockQuote)</literal> voyagera au premier nœud enfant où le type est <literal>BlockQuote</literal>. Il est à noter que comme d'autres boucles pour <literal>children</literal> et <literal>siblings</literal>, ce type de chemin ne peut être suivi que par une sous-requête.
     </para>
   </formalpara>
   <formalpara>
    <title>Notes d'implémentation</title>
    <para>
     Bien que CQL ait été implémenté en tant que partie de l'extension PHP CommonMark, il est séparé de PHP et n'utilise pas la machine virtuelle de PHP ou la représentation interne des valeurs.
   </para>
   </formalpara>
  </section>
<!-- }}} -->

  <section xml:id="commonmark-cql.synopsis">
   &reftitle.classsynopsis;

<!-- {{{ Synopsis -->
   <classsynopsis>
    <ooclass><classname>CommonMark\CQL</classname></ooclass>

<!-- {{{ Class synopsis -->
    <classsynopsisinfo>
     <ooclass>
      <classname>CommonMark\CQL</classname>
     </ooclass>
    </classsynopsisinfo>
<!-- }}} -->

    <classsynopsisinfo role="comment">&Constructor;</classsynopsisinfo>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('commonmark-cql.construct')/db:refsect1[@role='description']/descendant::db:constructorsynopsis[not(@role='procedural')])"/>

    <classsynopsisinfo role="comment">&Methods;</classsynopsisinfo>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('class.commonmark-cql')/db:refentry/db:refsect1[@role='description']/descendant::db:methodsynopsis[not(@role='procedural')])"/>
   </classsynopsis>
<!-- }}} -->

  </section>

 </partintro>

  &reference.cmark.commonmark.cql.construct;
  &reference.cmark.commonmark.cql.invoke;

</reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
