<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<refentry id="function.sqlite-create-aggregate">
 <refnamediv>
  <refname>sqlite_create_aggregate</refname>
  <refpurpose>Enregistre une UDF agregeante pour les requ&ecirc;tes SQLite</refpurpose>
 </refnamediv>
 <refsect1>
  <title>Description</title>
  <methodsynopsis>
   <type>bool</type><methodname>sqlite_create_aggregate</methodname>
   <methodparam><type>resource</type><parameter>dbhandle</parameter></methodparam>
   <methodparam><type>string</type><parameter>function_name</parameter></methodparam>
   <methodparam><type>mixed</type><parameter>step_func</parameter></methodparam>
   <methodparam><type>mixed</type><parameter>finalize_func</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>num_args</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>sqlite_create_aggregate</function> est similaire &agrave;
   <function>sqlite_create_function</function>, car elle enregistre une
   fonction qui sera utilis&eacute;e pour calculer un r&eacute;sultat agr&eacute;g&eacute; sur plusieurs
   lignes d'une requ&ecirc;te.
  </para>
  <para>
   La diff&eacute;rence principale entre cette fonction et 
   <function>sqlite_create_function</function> est que deux fonctions sont n&eacute;cessaires
   pour g&eacute;rer les agr&eacute;gations : <parameter>step_func</parameter> est
   appel&eacute;e pour chaque ligne du r&eacute;sultat. Votre fonction &php; doit accumuler
   le r&eacute;sultat, et le stocker dans le contexte d'agr&eacute;gation.
   Une fois que toutes les lignes ont &eacute;t&eacute; appel&eacute;es, 
   <parameter>finalize_func</parameter> sera appel&eacute;e, et elle doit alors
   lire les donn&eacute;es dans ce contexte d'agr&eacute;gation, et en retourner le r&eacute;sultat.
  </para>
  <para>
   <example>
    <title>Exemple d'UDF SQLite : taille maximale de cha&icirc;ne</title>
    <programlisting role="php">
<![CDATA[
<?php
$data = array(
   'one',
   'two',
   'three',
   'four'
   'five'
   'six',
   'seven',
   'eight',
   'nine'
   'ten'
   );
$db = sqlite_open(':memory:');
sqlite_query($db, "CREATE TABLE strings(a)");
foreach ($data as $str) {
  sqlite_query($db, "INSERT INTO strings VALUES('" .
    sqlite_escape_string($str) . "')");
}

function max_len_step(&$context, $string) {
  if (strlen($string) > $context) {
    $context = strlen($string);
  }
}

function max_len_finalize(&$context) {
  return $context;
}

sqlite_create_aggregate($db, 'max_len', 'max_len_step', 'max_len_finalize');

var_dump(sqlite_array_query($db, 'SELECT max_len(a) from strings'));

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Dans cet exemple, nous cr&eacute;ons une fonction d'agr&eacute;gation qui va calculer
   la taille de la plus longue cha&icirc;ne dans l'une des colonnes de la table.
   Pour chaque ligne, la fonction <literal>max_len_step</literal> 
   est appel&eacute;e, et re&ccedil;oit le param&egrave;tre <parameter>context</parameter>. Le contexte
   est une autre variable &php;, et il peut contenir un tableau ou m&ecirc;me un objet.
   Dans notre exemple, nous l'utilisons pour stocker la taille maximale 
   de la colonne courante. Si <parameter>string</parameter> est plus grand
   que la valeur maximale que nous avons enregistr&eacute;, nous modifions notre
   contexte en cons&eacute;quence.
  </para>
  <para>
   Une fois que toutes les lignes ont &eacute;t&eacute; trait&eacute;es, SQLite appelle la fonction
   <literal>max_len_finalize</literal> pour d&eacute;terminer le r&eacute;sultat de 
   l'agr&eacute;gation. Nous pourrions alors effectuer plusieurs calculs en fonction 
   des donn&eacute;es que nous avons r&eacute;colt&eacute; dans <parameter>context</parameter>.
   Dans notre exemple simple, 
   nous avons calcul&eacute; le r&eacute;sultat au fur et &agrave; mesure de la progression de la requ&ecirc;te,
   ce qui nous permet de n'avoir qu'&agrave; retourner la valeur de notre contexte.
  </para>
  <note>
   <para>
    L'exemple ci-dessus ne fonctionnera pas correctement si 
    une colonne contient une donn&eacute;e binaire. Reportez-vous &agrave; la fonction
    <function>sqlite_udf_decode_binary</function> pour plus de d&eacute;tails, et d'un
    exemple pour travailler avec des cha&icirc;nes binaires.
   </para>
  </note>
  <tip>
   <para>
    Il n'est pas recommand&eacute; de stocker une copie des valeurs dans le contexte,
    puis de les traiter &agrave; la fin, car cela conduirait SQLite &agrave; consommer beaucoup
    de m&eacute;moire : imaginez simplement la quantit&eacute; de m&eacute;moire que prendrons vos millions
    de lignes de 32 caract&egrave;res en fin de requ&ecirc;te.
   </para>
  </tip>
  <tip>
   <para>
    Vous pouvez utiliser <function>sqlite_create_function</function> et
    <function>sqlite_create_aggregate</function> pour remplacer des fonctions
    natives SQLite.
   </para>
  </tip>
  <para>
   Voir aussi
   <function>sqlite_create_function</function>,
   <function>sqlite_udf_encode_binary</function> et
   <function>sqlite_udf_decode_binary</function>.
  </para>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
