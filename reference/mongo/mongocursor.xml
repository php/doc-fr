<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 9bd7ff84794cde343127e864da941458fb305069 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

<phpdoc:classref xml:id="class.mongocursor" xmlns:phpdoc="http://php.net/ns/phpdoc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude">

 <title>&class.theclass; <classname>MongoCursor</classname></title>
 <titleabbrev>MongoCursor</titleabbrev>

 <partintro>

  <!-- {{{ Mongocursor intro -->
  <section xml:id="mongocursor.intro">
   &reftitle.intro;
   <para>
    L'objet de résultat d'une requête de base de données.
   </para>
   <para>
    Un <classname>MongoCursor</classname> a 2 états différents : Avant et après
    la requête. Un curseur peut être créé manuellement en appelant le constructeur,
    mais il est générallement créé en appelant la fonction
    <function>MongoCollection::find</function>. Lorsqu'un curseur est créé,
    il n'a pas encore contacté la base de données, il est dans l'état "avant requête".
    Dans cet état, le client peut spécifier les paramètres de sa requête,
    comme les limitations, les exceptions, l'ordre de tri ainsi que d'autres
    options avancées.
   </para>
   <para>
    Lorsque le client tente de récupérer un résultat (en appelant la fonction
    <function>MongoCursor::next</function>, directement ou indirectement),
    le curseur passe à l'état "après requête". À ce moment là, les seules
    fonctions disponibles sont les fonctions <classname>Iterator</classname>,
    <function>MongoCursor::hasNext</function>, et
    <function>MongoCursor::getNext</function>.
   </para>
   <para>
    <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find()->limit(10);

// la base n'a pas encore été interrogée,
// il est donc encore temps d'ajouter des options
$cursor = $cursor->sort(array("a" => 1));

var_dump($cursor->getNext());
// maintenant, la base a été interrogée, et les options ne sont plus prises en compte

// Cet commnande va produire une exception :
$cursor->skip(4);
?>
]]>
    </programlisting>
   </para>
  </section>
  <!-- }}} -->

  <section xml:id="mongocursor.synopsis">
   &reftitle.classsynopsis;

   <!-- {{{ Synopsis -->
   <classsynopsis>
    <ooclass><classname>MongoCursor</classname></ooclass>

    <!-- {{{ Class synopsis -->
    <classsynopsisinfo>
     <ooclass>
      <modifier>implements</modifier>
      <classname>Iterator</classname>
     </ooclass>
    </classsynopsisinfo>
    <!-- }}} -->
    
    <classsynopsisinfo role="comment">Champs statiques</classsynopsisinfo>
    <fieldsynopsis>
     <modifier>static</modifier>
     <type>boolean</type>
     <varname>slaveOkay</varname>
     <initializer>&false;</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>static</modifier>
     <type>integer</type>
     <varname>timeout</varname>
     <initializer>20000</initializer>
    </fieldsynopsis>
    
    <classsynopsisinfo role="comment">&Methods;</classsynopsisinfo>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('class.mongocursor')/db:refentry/db:refsect1[@role='description']/descendant::db:methodsynopsis[1])" />
   </classsynopsis>
   <!-- }}} -->

  </section>

   <section>
    <title>Variables statiques</title>

   <variablelist>
    <varlistentry>
     <term><property>MongoCursor::slaveOkay</property></term>
     <listitem>
      <para>
       Est ce que la requête doit avoir le drapeau "slaveOkay" activé, ce qui permet
       des lectures sur l'esclave (les esclaves sont par défaut déstinés à des sauvegardes
       et donc inaccessibles en lectures). Peut être surchargé avec
       <function>MongoCursor::slaveOkay</function>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><property>MongoCursor::timeout</property></term>
     <listitem>
      <para>
       Affecte le timeout en millisecondes pour les réponses des bases de données. Pour
       un timeout infini, utilisez -1. Peut être surchargé avec
       <function>MongoCursor::timeout</function>. Ceci ne provoque pas une annulation de
       l'opération par le serveur MongoDB mais fait en sorte que le pilote s'arrête
       d'attendre une réponse et envoie une MongoCursorTimeoutException.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>

  <section>
   &reftitle.seealso;
   <para>
    Documentation de MongoDB <link xlink:href="&url.mongodb.dochub.cursors;">concernant les
    curseurs</link>.
   </para>
  </section>
  
 </partintro>

 &reference.mongo.entities.mongocursor;

</phpdoc:classref>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
