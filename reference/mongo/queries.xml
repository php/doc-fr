<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: b18d2da96be56a85f8abb9f4045cbd6c40c19203 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<section xml:id="mongo.queries" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Interrogation</title>
 
 <section>
  <title>Interrogation sur un _id</title>
  <para>
   Chaque objet inséré se voit assigné automatiquement un champ unique _id,
   qui est bien utile pour être utilisé dans les requêtes..
  </para>
  <para>
   Supposez que vous voulez trouver un document que vous venez tout juste d'insérer.
   L'insertion ajoute un champ _id au document, aussi, vous pouvez effectuer votre
   requête de la sorte :
   <programlisting role="php">
<![CDATA[
<?php

$person = array("name" => "joe");

$people->insert($person);

// Maintenant, $joe a un champ _id
$joe = $people->findOne(array("_id" => $person['_id']));

?>
]]>
   </programlisting>
  </para>
  <para>
   Tant que l'utilisateur ne l'a pas spécifié autrement, le champ _id
   est un <classname>MongoId</classname>. L'erreur la plus courante
   est d'essayer d'utiliser une chaîne qui correspond à un
   <classname>MongoId</classname>. Gardez à l'esprit que cet identifiant
   a 2 types de données différents, et ne correspond pas l'un l'autre,
   de la même façon que la chaîne "array()" n'est pas la même chose
   qu'un tableau vide. Par exemple :
   <programlisting role="php">
<![CDATA[
<?php

$person = array("name" => "joe");

$people->insert($person);

// Convertion de l'_id en une chaîne
$pid = $person['_id'] . "";

// ECHEC - $pid est une chaîne, et non un MongoId
$joe = $people->findOne(array("_id" => $pid));

?>
]]>
   </programlisting>
  </para>
 </section>
 
 <section>
  <title>Les tableaux</title>
  <para>
   Les tableaux sont spéciaux à plus d'un titre. Tout d'abord, il y a 2 types
   utilisés par MongoDB : des tableaux "normaux" et des tableaux associatifs.
   Les tableaux associatifs peuvent avoir plusieurs types de clés et de valeurs.
   Les tableaux "normaux" sont définis comme tableaux dans ces indices numériques
   ascendants, en commençant par 0 et s'incrémentant de 1 pour chaque élément.
   Ces 2 types correspondent à ce que vous connaissez déjà comme type en PHP.
  </para>
  
  <para>
   Actuellement, si vous voulez sauvegarder la liste des récompenses
   dans un document, vous pouvez :
  </para>
  
  <programlisting role="php">
<![CDATA[
<?php

$collection->save(array("awards" => array("gold", "silver", "bronze")));

?>
]]>
  </programlisting>
  <para>
   Les requêtes peuvent effectuer des recherches directement dans les éléments.
   Supposez que nous souhaitons trouver tous les documents dont l'élément du
   tableau est à une valeur fournie. Par exemple, les documents sont la
   récompense est l'or, comme ceci :
  </para>
  <programlisting>
<![CDATA[
{ "_id" : ObjectId("4b06c282edb87a281e09dad9"), "awards" : ["gold", "silver", "bronze"]}
]]>
  </programlisting>
  <para>
   Ceci peut être effectué avec une requête simple, en ignorant le fait que "awards"
   est un tableau :
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find(array("awards" => "gold"));

?>
]]>
  </programlisting>
  
  <para>
   Supposez que vous interrogez la base de données avec un objet plus complexe,
   dont chaque élément du tableau sont eux-mêmes des objets, comme ceci :
  </para>
  
  <programlisting>
<![CDATA[
{ 
     "_id" : ObjectId("4b06c282edb87a281e09dad9"), 
     "awards" : 
     [
        {
            "first place" : "gold"
        },
        {
            "second place" : "silver" 
        },
        {
            "third place" :  "bronze"
        }
     ]
}
]]>
  </programlisting>
  <para>
  Continuons d'ignorer que c'est un tableau. Nous pouvons utiliser
  la notation basée sur les points pour interroger le sous-objet :
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find(array("awards.first place" => "gold"));

?>
]]>
  </programlisting>
  <para>
   Notez qu'il importe peu qu'il y ait un espace dans le nom du champ
   (bien qu'il convient de ne pas en mettre, juste pour rendre le code
   plus lisible).
  </para>
  
  <para>
   Vous pouvez également utiliser un tableau contenant plusieurs valeurs
   à chercher. Actuellement, si nous cherchons les documents "gold" et "copper",
   nous pouvons le faire comme ceci :
  </para>
  
  <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find(array("awards" => array('$in' => array("gold", "copper"))));

?>
]]>
  </programlisting>
  
 </section>
</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
