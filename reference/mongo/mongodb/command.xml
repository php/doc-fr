<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 7b95acba7cb67879373cbc659d9ef140e96e43b0 Maintainer: jpauli Status: ready -->
<!-- Reviewed: no -->

<refentry xml:id="mongodb.command" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <refnamediv>
  <refname>MongoDB::command</refname>
  <refpurpose>Exécute une commande de base de données</refpurpose>
 </refnamediv>
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <modifier>public</modifier> <type>array</type><methodname>MongoDB::command</methodname>
   <methodparam><type>array</type><parameter>data</parameter></methodparam>
   <methodparam><type>array</type><parameter>options</parameter></methodparam>
  </methodsynopsis>
  <para>
   Tout ce qui n'est pas une opération CRUD peut être effectué avec une commande
   de base de données. Besoin de connaitre la version de la base de données ?
   Il y a une commande pour cela. Besoin de faire une agrégation ? Il y a une
   commande pour cela. Besoin d'activer l'historisation ? Vous voyez l'idée ?
  </para>
  <para>
   Cette méthode est équivalente à :
   <programlisting role="php">
<![CDATA[
<?php

public function command($data) {
    return $this->selectCollection('$cmd')->findOne($data);
}

?>
]]>
   </programlisting>
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <parameter>data</parameter>
     </term>
     <listitem>
      <para>
       La requête à envoyer.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <parameter>options</parameter>
     </term>
     <listitem>
      <para>
       Options pour la commande. Actuellement, la seule option
       est <literal>timeout</literal>, qui est le nombre de secondes
       d'attente pour le client de la réponse de la base de données.
       Le fait de le définir à -1 fait qu'il attendra sans limite.
       Par défaut, ce sera <literal>MongoCursor::$timeout</literal>.
      </para>
     </listitem>
    </varlistentry>  
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>1.2.0</entry>
       <entry>
        Ajout du paramètre <literal>options</literal> avec une
        seule option : <literal>timeout</literal>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;  
  <para>
   Retourne la réponse de la base de données.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Exemple avec <function>MongoDB::command</function> et "distinct"</title>
   <para>
    Trouver tous les valeurs distinctes pour une clé.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$people = $db->people;

$people->insert(array("name" => "Joe", "age" => 4));
$people->insert(array("name" => "Sally", "age" => 22));
$people->insert(array("name" => "Dave", "age" => 22));
$people->insert(array("name" => "Molly", "age" => 87));

$ages = $db->command(array("distinct" => "people", "key" => "age"));

foreach ($ages['values'] as $age) {
    echo "$age\n";
}

?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
4
22
87
   </screen>
  </example>
  <example>
   <title>Exemple avec <function>MongoDB::command</function> et MapReduce</title>
   <para>
    Récupérer tous les utilisateurs avec au moins un événement "sale",
    et savoir le nombre de fois chacun de ces utilisateurs ont eu une vente.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

// Document d'événement simple
$events->insert(array("user_id" => $id,
    "type" => $type,
    "time" => new MongoDate(),
    "desc" => $description));

// Construit les fonctions map et reduce
$map = new MongoCode("function() { emit(this.user_id,1); }");
$reduce = new MongoCode("function(k, vals) { ".
    "var sum = 0;".
    "for (var i in vals) {".
        "sum += vals[i];".
    "}".
    "return sum; }");

$sales = $db->command(array(
    "mapreduce" => "events",
    "map" => $map,
    "reduce" => $reduce,
    "query" => array("type" => "sale")));

$users = $db->selectCollection($sales['result'])->find();

foreach ($users as $user) {
    echo "{$user['_id']} had {$user['value']} sale(s).\n";
}

?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
User 47cc67093475061e3d9536d2 had 3 sale(s).
User 49902cde5162504500b45c2c had 14 sale(s).
User 4af467e4fd543cce7b0ea8e2 had 1 sale(s).
   </screen>
   <note>
    <title>Utilisation de <classname>MongoCode</classname></title>
    <para>
     Cet exemple utilise la méthode <classname>MongoCode</classname>,
     qui prend également comme argument le scope. Cependant, actuellement,
     Mongo ne supporte pas l'utilisation d'un scope dans MapReduce. Si vous voulez
     utiliser des variables définies côté client dans les fonctions MapReduce,
     vous pouvez les ajouter au scope global en utilisant le champ optionnel scope
     avec la commande de la base de données. Voir
     <link xlink:href="&url.mongodb.dochub.mapreduce;">MapReduce</link> pour
     plus d'informations.
    </para>
   </note>
   <para>
    Si vous souhaitez utiliser MapReduce, Prajwal Tuladhar a créé une API
    pour les utilisateurs PHP de Mongo qui fournit une interface au lieu
    d'utiliser les commandes de base. Vous pouvez la télécharger depuis
    <link xlink:href="&url.mongodb.mapreduceapi;">Github</link>
    et il y a un
    <link xlink:href="&url.mongodb.mapreduceapi.blog;">article
    sur son blog</link> expliquant comment l'utiliser.
   </para>
  </example>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   La documentation principale MongoDB sur les
   <link xlink:href="&url.mongodb.dochub.commands;">commandes de base de
    données</link>.
   Aussi, quelques commandes individuelles :
   <link xlink:href="&url.mongodb.dochub.findandmodify;">findAndModify</link>,
   <link xlink:href="&url.mongodb.dochub.getlasterror;">getLastError</link>, et
   <link xlink:href="&url.mongodb.dochub.repair;">repair</link>.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
--> 
