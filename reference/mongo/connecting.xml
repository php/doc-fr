<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: fa909446a4cf15b5829ca87417db5ebcffc32a5c Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mongo.connecting" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Connection</title>
 
 <para>
  La connexion à MongoDB est aussi simple que cela : <literal>new MongoClient</literal>,
  mais il existe aussi plusieurs options et plusieurs configurations.
  La page sur la méthode <function>MongoClient::__construct</function> couvre
  toutes les options offertes par l'API, mais aussi, propose
  plusieurs cas pratiques.
 </para>
 
 <section xml:id="mongo.connecting.auth">
  <title>Authentification</title>
  <para>
   Si MongoDB est en fonctionnement avec l'option <literal>--auth</literal> ou
   l'option <literal>--keyFile</literal>, vous devez vous authentifier avant de
   faire n'importe quelle opération avec le driver. Vous pouvez vous authentifier
   via la connexion en spécifiant le nom d'utilisateur et le mot de passe
   soit dans l'URI de connexion, ou en utilisant les options
   <literal>"username"</literal> et <literal>"password"</literal> dans le constructeur
   <function>MongoClient::__construct</function>.
  </para>
  <example xml:id="mongo.connecting.auth-example">
   <title>Authentification sur la base de données "admin"</title>
   <programlisting role="php">
<![CDATA[
<?php
// Spécifie le nom d'utilisateur et le mot de passe dans l'URI de connexion (méthode préférée)
$m = new MongoClient("mongodb://${username}:${password}@localhost");

// Spécifie le nom d'utilisateur et le mot de passe via le tableau d'options (méthode alternative)
$m = new MongoClient("mongodb://localhost", array("username" => $username, "password" => $password));
?>
]]>
   </programlisting>
  </example>
  <para>
   Par défaut, le driver s'authentifiera sur la base de données <literal>admin</literal>.
   Vous pouvez vous authentifier sur une base de données différente en le spécifiant
   soit dans l'URI de connexion, soit via l'option <literal>"db"</literal> du constructeur
   <function>MongoClient::__construct</function>.
  </para>
  <example xml:id="mongo.connecting.auth-db-example">
   <title>Authentification sur une base de données normale</title>
   <programlisting role="php">
<![CDATA[
<?php
// Spécifie la base de données à utiliser dans l'URI de connexion (méthode préférée)
$m = new MongoClient("mongodb://${username}:${password}@localhost/myDatabase");

// Spécifie la base de données à utiliser via le tableau d'options (méthode alternative)
$m = new MongoClient("mongodb://${username}:${password}@localhost", array("db" => "myDatabase"));
?>
]]>
   </programlisting>
  </example>
  <para>
   Si votre connexion est interrompue, le driver tentera automatiquement une re-connexion
   ou une ré-authentification.
  </para>
 </section>
 
 <section xml:id="mongo.connecting.rs">
  <title>Paires de réplication</title>
  <para>
   Pour se connecter à une paire de réplication, vous devez spécifier
   au moins un membre de la paire et utiliser l'option <literal>"replicaSet"</literal>.
   Plusieurs serveurs doivent être délimités par une virgule.
  </para>
  <example xml:id="mongo.connecting.rs-example">
   <title>Liste du jeu de réplication</title>
   <programlisting role="php">
<![CDATA[
<?php

// Utilisation de plusieurs serveurs de la liste (méthode préférée)
$m = new MongoClient("mongodb://rs1.example.com:27017,rs2.example.com:27017/?replicaSet=myReplSetName");


// Utilisation d'un seul serveur de la liste
$m = new MongoClient("mongodb://rs1.example.com:27017", array("replicaSet" => "myReplSetName"));

// Utilisation de plusieurs serveurs de la liste
$m = new MongoClient("mongodb://rs1.example.com:27017,rs2.example.com:27017", array("replicaSet" => "myReplSetName"));
?>
]]>
   </programlisting>
  </example>
  <para>
   Le pilote PHP requêtera le(s) serveur(s) de base de données listé(s) pour vérifier qui
   est le primaire. Dès qu'il peut se connecter à au moins un hôte listé, et trouver un primaire,
   la connexion sera réussie. Dans le cas contraire, une
   <classname>MongoConnectionException</classname> est envoyée.
  </para>
  <tip>
   <para>
    Vous devriez toujours fournir une liste de partage contenant plus d'un membre
    du jeu de réplication. Pour une haute disponibilité, vous devriez partager
    avec au moins un serveur de chacun de vos centres de données.
   </para>
  </tip>
  <warning>
   <para>
    Les noms d'hôtes que vous spécifiez ici <emphasis>doivent</emphasis>
    correspondre aux noms fournis dans la configuration du jeu de réplication,
    car le driver utilise le nom tel que spécifié dans la configuration du jeu
    de réplication comme identifiant dans son mappage interne. Le fait de spécifier
    (par exemple) l'adresse IP au lieu du nom d'hôte configuré fera que le driver
    gardera une connexion pour à la fois le nom d'hôte et son adresse IP.
   </para>
  </warning>
  <para>
   Si le primaire devient indisponible, les secondaires ne deviendront pas
   primaires pendant ces quelques secondes. Pendant ce temps là
   (<link xlink:href="&url.mongodb.replica.failover;">20-60 secondes</link>),
   la connexion ne sera pas capable d'effectuer les opérations sur la base
   de données (les connexions aux secondaires pourront toujours effectuer des
   lectures) et une exception sera levée.
  </para>
  <note>
   <para>
    La <link linkend="mongo.readpreferences">préférence de lecture</link>
    par défaut est de ne lire que depuis le primaire. Lors du processus d'élection,
    il n'y a pas de primaire, et toutes les lectures échoueront.
   </para>
   <para>
    Il est recommandé d'utiliser la préférence de lecture
    <constant>MongoClient::RP_PRIMARY_PREFERRED</constant> pour les applications
    qui requièrent une haute disponibilité pour les lectures, vu que les
    lectures ne seront réalisées sur les secondaires que lorsqu'il n'y a aucun
    primaire de disponible.
   </para>
  </note>
  <para>
   Une fois le maître trouvé, essayer des lectures ou écritures permettra au pilote de
   détecter le nouveau primaire. Le pilote en fera alors sa connexion principale et continuera
   les opérations normalement.
  </para>
  <para>
   La santé et le statut d'un secondaire sont vérifiés toutes les 5 secondes
   (configurable avec la directive
   <link linkend="ini.mongo.ping-interval">mongo.ping_interval</link>)
   ou lorsque la prochaine opération survient après 5 secondes. La
   configuration sera de nouveau analysée lorsque le driver rencontre
   un problème lors d'une connexion à un serveur.
  </para>
  <para>
   Les failovers du jeu de réplication sont vérifiés toutes les 60 secondes
   (configurable avec la directive
   <link linkend="ini.mongo.is-master-interval">mongo.is_master_interval</link>),
   et lorsqu'une opération en écriture échoue avec des écritures reconnues.
  </para>
  
  <caution>
   <para>
    Les secondaires peuvent être derrière le primaire lors des opérations,
    aussi, votre application doit être capable de gérer les données périmées
    lors de l'utilisation de préférences de lecture autre que
    <constant>MongoClient::RP_PRIMARY</constant>.
   </para>
  </caution>
  
  <para>
   Pour plus d'informations sur les paires de réplication, reportez-vous à la
   <link xlink:href="&url.mongodb.replica;">documentation interne</link>.
  </para>
  
  <simplesect role="seealso">
   &reftitle.seealso;
   <simplelist>
    <member><xref linkend="mongo.readpreferences" /></member>
    <member><xref linkend="mongo.writeconcerns" /></member>
   </simplelist>
  </simplesect>
  
  <simplesect role="changelog">
   &reftitle.changelog;
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>1.0.9</entry>
       <entry>
        Ajout du support au jeu de réplication, et du failover automatique.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </simplesect>
  
 </section>
 
 <section xml:id="mongo.connecting.mongos">
  <title>Fragmentation</title>
  <para>
   Pour se connecter à un cluster fragmenté, vous devez spécifier une ou
   plusieurs instances <literal>mongos</literal> dans la chaîne de connexion.
   Les serveurs doivent être séparés par une virgule.
  </para>
  <example xml:id="mongo.connecting.mongos-example">
   <programlisting role="php">
<![CDATA[
<?php

// Utilisation d'un serveur depuis la liste
$m = new MongoClient("mongodb://mongos1.example.com:27017");

// Utilisation de plusieurs serveurs depuis la liste
$m = new MongoClient("mongodb://mongos1.example.com:27017,mongos2.example.com:27017");

?>
]]>
   </programlisting>
  </example>
  <para>
   Que le cluster fragmenté soit un serveur <literal>mongod</literal> simple
   ou un jeu complet de réplication, le processus de connexion du driver reste
   le même. Toutes les communications à la base de données seront dirigées
   vers <literal>mongos</literal>.
  </para>
  <para>
   Pour plus d'informations sur la fragmentation avec MongoDB, reportez-vous à cette
   <link xlink:href="&url.mongodb.docs.sharding;">documentation</link>.
  </para>
 </section>
 
 <section xml:id="mongo.connecting.uds">
  <title>Support des sockets de domaine</title>
  
  <para>
   MongoDB a un support interne des sockets de domaine Unix, et ouvrira
   le socket au démarrage, par défaut, situé dans le fichier
   <filename>/tmp/mongodb-&lt;port&gt;.sock.</filename>.
  </para>
  
  <para>
   Pour vous connecter au fichier de socket, specifiez le chemin dans la chaine de connexion
   MongoDB:
  </para>
  
  <example xml:id="mongo.connecting.uds-example">
   <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb:///tmp/mongo-27017.sock");
?>
]]>
   </programlisting>
  </example>
  
  <para>
   Si vous voulez vous authentifier sur une base de données (tel que décrit ci-dessous) en
   utilisant un socket, vous devez alors préciser un port égal à 0 comme cela l'analyseur
   sait où trouver la fin de la chaine de connexion. Vous pouvez également utiliser
   les options du constructeur.
  </para>
  
  <example xml:id="mongo.connecting.uds-auth-example">
   <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb://username:password@/tmp/mongo-27017.sock:0/foo");
?>
]]>
    </programlisting>
  </example>
  
  <simplesect role="changelog">
   &reftitle.changelog;
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>1.0.9</entry>
       <entry>
        Ajout du support des sockets de domaine Unix.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </simplesect>
  
 </section>
 
 <section xml:id="mongo.connecting.pools">
  <title>File d'attente de connexion (version 1.2.0-1.2.12 *seulement*)</title>
  <note>
   <para>
    Cette section n'est plus pertinente depuis la version 1.3.0 du driver,
    et n'est plus présente que dans un but d'historisation de l'information
    sur la façon dont la mise en file d'attente fonctionne.
   </para>
   <para>
    The latest versions of the driver have no concept of pooling anymore and
    will maintain only one connection per process, for each connection type
    (ReplicaSet/standalone/mongos), for each credentials combination.
   </para>
  </note>
  <para>
   La création de connexions est une des actions les plus lourdes réalisées
   par le driver. Cela peut prendre plusieurs millisecondes pour définir correctement
   une connexion, y compris sur un réseau rapide. Aussi, le driver tente de
   minimiser le nombre de nouvelles connexions créées en réutilisant les connexions
   depuis la file d'attente.
  </para>
  <para>
   Lorsqu'un utilisateur crée une nouvelle instance de la clase
   <classname>MongoClient</classname>, toutes les connexions nécessaires seront
   prises depuis leurs files d'attente (les connexions pour le jeu de réplication
   peuvent nécessiter plusieurs connexions, une pour chaque membre du jeu).
   Lorsque l'instance de la classe <classname>MongoClient</classname> sort du scope,
   les connexions seront remises dans la file d'attente. Lorsque le processus PHP
   existe, toutes les connexions de la file d'attente seront fermées.
  </para>
  <section>
   <title>"Pourquoi dois-je avoir autant de connexions ouvertes ?"</title>
   <para>
    La file d'attente de connexions peut générer un nombre important de connexions.
    Ceci est voulu, et, en utilisant un peu d'arithmétique, vous pouvez trouver
    le nombre de connexions qui sera créée. Il y a 3 facteurs qui affectent le
    nombre de connexions :
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>
       connections_per_pool
      </literal>
     </para>
     <para>
      Chaque file d'attente de connexions, créera, par défaut, un nombre illimité
      de connexions. Cela peut poser quelques soucis : si la file peut créer un
      nombre illimité de connexions, peut-elle en créer des centaines et ainsi,
      dépasser les descripteurs de fichiers du serveur ? En pratique, ceci est
      peu probable, sachant que chaque connexion inutilisée est replacée dans
      la file d'attente pour une réutilisation ultérieure, aussi, les futures
      connexions utiliseront la même connexion au lieu d'en créer une nouvelle.
      Sauf si vous créez volontairement des milliers de connexions à la fois
      sans les laisser sortir du scope, le nombre de connexions ouvertes devrait
      rester à un niveau raisonnable.
     </para>
     <para>
      Vous pouvez voir le nombre de connexions présentes dans la file d'attente
      en utilisant la méthode <function>MongoPool::info</function>.
      Ajouter les champs "in use" et "in pool" pour un serveur donné.
      Ce sera le nombre total de connexions pour cette file d'attente.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       pools_per_process
      </literal>
     </para>
     <para>
      Chaque adresse de serveur MongoDB sur lequel vous vous connectez
      utilise sa propre file d'attente de connexions. Par exemple, si votre nom
      d'hôte local est "example.net", une connexion à "example.net:27017", "localhost:27017",
      et "/tmp/mongodb-27017.sock" créera 3 files d'attente de connexions. Vous pouvez voir
      le nombre de files d'attentes de connexions ouvertes en utilisant la méthode
      <function>MongoPool::info</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       processes
      </literal>
     </para>
     <para>
      Chaque processus PHP a un jeu de files d'attente séparées. PHP-FPM et Apache
      créent généralement entre 6 et une douzaine de fils. Vérifiez votre configuration
      pour voir le nombre maximal de processus PHP pouvant être engendrés.
     </para>
     <para>
      Si vous utilisez PHP-FPM, le fait d'estimer le nombre de connexions peut être
      délicat car le processus va engendrer encore plus de fils à forte charge.
      Pour rester dans un contexte sécurisé, regardez le paramètre <literal>max_children</literal>
      et ajoutez-y <literal>spare_servers</literal> + <literal>start_servers</literal> (choisissez
      le nombre le plus important). Le résultat sera le nombre de processus PHP (et donc, le nombre
      de jeux de files d'attente) dont vous pourrez vous attendre.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Les trois variables ci-dessus peuvent être multipliés ensemble pour fournir
    le nombre maximal de connexions attendues :
    <literal>connections_per_pool</literal> *
    <literal>pools_per_process</literal> *
    <literal>processes</literal>.  Notez
    que <literal>connections_per_pool</literal> peut être différent suivant les files
    d'attente, aussi, <literal>connections_per_pool</literal> devrait être le maximal.
   </para>
   <para>
    Par exemple, supposez que vous avez 30 connexions par files d'attentes,
    10 files d'attente par processus PHP, et 128 processus PHP. Alors, vous pouvez
    vous attendre à 38400 connexions depuis cette machine. Aussi, vous devriez
    définir la limite des descripteurs de fichiers de cette machine à une valeur
    suffisante pour gérer toutes ces connexions, ou alors les descripteurs de fichiers
    ne seront pas suffisants.
   </para>
   <para>
    Voir la méthode <classname>MongoPool</classname> pour plus d'informations sur les
    files d'attente de connexions.
   </para>
  </section>
 </section>
 
 <section xml:id="mongo.connecting.persistent">
  <title>Les connexions persistantes (version supérieure à 1.1.4 *uniquement*)</title>
  <note>
   <para>
    Cette section n'est pas pertinente pour les versions 1.2.0+. En 1.2.0+,
    les connexions sont toujours persistantes et gérées automatiquement
    par le driver. Si vous utilisez la version 1.2.x (mais non 1.3.x ou supérieur),
    reportez-vous à la méthode <classname>MongoPool</classname> pour plus
    d'informations sur les files d'attente de connexions.
   </para>
  </note>
  
  <para>
   La création de nouvelles connexions à la base de données est une opération lente.
   Pour minimiser le nombre de connexions que vous devez effectuer, vous pouvez utiliser
   les connexions dites "persistantes". Une connexion persistante est sauvegardée par PHP,
   et ainsi, vous pourrez utiliser la même connexion pour toutes vos requêtes.
  </para>
  
  <para>
   Par exemple, ce programme simple se connecte à la base de données 1000 fois :
  </para>
  
  <example xml:id="mongo.connecting.no-persistent-example">
   <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new MongoClient();
}

?>
]]>
   </programlisting>
  </example>
  
  <para>
   Son exécution prend approximativement 18 secondes. Si vous changez ce code pour
   utiliser les connexions persistantes :
  </para>
  
  <example xml:id="mongo.connecting.persistent-example">
   <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new MongoClient("localhost:27017", array("persist" => "x"));
}

?>
]]>
   </programlisting>
  </example>
  
  <para>
   ... il ne prend plus que .02 secondes, vu qu'il ne réalise réellement qu'une seule
   connexion à la base de données.
  </para>
  
  <para>
   Les connexions persistantes ont besoin d'une chaîne d'identification (qui est "x" dans
   notre précédent exemple) afin de les identifier de façon unique. Afin d'utiliser une
   connexion persistante, le nom de l'hôte, le port, la chaîne d'identification, le nom
   d'utilisateur ainsi que le mot de passe (si fourni) doivent correspondre avec une
   connexion persistante existante. Sinon, une nouvelle connexion sera créée avec ces
   informations d'identification.
  </para>
  <para>
   Les connexions persistantes sont <emphasis>hautement recommandées</emphasis> et
   devraient être systématiquement utilisées en production sauf si une très bonne raison
   indique le contraire. La plupart des raisons qui font qu'elles ne sont pas recommandées
   dans le cas des bases de données relationnelles ne sont pas applicables pour MongoDB.
  </para>
 </section>
 
</chapter>
