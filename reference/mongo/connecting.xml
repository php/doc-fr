<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 8a4640c71cd1b8b6ad42f5c58ba0daacfea739c4 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<section xml:id="mongo.connecting" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Connection</title>

 <para>
  La connexion à MongoDB est aussi simple que cela : <literal>new MongoClient</literal>,
  mais il existe aussi plusieurs options et plusieurs configurations.
  La page sur la méthode <function>MongoClient::__construct</function> couvre
  toutes les options offertes par l'API, mais aussi, propose
  plusieurs cas pratiques.
 </para>

 <section>
  <title>Authentification</title>
  <para>
   Si MongoDB est en fonctionnement avec l'option <literal>--auth</literal> ou
   l'option <literal>--keyFile</literal>, vous devez vous authentifier avant de
   faire n'importe quelle opération avec le driver. Vous pouvez vous authentifier
   via la connexion en spécifiant le nom d'utilisateur et le mot de passe
   soit dans l'URI de connexion, ou en utilisant les options
   <literal>"username"</literal> et <literal>"password"</literal> dans le constructeur
   <function>MongoClient::__construct</function>.
  </para>
  <programlisting role="php">
<![CDATA[
<?php
// Spécifie le nom d'utilisateur et le mot de passe dans l'URI de connexion (méthode préférée)
$m = new MongoClient("mongodb://${username}:${password}@localhost");

// Spécifie le nom d'utilisateur et le mot de passe via le tableau d'options (méthode alternative)
$m = new MongoClient("mongodb://localhost", array("username" => $username, "password" => $password));
?>
]]>
  </programlisting>
  <para>
   Par défaut, le driver s'authentifiera sur la base de données <literal>admin</literal>.
   Vous pouvez vous authentifier sur une base de données différente en le spécifiant
   soit dans l'URI de connexion, soit via l'option <literal>"db"</literal> du constructeur
   <function>MongoClient::__construct</function>.
  </para>
  <programlisting role="php">
<![CDATA[
<?php
// Spécifie la base de données à utiliser dans l'URI de connexion (méthode préférée)
$m = new MongoClient("mongodb://${username}:${password}@localhost/myDatabase");

// Spécifie la base de données à utiliser via le tableau d'options (méthode alternative)
$m = new MongoClient("mongodb://${username}:${password}@localhost", array("db" => "myDatabase"));
?>
]]>
  </programlisting>
  <para>
   Si votre connexion est interrompue, le driver tentera automatiquement une re-connexion
   ou une ré-authentification.
  </para>
 </section>

 <section>
  <title>Paires de réplication</title>
  <para>
   Pour se connecter à une paire de réplication, vous devez spécifier
   au moins un membre de la paire et utiliser l'option <literal>"replicaSet"</literal>.
   Plusieurs serveurs doivent être délimités par une virgule.
  </para>
  <programlisting role="php">
<![CDATA[
<?php

// Utilisation de plusieurs serveurs de la liste (méthode préférée)
$m = new MongoClient("mongodb://rs1.example.com:27017,rs2.example.com:27017/?replicaSet=myReplSetName"));


// Utilisation d'un seul serveur de la liste
$m = new MongoClient("mongodb://rs1.example.com:27017", array("replicaSet" => "myReplSetName"));

// Utilisation de plusieurs serveurs de la liste
$m = new MongoClient("mongodb://rs1.example.com:27017,rs2.example.com:27017", array("replicaSet" => "myReplSetName"));
?>
]]>
  </programlisting>
  <para>
   Les versions 1.0.9+ du pilote sont requises pour connecter une paire.
   Les versions antérieures ne detectent pas correctement le primaire et ne se
   reconnectent pas correctement.
  </para>
  <para>
   Le pilote PHP requêtera le(s) serveur(s) de base de données listé(s) pour vérifier qui
   est le primaire. Dès qu'il peut se connecter à au moins un hôte listé, et trouver un primaire,
   la connexion sera réussie. Dans le cas contraire, une
   <classname>MongoConnectionException</classname> est envoyée.
  </para>
  <para>
   Si le primaire devient indisponible, les secondaires ne deviendront pas
   primaires pendant ces quelques secondes. Pendant ce temps là
   (<link xlink:href="&url.mongodb.replica.failover;">20-60 secondes</link>),
   la connexion ne sera pas capable d'effectuer les opérations sur la base
   de données (les connexions aux secondaires pourront toujours effectuer des
   lectures) et une exception sera levée.
  </para>
  <para>
   Une fois le maître trouvé, essayer des lectures ou écritures permettra au pilote de
   détecter le nouveau primaire. Le pilote en fera alors sa connexion principale et continuera
   les opérations normalement.
  </para>
  <para>
   Pour plus d'informations sur les paires de réplication, reportez-vous à la
   <link xlink:href="&url.mongodb.replica;">documentation interne</link>.
  </para>
 </section>

 <section>
  <title>Fragmentation</title>
  <para>
   Pour se connecter à un cluster fragmenté, vous devez spécifier une ou
   plusieurs instances <literal>mongos</literal> dans la chaîne de connexion.
   Les serveurs doivent être séparés par une virgule.
  </para>
  <programlisting role="php">
<![CDATA[
<?php

// Utilisation d'un serveur depuis la liste
$m = new MongoClient("mongodb://mongos1.example.com:27017");

// Utilisation de plusieurs serveurs depuis la liste
$m = new MongoClient("mongodb://mongos1.example.com:27017,mongos2.example.com:27017"));

?>
]]>
  </programlisting>
  <para>
   Que le cluster fragmenté soit un serveur <literal>mongod</literal> simple
   ou un jeu complet de réplication, le processus de connexion du driver reste
   le même. Toutes les communications à la base de données seront dirigées
   vers <literal>mongos</literal>.
  </para>
  <para>
   Pour plus d'informations sur la fragmentation avec MongoDB, reportez-vous à cette
   <link xlink:href="&url.mongodb.docs.sharding;">documentation</link>.
  </para>
 </section>

 <section>
  <title>Support des Domain Socket</title>

  <para>
   Si vous utilisez MongoDB localement et que vous utilisez une version 1.0.9 ou supérieure du
   pilote, vous pouvez vous connecter au travers d'un socket. MongoDB ouvre automatiquement
   un fichier de socket au démarrage : <literal>/tmp/mongodb-&lt;port&gt;.sock.</literal>.
  </para>

  <para>
   Pour vous connecter au fichier de socket, specifiez le chemin dans la chaine de connexion
   MongoDB:
  </para>

  <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb:///tmp/mongo-27017.sock");
?>
]]>
  </programlisting>

  <para>
   Si vous voulez vous authentifier sur une base de données (tel que décrit ci-dessous) en
   utilisant un socket, vous devez alors préciser un port égal à 0 comme cela l'analyseur
   sait où trouver la fin de la chaine de connexion. Vous pouvez également utiliser
   les options du constructeur.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb://username:password@/tmp/mongo-27017.sock:0/foo");
?>
]]>
  </programlisting>

 </section>

 <section>
  <title>File d'attente de connexion (version 1.2.0-1.2.12 *seulement*)</title>
  <para>
   La création de connexions est une des actions les plus lourdes réalisées
   par le driver. Cela peut prendre plusieurs millisecondes pour définir correctement
   une connexion, y compris sur un réseau rapide. Aussi, le driver tente de
   minimiser le nombre de nouvelles connexions créées en réutilisant les connexions
   depuis la file d'attente.
  </para>
  <para>
   Lorsqu'un utilisateur crée une nouvelle instance de la clase
   <classname>MongoClient</classname>, toutes les connexions nécessaires seront
   prises depuis leurs files d'attente (les connexions pour le jeu de réplication
   peuvent nécessiter plusieurs connexions, une pour chaque membre du jeu).
   Lorsque l'instance de la classe <classname>MongoClient</classname> sort du scope,
   les connexions seront remises dans la file d'attente. Lorsque le processus PHP
   existe, toutes les connexions de la file d'attente seront fermées.
  </para>
  <section>
   <title>"Pourquoi dois-je avoir autant de connexions ouvertes ?"</title>
   <para>
    La file d'attente de connexions peut générer un nombre important de connexions.
    Ceci est voulu, et, en utilisant un peu d'arithmétique, vous pouvez trouver
    le nombre de connexions qui sera créée. Il y a 3 facteurs qui affectent le
    nombre de connexions :
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>
       connections_per_pool
      </literal>
     </para>
     <para>
      Chaque file d'attente de connexions, créera, par défaut, un nombre illimité
      de connexions. Cela peut poser quelques soucis : si la file peut créer un
      nombre illimité de connexions, peut-elle en créer des centaines et ainsi,
      dépasser les descripteurs de fichiers du serveur ? En pratique, ceci est
      peu probable, sachant que chaque connexion inutilisée est replacée dans
      la file d'attente pour une réutilisation ultérieure, aussi, les futures
      connexions utiliseront la même connexion au lieu d'en créer une nouvelle.
      Sauf si vous créez volontairement des milliers de connexions à la fois
      sans les laisser sortir du scope, le nombre de connexions ouvertes devrait
      rester à un niveau raisonnable.
     </para>
     <para>
      Vous pouvez voir le nombre de connexions présentes dans la file d'attente
      en utilisant la méthode <function>MongoPool::info</function>.
      Ajouter les champs "in use" et "in pool" pour un serveur donné.
      Ce sera le nombre total de connexions pour cette file d'attente.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       pools_per_process
      </literal>
     </para>
     <para>
      Chaque adresse de serveur MongoDB sur lequel vous vous connectez
      utilise sa propre file d'attente de connexions. Par exemple, si votre nom
      d'hôte local est "example.net", une connexion à "example.net:27017", "localhost:27017",
      et "/tmp/mongodb-27017.sock" créera 3 files d'attente de connexions. Vous pouvez voir
      le nombre de files d'attentes de connexions ouvertes en utilisant la méthode
      <function>MongoPool::info</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       processes
      </literal>
     </para>
     <para>
      Chaque processus PHP a un jeu de files d'attente séparées. PHP-FPM et Apache
      créent généralement entre 6 et une douzaine de fils. Vérifiez votre configuration
      pour voir le nombre maximal de processus PHP pouvant être engendrés.
     </para>
     <para>
      Si vous utilisez PHP-FPM, le fait d'estimer le nombre de connexions peut être
      délicat car le processus va engendrer encore plus de fils à forte charge.
      Pour rester dans un contexte sécurisé, regardez le paramètre <literal>max_children</literal>
      et ajoutez-y <literal>spare_servers</literal> + <literal>start_servers</literal> (choisissez
      le nombre le plus important). Le résultat sera le nombre de processus PHP (et donc, le nombre
      de jeux de files d'attente) dont vous pourrez vous attendre.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Les trois variables ci-dessus peuvent être multipliés ensemble pour fournir
    le nombre maximal de connexions attendues :
    <literal>connections_per_pool</literal> *
    <literal>pools_per_process</literal> *
    <literal>processes</literal>.  Notez
    que <literal>connections_per_pool</literal> peut être différent suivant les files
    d'attente, aussi, <literal>connections_per_pool</literal> devrait être le maximal.
   </para>
   <para>
    Par exemple, supposez que vous avez 30 connexions par files d'attentes,
    10 files d'attente par processus PHP, et 128 processus PHP. Alors, vous pouvez
    vous attendre à 38400 connexions depuis cette machine. Aussi, vous devriez
    définir la limite des descripteurs de fichiers de cette machine à une valeur
    suffisante pour gérer toutes ces connexions, ou alors les descripteurs de fichiers
    ne seront pas suffisants.
   </para>
   <para>
    Voir la méthode <classname>MongoPool</classname> pour plus d'informations sur les
    files d'attente de connexions.
   </para>
  </section>
 </section>
 
 <section>
  <title>Les connexions persistantes</title>
  <note>
   <para>
    Cette section n'est pas pertinente pour les versions 1.2.0+. En 1.2.0+,
    les connexions sont toujours persistantes et gérées automatiquement
    par le driver. Si vous utilisez la version 1.2.x, reportez-vous à la méthode
    <classname>MongoPool</classname> pour plus d'informations sur les files d'attente
    de connexions.
   </para>
  </note>

  <para>
   La création de nouvelles connexions à la base de données est une opération lente.
   Pour minimiser le nombre de connexions que vous devez effectuer, vous pouvez utiliser
   les connexions dites "persistantes". Une connexion persistante est sauvegardée par PHP,
   et ainsi, vous pourrez utiliser la même connexion pour toutes vos requêtes.
  </para>

  <para>
   Par exemple, ce programme simple se connecte à la base de données 1000 fois :
  </para>

  <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new MongoClient();
}

?>
]]>
  </programlisting>

  <para>
   Son exécution prend approximativement 18 secondes. Si vous changez ce code pour
   utiliser les connexions persistantes :
  </para>

  <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new MongoClient("localhost:27017", array("persist" => "x"));
}

?>
]]>
  </programlisting>

  <para>
   ... il ne prend plus que .02 secondes, vu qu'il ne réalise réellement qu'une seule
   connexion à la base de données.
  </para>

  <para>
   Les connexions persistantes ont besoin d'une chaîne d'identification (qui est "x" dans
   notre précédent exemple) afin de les identifier de façon unique. Afin d'utiliser une
   connexion persistante, le nom de l'hôte, le port, la chaîne d'identification, le nom
   d'utilisateur ainsi que le mot de passe (si fourni) doivent correspondre avec une
   connexion persistante existante. Sinon, une nouvelle connexion sera créée avec ces
   informations d'identification.
  </para>
  <para>
   Les connexions persistantes sont <emphasis>hautement recommandées</emphasis> et
   devraient être systématiquement utilisées en production sauf si une très bonne raison
   indique le contraire. La plupart des raisons qui font qu'elles ne sont pas recommandées
   dans le cas des bases de données relationnelles ne sont pas applicables pour MongoDB.
  </para>
 </section>

</section>
