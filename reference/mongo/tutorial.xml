<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 8a4640c71cd1b8b6ad42f5c58ba0daacfea739c4 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<section xml:id="mongo.tutorial" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Tutoriel</title>
 <section>
  <title>Introduction</title>
  <para>
   Voici le driver PHP pour MongoDB.
  </para>
  <para>
   Vous trouverez dans ce chapitre quelques rapides exemples montrant la façon
   de se connecter, d'insérer des documents, de requêter des documents, de traverser
   des jeux de résultats, et de se déconnecter d'une base de données MongoDB.
   Vous trouverez encore plus de détails dans chaque étape de ce tutoriel.
  </para>
  <programlisting role="php">
<![CDATA[
<?php

// connexion
$m = new MongoClient();

// sélection d'une base de données
$db = $m->comedy;

// sélectionne une collection (analogue à une table de base de données relationnelle)
$collection = $db->cartoons;

// ajoute un enregistrement
$obj = array( "title" => "Calvin and Hobbes", "author" => "Bill Watterson" );
$collection->insert($obj);

// ajoute un autre enregistrement, avec une façon différente d'insertion
$obj = array( "title" => "XKCD", "online" => true );
$collection->insert($obj);

// récupère tout de la collection
$cursor = $collection->find();

// traverse les résultats
foreach ($cursor as $obj) {
    echo $obj["title"] . "\n";
}

?>
]]>
  </programlisting>
  <para>
   Ceci affichera :
  </para>
  <screen>
<![CDATA[
Calvin and Hobbes
XKCD
]]>
  </screen>
 </section>
 <section>
  <title>Création d'une connexion</title>
  <para>
   Pour se connecter à un serveur de base de données, utilisez une
   des façons suivantes :
  </para>
  
  <programlisting role="php">
<![CDATA[
<?php

$connection = new MongoClient(); // Connexion à localhost:27017
$connection = new MongoClient( "example.com" ); // Connexion à un hôte distant (en utilisant le port par défaut : 27017)
$connection = new MongoClient( "example.com:65432" ); // connect to a remote host at a given port

?>
]]>
  </programlisting>
  <para>
   Vous n'avez pas à vous déconnecter explicitement de la base de données. Lorsque
   <literal>$connection</literal> sort du scope, la connexion sera fermée automatiquement
   et toutes les ressources utilisées par la base de données seront libérées.
  </para>
  <section>
   <title>Voir aussi</title>
   <para>
    La chapitre sur les
    <link linkend="mongo.connecting">connexion</link>
    couvre les différents types de connexions.
   </para>
   <para>
    La documentation de l'API de la classe
    <classname>MongoClient</classname> et de la classe
    <function>MongoClient::__construct</function> permet d'avoir une
    bonne compréhension des options possibles avec bons nombres
    d'exemples.
   </para>
  </section>
  
  <section>
   <title>Sélection d'une base de données</title>
   <para>
    Pour sélectionner une base de données, utilisez :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db = $connection->dbname;

?>
]]>
   </programlisting>
   <para>
    La base de données n'a pas besoin d'avoir été créée auparavant ;
    vous pouvez simplement créer une nouvelle base de données en tentant
    de la sélectionner.
   </para>
   <para>
    Attention aux fautes de frappe ! Vous pouvez
    par inadvertance créer une nouvelle base de données, ce qui peut
    rendre plus compliqué de trouver la cause d'une erreur :
    
    <programlisting role="php">
<![CDATA[
<?php

$db = $connection->mybiglongdbname;
// Plus de codes ici...
$db = $connection->mybiglongdbanme;
// Maintenant, vous êtes connecté à une base de données différente !

?>
]]>
    </programlisting>
   </para>
   <section>
    <title>Voir aussi</title>
    <para>
     La documentation de l'API de la classe
     <classname>MongoDB</classname> contient plus d'informations
     sur les objets de bases de données.
    </para>
   </section>
  </section>
  
  <section>
   <title>Sélection d'une collection</title>
   <para>
    Récupérer une connexion utilise la même syntaxe que de récupérer
    une base de données :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db = $connection->baz;
$collection = $db->foobar;

// ou, plus succinctement
$collection = $connection->baz->foobar;

?>
]]>
   </programlisting>
   <para>
    Une collection est similaire à une table (si vous êtes familier avec les
    bases de données relationnelles).
   </para>
   <section>
    <title>Voir aussi</title>
    <para>
     La documentation de l'API de la classe
     <classname>MongoCollection</classname> contient
     plus d'informations sur les objets de collection.
    </para>
   </section>
  </section>
  
  <section>
   <title>Insertion d'un document</title>
   <para>
    Les tableaux associatifs sont les objets basiques qui peuvent être insérés
    dans une collection d'une base de données. Un document "document" peut
    être :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$doc = array( "name" => "MongoDB",
   "type" => "database",
   "count" => 1,
   "info" => (object)array( "x" => 203, "y" => 102),
   "versions" => array("0.9.7", "0.9.8", "0.9.9")
);

?>
]]>
   </programlisting>
   <para>
    Notez que vous pouvez avoir des tableaux et des objets imbriqués.
   </para>
   <para>
    Pour insérer ce document, utilisez la méthode
    <function>MongoCollection::insert</function> :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$collection->insert( $doc );

?>
]]>
   </programlisting>
   <section>
    <title>Voir aussi</title>
    <para>
     La documentation de l'API sur la méthode
     <function>MongoCollection::insert</function>
     contient plus d'informations sur l'insertion
     des données.
    </para>
   </section>
  </section>
  
  <section>
   <title>
    Trouver un document en utilisant la méthode
    <function>MongoCollection::findOne</function>
   </title>
   <para>
    Pour montrer que le document inséré dans l'étape précédante est bien présent,
    nous pouvons simplement utiliser la méthode
    <function>MongoCollection::findOne</function> pour récupérer
    une seule document de la collection. Cette méthode est utile dans les cas où
    il n'y a qu'un seul document correspondant aux critères ou bien si vous ne
    souhaitez qu'un seul résultat.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$obj = $collection->findOne();
var_dump( $obj );

?>
]]>
   </programlisting>
   <para>
    et vous devriez voir :
   </para>
   <programlisting>
<![CDATA[
array(6) {
  ["_id"]=>
  object(MongoId)#8 (1) {
    ["$id"]=>
    string(24) "4e2995576803fab768000000"
  }
  ["name"]=>
  string(7) "MongoDB"
  ["type"]=>
  string(8) "database"
  ["count"]=>
  int(1)
  ["info"]=>
  array(2) {
    ["x"]=>
    int(203)
    ["y"]=>
    int(102)
  }
  ["versions"]=>
  array(3) {
    [0]=>
    string(5) "0.9.7"
    [1]=>
    string(5) "0.9.8"
    [2]=>
    string(5) "0.9.9"
  }
}
]]>
   </programlisting>
   <para>
    Notez qu'il y a un champ <literal>_id</literal> qui a été ajouté automatiquement
    à votre document. <literal>_id</literal> est le champ de la clé primaire.
    Si votre document n'en spécifie pas une, le driver en ajoutera une
    automatiquement.
   </para>
   <para>
    Si vous spécifiez votre propre champ <literal>_id</literal>, il doit être unique
    dans la collection. Par exemple :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db->foo->insert(array("_id" => 1), array("safe" => true));
// ceci émettra une exception
$db->foo->insert(array("_id" => 1), array("safe" => true));

// ceci est correct, sachant que c'est une collection différente
$db->bar->insert(array("_id" => 1), array("safe" => true));

?>
]]>
   </programlisting>
   <para>
    Notez que ces insertions utilisent une second tableau : 
    <literal>array("safe" => true)</literal>. Ce second champ spécifie
    les options d'insertion. Par défaut, le driver n'attend pas la réponse
    de la base de données pour écrire, et donc, il ne récupère pas le
    <literal>_id</literal>. En spécifiant qu'il s'agit d'une écriture "sur" (<literal>safe</literal>),
    le driver attendra une réponse de la base de données afin de confirmer l'écriture.
    En général, toutes les écritures doivent utiliser l'option "safe" (l'option
    avait été omise dans les précédents exemples dans un souci de simplification).
   </para>
   <section>
    <title>Voir aussi</title>
    <para>
     La méthode <function>MongoCollection::findOne</function> pour plus
     d'informations sur la recherche de données.
    </para>
    <para>
     La classe <classname>MongoId</classname> vous fournira plus de détails sur
     les identifiants uniques.
    </para>
    <para>
     La section sur les <link linkend="mongo.writes">écritures</link> couvrent
     les écritures sécurisées sur plusieurs niveaux, tel que fait par les méthodes
     <function>MongoCollection::insert</function>,
     <function>MongoCollection::update</function> et
     <function>MongoCollection::remove</function>.
    </para>
   </section>
  </section>
  
  <section>
   <title>Ajout de plusieurs documents</title>
   <para>
    Afin de faire des requêtes plus intéressantes, commençons par ajouter
    plusieurs documents simples dans notre collection. Ces documents
    seront de la forme <literal>array( "i" => <replaceable>value</replaceable> );</literal>
    et nous pourrons les insérer efficacement via une boucle :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

for($i=0; $i<100; $i++) {
    $collection->insert( array( "i" => $i ) );
}

?>
]]>
   </programlisting>
   
   <para>
    Notez que vous pouvez insérer des tableaux avec des clés différentes
    dans la même collection. Cet aspect correspond à ce que nous avançons
    lorsque nous disons que MongoDB a "un schéma libre".
   </para>
  </section>
  
  <section>
   <title>Comptage des documents dans une collection</title>
   <para>
    Maintenant que nous avons inséré 101 documents (le 100 noté dans la boucle, +1),
    nous pouvons vérifier le nombre de documents dans la collection en utilisant
    la méthode <function>MongoCollection::count</function>.
    <programlisting role="php">
<![CDATA[
<?php

echo $collection->count();

?>
]]>
    </programlisting>
    et vous devriez voir afficher : 101.
   </para>
  </section>
  
  <section>
   <title>Utilisation d'un curseur pour récupérer tous les documents</title>
   <para>
    Afin de récupérer tous les documents d'une collection, vous devez utiliser
    la méthode <function>MongoCollection::find</function>. Cette méthode retourne
    un objet <classname>MongoCursor</classname> qui vous permet de parcourir
    tous les documents correspondant à votre requête. Aussi, pour récupérer tous
    les documents et les afficher, vous pouvez faire ceci :
    <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find();
foreach ($cursor as $id => $value) {
    echo "$id: ";
    var_dump( $value );
}

?>
]]>
    </programlisting>
    ceci affichera les 101 documents de la collection. <literal>$id</literal>
    est le champ <literal>_id</literal>
    du document (sous la forme d'une &string;), et <literal>$value</literal> est le document lui-même.
   </para>
   <section>
    <title>Voir aussi</title>
    <para>
     La documentation de l'API sur la méthode
     <function>MongoCollection::find</function>
     contient plus d'informations sur la recherche de données.
    </para>
   </section>
  </section>
  
  <section>
   <title>Ajout d'un critère à une requête</title>
   <para>
    Nous pouvons créer une requête à passer à la méthode
    <function>MongoCollection::find</function> pour récupérer
    un sous-jeu de documents de notre collection. Par exemple, si vous voulez
    trouver les documents dont le champ "i" vaut "71", vous pouvez le faire
    comme ceci :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => 71 );
$cursor = $collection->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    un seul document s'affichera :
   </para>
   <programlisting>
<![CDATA[
array(2) {
  ["_id"]=>
  object(MongoId)#6 (0) {
  }
  ["i"]=>
  int(71)
  ["_ns"]=>
  "testCollection"
}
]]>
   </programlisting>
  </section>
  
  <section>
   <title>Récupération de plusieurs documents avec une requête</title>
   <para>
    Vous pouvez utiliser une requête pour récupérer plusieurs documents
    depuis la collection. Par exemple, si vous voulez récupérer tous les
    documents dont le champ "i" est plus grand que 50, vous pouvez le faire
    comme ceci :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => array( '$gt' => 50 ) ); //notez les simples guillemets autour de '$gt'
$cursor = $coll->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    Ceci devrait afficher les documents dont le champ "i" est supérieur à 50. Nous pouvons
    également spécifier un intervalle comme 20 &lt; i &lt;= 30 :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => array( "\$gt" => 20, "\$lte" => 30 ) );
$cursor = $coll->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    Rappelez-vous de toujours échapper le symbole $ ou d'utiliser des guillemets
    simples. Sinon, PHP l'interprétera comme étant la variable
    <varname>$gt</varname>.
   </para>
  </section>
  
  <section>
   <title>Création d'un index</title>
   <para>
    MongoDB supporte les indexes, et il est très simple de les ajouter à une
    collection. Pour créer un index, vous devez spécifier le nom du champ
    ainsi que sa direction : ascendant (1) ou descendant
    (-1). L'exemple suivant va créer un index ascendant sur le champ "i" :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$coll->ensureIndex( array( "i" => 1 ) );  // Création d'un index sur le champ "i"
$coll->ensureIndex( array( "i" => -1, "j" => 1 ) );  // Index descendant sur le champ "i", et ascendant sur le champ "j"

?>
]]>
   </programlisting>
   <para>
    L'indexation est une action critique pour les performances en lecture lorsque vos
    données grossissent. Si vous n'êtes pas familier avec l'indexation, reportez-vous à
    la documentation de la méthode <function>MongoCollection::ensureIndex</function> ansi
    que la <link xlink:href="&url.mongodb.dochub.indexes;">documentation du coeur
    de l'indexation MongoDB</link>.
   </para>
  </section>
 </section>
</section>
