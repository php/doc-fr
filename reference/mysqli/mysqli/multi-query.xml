<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: d470f625f96a83d65464619297cccad7ce46e743 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->
<refentry xml:id="mysqli.multi-query" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>mysqli::multi_query</refname>
  <refname>mysqli_multi_query</refname>
  <refpurpose>Exécute une ou plusieurs requêtes sur la base de données</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <para>&style.oop;</para>
  <methodsynopsis role="mysqli">
   <modifier>public</modifier> <type>bool</type><methodname>mysqli::multi_query</methodname>
   <methodparam><type>string</type><parameter>query</parameter></methodparam>
  </methodsynopsis>
  <para>&style.procedural;</para>
  <methodsynopsis>
   <type>bool</type><methodname>mysqli_multi_query</methodname>
   <methodparam><type>mysqli</type><parameter>mysql</parameter></methodparam>
   <methodparam><type>string</type><parameter>query</parameter></methodparam>
  </methodsynopsis>
  <para>
   Exécute une ou plusieurs requêtes, rassemblées dans le paramètre
   <parameter>query</parameter> par des points-virgules.
  </para>
  &mysqli.sqlinjection.warning;
  <para>
   Les requêtes sont envoyées de manière asynchrone dans un seul appel à la
   base de donnéess, mais la base de donnéess les traitent de manière séquentielle.
   <methodname>mysqli_multi_query</methodname> attend pour la première requête
   de compléter avant de retourner le contrôle à PHP. Le serveur MySQL traitera
   alors la prochaine requête dans la suite. Une fois que le résultat est prêt,
   MySQL attendra pour la prochaine exécution de
   <function>mysqli_next_result</function> depuis PHP.
  </para>
  <para>
   Il est recommandé d'utiliser une
   <link linkend="control-structures.do.while">do-while</link> pour traiter
   plusieurs requêtes. La connexion sera occupée jusqu'à ce que toutes les
   requêtes soient complétées et que leur résultat soit récupéré par PHP.
   Aucune autre requête ne peut être émise sur la même connexion, jusqu'à ce
   que toutes les requêtes soient traitées.
   Pour traiter la prochaine requête dans la suite, utiliser
   <function>mysqli_next_result</function>. Si le prochain résultat n'est pas
   encore prêt mysqli attendra pour la réponse depuis le serveur MySQL.
   Pour vérifier s'il y a plus de résultats, utiliser
   <function>mysqli_more_results</function>.
  </para>
  <para>
   Pour les requêtes qui produisent un jeu de résultat, tel que
   <literal>SELECT, SHOW, DESCRIBE</literal> ou
   <literal>EXPLAIN</literal>,
   <function>mysqli_use_result</function> ou <function>mysqli_store_result</function>
   peut être utilisé pour récupérer le jeu de résultat. Pour les requêtes qui
   ne produisent pas de jeu de résultat, les mêmes fonctions peuvent être
   utilisées pour récupérer les informations telles que le nombre de lignes affectées.
  </para>
  <tip>
   <para>
    Exécuter une requête <literal>CALL</literal> pour les procédures stockées
    peut produire plusieurs jeux de résultats. Si la procédure stockée contient
    des requêtes <literal>SELECT</literal>, les jeux de résultats sont retournés
    dans l'ordre dans lequel ils sont produits par l'exécution de la procédure.
    En général, l'appeleur ne peut pas savoir combien de jeux de résultats une
    procédure retournera et doit être préparé à récupérer plusieurs résultats.
    Le résultat final de la procédure est un résultat de statut qui n'inclut
    pas de jeu de résultat. Le statut indique si la procédure a succédé
    ou si une erreur s'est produite.
   </para>
  </tip>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    &mysqli.link.description;
    <varlistentry>
     <term><parameter>query</parameter></term>
     <listitem>
      <para>
       Une &string; contenant les requêtes à exécuter.
       Plusieurs requêtes doivent être séparées par un point-virgule.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne &false; uniquement si la première requête échoue. Pour récupérer
   les sous-séquences d'erreurs issues des autres requêtes, vous devez appeler
   d'abord la fonction <function>mysqli_next_result</function>.
  </para>
 </refsect1>

 <refsect1 role="errors">
  &reftitle.errors;
  &mysqli.conditionalexception;
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Exemple avec <methodname>mysqli::multi_query</methodname></title>
   <para>&style.oop;</para>
   <programlisting role="php">
<![CDATA[
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$mysqli = new mysqli("localhost", "my_user", "my_password", "world");

$query = "SELECT CURRENT_USER();";
$query .= "SELECT Name FROM City ORDER BY ID LIMIT 20, 5";

/* Exécution d'une requête multiple */
$mysqli->multi_query($query);
do {
    /* store the result set in PHP */
    if ($result = $mysqli->store_result()) {
        while ($row = $result->fetch_row()) {
            printf("%s\n", $row[0]);
        }
    }
    /* print divider */
    if ($mysqli->more_results()) {
        printf("-----------------\n");
    }
} while ($mysqli->next_result());
?>
]]>
   </programlisting>
   <para>&style.procedural;</para>
   <programlisting role="php">
<![CDATA[
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$link = mysqli_connect("localhost", "my_user", "my_password", "world");

$query = "SELECT CURRENT_USER();";
$query .= "SELECT Name FROM City ORDER BY ID LIMIT 20, 5";

/* Exécution d'une requête multiple */
mysqli_multi_query($link, $query);
do {
    /* store the result set in PHP */
    if ($result = mysqli_store_result($link)) {
        while ($row = mysqli_fetch_row($result)) {
            printf("%s\n", $row[0]);
        }
        /* Affichage d'une séparation */
        if (mysqli_more_results($link)) {
            printf("-----------------\n");
        }
    }
    /* print divider */
    if (mysqli_more_results($link)) {
        printf("-----------------\n");
    }
} while (mysqli_next_result($link));
?>
]]>
   </programlisting>
   &examples.outputs.similar;
   <screen>
<![CDATA[
my_user@localhost
-----------------
Amersfoort
Maastricht
Dordrecht
Leiden
Haarlemmermeer
]]>
   </screen>
  </example>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>mysqli_query</function></member>
    <member><function>mysqli_use_result</function></member>
    <member><function>mysqli_store_result</function></member>
    <member><function>mysqli_next_result</function></member>
    <member><function>mysqli_more_results</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
