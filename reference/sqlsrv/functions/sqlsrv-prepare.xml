<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: c758e862cf7648f657acb9e073bcc657f368a701 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="function.sqlsrv-prepare">
 <refnamediv>
  <refname>sqlsrv_prepare</refname>
  <refpurpose>Prépare une requête pour exécution</refpurpose>
 </refnamediv>
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>sqlsrv_prepare</methodname>
   <methodparam><type>resource</type><parameter>conn</parameter></methodparam>
   <methodparam><type>string</type><parameter>sql</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>params</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>options</parameter></methodparam>
  </methodsynopsis>
  <simpara>
   Prépare une requête pour exécution. Cette fonction est idéale pour
   préparer une requête qui sera exécutée plusieurs fois avec des
   valeurs de paramètres différents.
  </simpara>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <simpara>
      Une ressource de connexion retournée par la fonction
      <function>sqlsrv_connect</function>.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>sql</parameter></term>
    <listitem>
     <simpara>
      La chaîne qui définit la requête à préparer et à exécuter.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>params</parameter></term>
    <listitem>
     <para>
      Un tableau spécifiant les informations de paramètres lors de l'exécution
      d'une requête contenant des paramètres. Les éléments du tableau peuvent
      être n'importe lequel de ceux qui suivent :
      <simplelist>
       <member>Une valeur littérale</member>
       <member>Une variable PHP</member>
       <member>Un tableau avec la structure suivante :
       array($value [, $direction [, $phpType [, $sqlType]]])</member>
      </simplelist>
      La table suivante décrit les éléments de la structure du tableau ci-dessus :
      </para>
      <table>
      <title>Structure du tableau</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Élément</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>$value</entry>
         <entry>Une valeur littérale, une variable PHP ou une variable PHP passée par référence.</entry>
        </row>
        <row>
         <entry>$direction (optional)</entry>
         <entry>Une des constantes SQLSRV suivantes, utilisées pour indiquer la
          direction du paramètre : SQLSRV_PARAM_IN, SQLSRV_PARAM_OUT, SQLSRV_PARAM_INOUT.
          La valeur par défaut est SQLSRV_PARAM_IN.
         </entry>
        </row>
        <row>
         <entry>$phpType (optional)</entry>
         <entry>Une constante SQLSRV_PHPTYPE_* qui spécifie le type de données PHP
          de la valeur retournée.</entry>
        </row>
        <row>
         <entry>$sqlType (optional)</entry>
         <entry>Une constante SQLSRV_SQLTYPE_* qui spécifie le type de données
          du serveur SQL de la valeur d'entrée.</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>options</parameter></term>
    <listitem>
     <simpara>
      Un tableau spécifiant les options de propriétés de la requête.
      Les clés prises en charge sont décrites dans le tableau suivant :
     </simpara>
     <table>
      <title>Options de la requête</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Clé</entry>
         <entry>Valeurs</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>QueryTimeout</entry>
         <entry>Une valeur entière positive.</entry>
         <entry>Définit le délai maximal d'exécution de la requête, en seconde.
          Par défaut, le driver attendra indéfiniment les résultats.</entry>
        </row>
        <row>
         <entry>SendStreamParamsAtExec</entry>
         <entry>&true; ou &false; (par défaut, &true;)</entry>
         <entry>Configure le driver pour envoyer les données du flux à l'exécution (&true;),
          ou envoyer les données du flux par morceaux (&false;). Par défaut, la valeur
          est définie à &true;. Pour plus d'informations, se reporter à la fonction
          <function>sqlsrv_send_stream_data</function>.</entry>
        </row>
        <row>
         <entry>Scrollable</entry>
         <entry>SQLSRV_CURSOR_FORWARD, SQLSRV_CURSOR_STATIC, SQLSRV_CURSOR_DYNAMIC,
         ou SQLSRV_CURSOR_KEYSET</entry>
         <entry>Voir la section sur <link xlink:href="&url.sqlsrv.specify.cursortype;">la
          spécification d'un type de curseur et la sélection de lignes</link> de la documentation
          Microsoft SQLSRV.</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <simpara>
   Retourne une ressource de requête en cas de succès, ou &false; si une
   erreur survient.
  </simpara>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Exemple avec <function>sqlsrv_prepare</function></title>
   <simpara>
    Cet exemple montre la façon de préparer une requête avec la fonction
    <function>sqlsrv_prepare</function> et sa ré-exécution à plusieurs reprises
    (avec des valeurs de paramètres différents) en utilisant la fonction
    <function>sqlsrv_execute</function>.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$serverName = "serverName\sqlexpress";
$connectionInfo = array( "Database"=>"dbName", "UID"=>"username", "PWD"=>"password");
$conn = sqlsrv_connect( $serverName, $connectionInfo);
if( $conn === false) {
    die( print_r( sqlsrv_errors(), true));
}

$sql = "UPDATE Table_1
        SET OrderQty = ?
        WHERE SalesOrderID = ?";

// Initialise les paramètres et prépare la requête.
// Les variables $qty et $id sont liées à la requête $stmt.
$qty = 0; $id = 0;
$stmt = sqlsrv_prepare( $conn, $sql, array( &$qty, &$id));
if( !$stmt ) {
    die( print_r( sqlsrv_errors(), true));
}

// Définit les informations SalesOrderDetailID et OrderQty.
// Ce tableau lie l'ordre des IDs avec l'ordre des quantités avec des paires clé=>valeur.
$orders = array( 1=>10, 2=>20, 3=>30);

// Exécute la requête pour chaque ordre.
foreach( $orders as $id => $qty) {
    // En raison du fait que $id et $qty sont liés à $stmt1,
    // leurs valeurs mises à jour sont utilisées lors de chaque exécution
    // de la requête.
    if( sqlsrv_execute( $stmt ) === false ) {
          die( print_r( sqlsrv_errors(), true));
    }
}
?>
]]>
   </programlisting>
  </example>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <simpara>
   Lorsque l'on prépare une requête qui utilise des variables comme paramètres,
   les variables sont liées à la requête. Cela signifie que si l'on met à jour
   les valeurs de ces variables, la prochaine exécution de la requête prendra
   en compte ces nouvelles valeurs. Pour les requêtes que l'on ne prévoit
   exécuter qu'une seule fois, utilisez la fonction
   <function>sqlsrv_query</function>.
  </simpara>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <simplelist>
   <member><function>sqlsrv_execute</function></member>
   <member><function>sqlsrv_query</function></member>
  </simplelist>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
