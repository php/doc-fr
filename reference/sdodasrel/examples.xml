<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a56106f69198dfe88c6084593c78a71c26b24353 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="sdo.das.rel.examples" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 &reftitle.examples;
 <section xml:id="sdo.das.rel.examples-crud">
  <title>Création, récupération, mise à jour et effacement de données</title>
  <para>
   Cette section illustre comment le DAS Relationnel peut être utilisé pour
   créer, récupérer, mettre à jour et supprimer des données dans une base de
   données relationnelle. Plusieurs de ces exemples sont illustrés avec trois
   tables dans une base de données qui contient <literal>"compagnies"</literal>, <literal>"departements"</literal>
   à l'intérieur de ces compagnies et <literal>"employes"</literal> qui travaillent dans ces
   départements. Cet exemple est utilisé dans plusieurs places dans la
   littérature SDO. Voyez la section des exemples de
   <link xlink:href="&url.ibm.sdo.spec;">spécification d'Objets de Service de
   Données</link>
   ou la section d'<link linkend="sdo.examples">exemples</link>
   de la documentation de l'extension SDO.
  </para>

  <para>
   Le DAS Relationnel est construit avec les métadonnées qui définissent la
   base de données relationnelle et comment il devrait être en relation avec
   le SDO. La longue section qui suit décrit ces métadonnées et comment
   construire le DAS Relationnel. Ces exemples qui suivent assument tous que
   ces métadonnées sont incluses dans un fichier PHP.
  </para>

  <para>
   Les exemples ci-dessous et les autres peuvent être trouvés dans le dossier
   <filename>Scenarios</filename>
   dans le paquetage DAS Relationnel.
  </para>

  <para>
   Le DAS Relationnel émet des exceptions dans le cas qu'il trouve des
   erreurs dans les métadonnées ou des erreurs lors de l'exécution des
   requêtes SQL à la base de données. Pour rendre les exemples plus concis,
   ils n'incluent pas les blocs try/catch autour des appels de DAS
   Relationnel.
  </para>

  <para>
   Ces exemples diffèrent tous de l'utilisation prévue de SDO dans deux
   égards importants.
  </para>
  <para>
   Premièrement, ils montrent toutes les interactions avec la base de données
   complétés dans un script. Ces scénarios ne sont pas réalistes mais sont
   choisis dans le but d'illustrer simplement l'utilisation de DAS
   Relationnel. Il est prévu que les interactions avec la base de données
   soient séparés dans le temps et le graphique de données linéarisées et
   délinéarisées dans une session PHP une ou plusieurs fois tant que
   l'application interagit avec l'utilisateur final.
  </para>
  <para>
   Deuxièmement, toutes les requêtes exécutées sur la base de données sont
   figées dans le code sans aucune substitution de variable. Dans ce cas, il
   est plus sage d'utiliser le simple appel de
   <function>executeQuery</function>
   et c'est ce que montrent les exemples.
   En pratique, il est peu probable que la requête SQL soit connue
   entièrement avant son exécution. Afin d'autoriser la substitution sans
   danger des variables dans les requêtes SQL, sans prendre le risque
   d'effectuer des injections SQL avec des effets inconnus, il est plus
   sécuritaire d'utiliser
   <function>executePreparedQuery</function>
   qui prend une requête SQL préparée contenant des paramètres fictifs et une
   liste des valeurs à être substituées.
  </para>
 </section>

 <section xml:id="sdo.das.rel.metadata">
  <title>Spécification des métadonnées</title>
  <para>
   La première longue section décrit en détail comment les métadonnées
   décrivant la base de données et le modèle SDO requis est fourni à DAS
   Relationnel.
  </para>
  <para>
   Lorsque le constructeur de DAS Relationnel est appelé, il doit recevoir
   plusieurs informations. La majeure partie des informations, passée en
   tant qu'un tableau associatif dans le premier argument du constructeur,
   dit à DAS Relationnel ce qu'il doit savoir à propos de la base de données
   relationnelle. Il décrit les noms des tables, des colonnes, des clés
   primaires et des clés secondaires. On devrait comprendre assez facilement
   ce qui est requis et une fois écrit, il peut être placé dans un fichier
   PHP et inclut lorsque nécessaire. Le reste des informations, passé dans
   un deuxième et troisième arguments du constructeur, dit au DAS
   Relationnel ce qu'il doit savoir à propos des relations entre les objets
   et la forme du graphique de données; il détermine finalement comment les
   données de la base de données seront normalisées dans le graphique.
  </para>

  <section xml:id="sdo.das.rel.metadata.database">
   <title>Métadonnées de base de données</title>
   <para>
    Le premier argument du constructeur décrit la base de données
    relationnelle cible.
   </para>
   <para>
    Chaque table est décrite par un tableau associatif avec jusqu'à quatre
    clés.
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Clé</entry>
        <entry>Valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>name</entry>
        <entry>Le nom de la table.</entry>
       </row>
       <row>
        <entry>columns</entry>
        <entry>
         Un tableau listant les noms des colonnes, dans n'importe quel
         ordre.
        </entry>
       </row>
       <row>
        <entry>PK</entry>
        <entry>Le nom de la colonne contenant la clé primaire.</entry>
       </row>
       <row>
        <entry>FK</entry>
        <entry>Un tableau avec deux entrées, <literal>"from"</literal> et <literal>"to"</literal> (provenance et
         destination), qui définissent une colonne contenant la clé étrangère
         et une table dans lequel la clé étrangère pointe. S'il n'y a pas de
         clé étrangère dans la table, alors l'entrée <literal>"FK"</literal> est optionnelle.
         Seulement une clé étrangère peut être spécifiée. Seulement une clé
         étrangère pointant à une clé primaire d'une table peut être
         spécifiée.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <programlisting role="php">
<![CDATA[
<?php
/*****************************************************************
* MÉTADONNÉES DÉFINISSANT LA BASE DE DONNÉES
******************************************************************/
$company_table = array (
  'name' => 'company',
  'columns' => array('id', 'name',  'employee_of_the_month'),
  'PK' => 'id',
  'FK' => array (
      'from' => 'employee_of_the_month',
      'to' => 'employee',
      ),
  );
$department_table = array (
  'name' => 'department', 
  'columns' => array('id', 'name', 'location', 'number', 'co_id'),
  'PK' => 'id',
  'FK' => array (
      'from' => 'co_id',
      'to' => 'company',
      )
  );
$employee_table = array (
  'name' => 'employee',
  'columns' => array('id', 'name', 'SN', 'manager', 'dept_id'),
  'PK' => 'id',
  'FK' => array (
      'from' => 'dept_id',
      'to' => 'department',
      )
  );
$database_metadata = array($company_table, $department_table, $employee_table);
?>
]]>
   </programlisting>

   <para>
    Les métadonnées correspondent à une base de données relationnelle qui
    peut avoir été définie comme étant MySQL :
   </para>
   <programlisting role="sql">
<![CDATA[
create table company (
 id integer auto_increment,
 name char(20),
 employee_of_the_month integer,
 primary key(id)
);
create table department (
 id integer auto_increment,
 name char(20),
 location char(10),
 number integer(3),
 co_id integer,
 primary key(id)
);
create table employee (
 id integer auto_increment,
 name char(20),
 SN char(4),
 manager tinyint(1),
 dept_id integer,
 primary key(id)
);
]]>
   </programlisting>
   <para>
   or to DB2 as:
   </para>
   <programlisting role="sql">
<![CDATA[
create table company ( \
  id integer not null generated by default as identity,  \
  name varchar(20), \
  employee_of_the_month integer, \
  primary key(id) )
create table department ( \
  id integer not null generated by default as identity, \
  name varchar(20), \
  location varchar(10), \
  number integer, \
  co_id integer, \
  primary key(id) )
create table employee ( \
  id integer not null generated by default as identity, \
  name varchar(20), \
  SN char(4), \
  manager smallint, \
  dept_id integer, \
  primary key(id) )
]]>
   </programlisting>

   <para>
    Notez que bien que dans cet exemple n'a pas de clé étrangère de
    spécifiée à la base de données et que la base de données n'est pas
    prévue à forcer l'intégrité référentielle, l'intention derrière la
    colonne
    <varname>co_id</varname>
    de la table departement et la colonne
    <varname>dept_id</varname>
    de la table employe est qu'elles pourraient contenir la clé primaire de
    leur compagnie les contenant ou l'enregistrement du département,
    respectivement.
    Alors ces deux colonnes actent comme des clés étrangères.
   </para>

   <para>
    Il y a une troisième clé étrangère dans cet exemple, elle est de la
    colonne <varname>employe_du_mois</varname>
    de la table compagnie qui est compris dans une ligne de la table
    employe.
    Notez la différence dans l'intention entre cette clé étrangère et les
    deux autres. La colonne
    <varname>employe_du_mois</varname>
    représente une relation de valeurs simples : il peut y avoir seulement
    un employé du moi pour une compagnie donnée.
    Les colonnes
    <varname>co_id</varname>
    <varname>dept_id</varname>
    représentent des relations de valeurs multiples : une compagnie peut
    contenir plusieurs département et un département peut contenir beaucoup
    d'employés. Cette distinction deviendra évidente lorsque le reste des
    métadonnées sélectionne les relations entre la compagnie-département et le
    département-employé comme étant une relation contenue.
   </para>

   <para>
    Il y a un peu de règles simples qui doivent être suivies lorsque l'on
    construit les métadonnées de base de données :
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Toutes les tables doivent avoir des clés primaires et les clés
      primaires doivent être spécifiées dans les métadonnées. Sans clés
      primaires, il n'est pas possible de garder une trace des identités des
      objets. Comme vous pouvez le voir avec les requête SQL qui créent les
      tables, les clés primaires peuvent être générées automatiquement, ce
      qui signifie, qu'elles sont générées et assignées par la base de
      données lorsque l'enregistrement est inséré. Dans ce cas, la clé
      primaire générée automatiquement est obtenue de la base de données et
      insérées dans l'objet de données immédiatement après que la ligne
      soit insérée dans la base de données.
     </para>
    </listitem>

    <listitem>
     <para>
      Il n'est pas nécessaire de spécifier les métadonnées de toutes les
      colonnes qui existent dans la base de données, seulement celles qui
      seront utilisées. Par exemple, si la table compagnie avait un autre
      colonne que l'application ne souhaite pas accéder avec SDO, il n'est
      pas nécessaire de la spécifiée dans les métadonnées. En contrepartie,
      cela ne devrait pas causer de problème de la spécifier : si elle est
      spécifiée dans les métadonnées mais jamais récupérée ou assignée par
      l'application, alors la colonne inutilisée ne devrait rien affecter.
     </para>
    </listitem>

    <listitem>
     <para>
      Dans les métadonnées de base de données, notez que les définitions
      des clés étrangères n'identifient pas la colonne de destination dans
      la table qui est pointée, mais le nom de la table elle-même.
      Strictement, le modèle relationnel permet la destination d'une clé
      étrangère à être une clé non primaire. Seules les clés étrangères qui
      pointent à une clé primaire sont utiles pour la construction du
      modèle SDO, puisque les métadonnées spécifient le nom de la table. Il
      est entendu que la clé étrangère pointe vers la clé primaire d'une
      table donnée.
     </para>
    </listitem>
   </itemizedlist>

   <para>
    Ayant donné ces règles et les requêtes SQL qui définissent les bases de
    données, les métadonnées de base de données devrait être faciles à
    construire.
   </para>

   <section xml:id="sdo.das.rel.metadata.database.model">
    <title>Que fait DAS Relationnel avec ces métadonnées</title>
    <para>
     Le DAS Relationnel utilise les métadonnées de base de données pour
     former la plupart des modèles SDO. Pour chaque table dans les
     métadonnées de base de données, un type SDO est défini. Chaque colonne
     qui peut représenter une valeur primitive (les colonnes qui ne sont pas
     définies comme étant des clés étrangères) est ajoutée comme propriété
     au type SDO.
    </para>
    <para>
     Toutes les propriétés primitives sont données par un type de &string;
     dans le modèle SDO, sans se soucier de leur type SQL. Lors de la
     ré-écriture des données dans la base de données, le DAS Relationnel
     créera une requête SQL qui traitera les valeurs comme étant des chaînes
     de caractères et la base de données les convertira dans le type
     approprié.
    </para>

    <para>
     Les clés étrangères sont interprétées de une des deux manières,
     dépendamment des métadonnées contenues dans le troisième argument du
     constructeur qui définissent les relations de SDO contenues.
     Une discussion de cela est donc reportée dans la section
     <link linkend="sdo.das.rel.metadata.crels">
      relations SDO contenues
     </link>
     ci-dessous.
    </para>
   </section>

   <section xml:id="sdo.das.rel.metadata.approottype">
    <title>Spécification du type de racine de l'application</title>
    <para>
     Le second argument du constructeur est l'application du type de racine.
     La vraie racine de chaque graphique de données est un objet d'un type de
     racine spécial et tous les objets de données des applications viennent
     quelque part sous cela. De la plupart des types d'application dans le
     modèle SDO, une doit être le type d'application immédiatement sous la
     racine du graphique de données. S'il y a seulement une table dans les
     métadonnées de base de données, le type de racine de l'application peut
     être impliqué et cet argument peut être omis.
    </para>
   </section>

   <section xml:id="sdo.das.rel.metadata.crels">
    <title>Spécification des relations SDO contenues</title>

    <para>
     Le troisième argument du constructeur définit comment les types dans le
     modèle seront liés ensemble pour former un graphique. Cela identifie les
     relations parent-enfant entre les types qui collectivement forment un
     graphique. Les relations doivent être supportées par les clés étrangères
     pour être trouvées dans les données, d'une manière rapide d'être décrit.
    </para>

    <para>
     Les métadonnées sont un tableau contenant un ou plusieurs tableaux
     associatifs, chacun d'eux identifie un parent et un enfant. L'exemple
     ci-dessous montre une relation parent-enfant de compagnie au département
     et un autre du département aux employés. Chacune d'elles deviendra un
     propriété définissant une relation de valeur multiples contenue dans un
     modèle SDO.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$department_containment = array( 'parent' => 'company', 'child' => 'department');
$employee_containment = array( 'parent' => 'department', 'child' => 'employee');

$SDO_containment_metadata = array($department_containment, $employee_containment);
?>
]]>
    </programlisting>

    <para>
     Les clés étrangères dans les métadonnées de base de données sont
     interprétées comme des propriétés avec soit des relations de valeurs
     multiples contenues ou des références de simples valeurs non contenues,
     dépendamment si elles ont une relation SDO contenue correspondante
     spécifiée dans les métadonnées. Dans cet exemple ici, les clés
     étrangères du département à la compagnie (la colonne
     <varname>co_id</varname> dans la table de departement)
     et de l'employé au département (la colonne <varname>dept_id</varname>
     dans la table employe) sont interprétées comme supportant les relations
     SDO contenues. Chaque référence contenue mentionnée dans les métadonnées
     de relations contenue de SDO doit avoir une clé correspondante présente
     dans la base de données et définie dans les métadonnées de base de données.
     Les valeurs des colonnes de la clé étrangère pour les relations contenues
     n'apparaissent pas dans les objets de données; à la place, chacune
     d'entre elles est représentée par une relation contenue du parent à
     l'enfant. Alors la colonne <varname>co_id</varname> dans la ligne de
     département de la base de données, par exemple, n'apparaît pas en tant
     que propriété du type de département, mais apparaît à la place comme
     une relation contenue appelée <varname>departname</varname> sur le
     type de compagnie. Notez que la clé étrangère et la relation
     parent-enfant semble avoir un sens opposé : la clé étrangère pointe du
     département à la compagnie, mais la relation parent-enfant pointe de
     la compagnie au département.
    </para>

    <para>
     La troisième clé dans cet exemple, le <varname>employe_du_mois</varname>,
     est gérée différemment. Elle n'est pas mentionnée dans les métadonnées
     de relations SDO contenues. Ceci a pour conséquence d'être interprété de
     la seconde manière : elle devient une référence de valeur simple non contenue
     sur l'objet compagnie, sur lequel vous pouvez assigner des références au type
     d'employé d'objets de données SDO. Elle apparaît comme une propriété du
     type de compagnie. Le moyen pour lui assigner une valeur dans le
     graphique de données est d'avoir un graphique qui contient un objet
     employé avec les relations contenues et d'assigner l'objet à celui-ci.
     Ceci est montré dans les exemples plus loin.
    </para>
   </section>
  </section> <!--specifying the metadata sdo.das.rel.metadata.database.model -->
 </section> <!-- sdo.das.rel.metadata -->

 <section xml:id="sdo.das.rel.examples.one-table">
  <title>Exemples avec une table</title>
  <para>
   Les exemples suivants utilisent tous le DAS Relationnel pour travailler
   avec un graphique de données contenant juste un objet de données
   d'application, une seule compagnie et les données qui seront dans la
   table compagnie. Ces exemples ne montre pas le pouvoir de SDO ou de DAS
   Relationnel et bien sûr les mêmes résultats peuvent être atteints plus
   économiquement à l'aide de requêtes SQL directes mais ces exemples sont
   pour vous montrer comment fonctionne le DAS Relationnel.
  </para>

  <para>
   Pour ce simple scénario, il serait possible de simplifier les métadonnées
   de base de données pour inclure juste la table de compagnie - si cela
   était fait, le deuxième et troisième argument du constructeur et le
   spécificateur de colonne utilisé dans l'exemple de requête deviendrait
   optionnel.
  </para>

  <para>
   <example>
    <title>Création d'un objet de données</title>
    <para>
     Le plus simple exemple est de créer un objet de données simple et de
     l'écrire à la base de données. Dans cet exemple, un objet simple de
     compagnie est créé, son nom est fixé à <literal>"Acme"</literal> et le DAS Relationnel est
     appelé pour écrire les changements à la base de données. Le nom de la
     compagnie est fixé ici en utilisant la méthode de propriété de nom.
     Voyez la section d'<link linkend="sdo.examples">exemples</link> sur
     l'extension SDO pour d'autres moyens d'accéder au propriétés d'un
     objet.
    </para>

    <para>
     Les objets de données peuvent seulement être créés lorsque vous avez un
     objet de données au démarrage. C'est pour cette raison que le premier
     appel à DAS Relationnel ici est pour obtenir l'objet racine. C'est en
     effet comment demander pour un graphique de données vide - l'objet de
     racine spécial est la vrai racine de l'arbre. L'objet de données
     compagnie est alors créé avec l'appel à
     <function>createDataObject</function>
     sur l'objet racine. Ceci crée l'objet de données compagnie et l'insère
     dans le graphique en insérant une propriété de valeurs multiples
     contenue dans l'objet racine appelé <literal>"compagnie"</literal>.
    </para>
    <para>
     Lorsque DAS Relationnel est appelé pour effectuer les changements, une
     simple requête d'insertion
     <literal>"INSERT INTO compagnie (nom} VALUES ("Acme");"</literal>
     sera construite et exécutée. La clé primaire générée automatiquement
     sera fixée dans l'objet de données et le changement sera effacé, alors
     il serait possible de continuer de travailler avec le même objet de
     données, le modifier, et applique les nouveaux changements une deuxième
     fois.
    </para>

    <programlisting role="php" xml:id="sdo.das.rel.examples.1c-C">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/**************************************************************
 * Construit le DAS avec les métadonnées
 ***************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

/**************************************************************
 * Obtient l'objet racine et crée un objet compagnie dessous.
 * Effectue un petit changement à l'objet de données.
 ***************************************************************/
$root = $das  -> createRootDataObject();
$acme = $root -> createDataObject('compagnie');

$acme->name = "Acme";

/**************************************************************
 * Récupère la connexion à la base de données et écrit l'objet à la base de données
 ***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);
$das -> applyChanges($dbh, $root);
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Récupération d'un objet de données</title>
    <para>
     Dans cet exemple, un simple objet de données est récupéré de la base de
     données - ou possiblement plus d'un s'il y avait plus d'une compagnie
     qui était appelée <literal>"Acme"</literal>. Pour chaque compagnie retournée, les
     propriétés
     <varname>nom</varname>
     et
     <varname>id</varname>
     sont affichées.
    </para>
    <para>
     Dans cet exemple, le troisième argument de
     <function>executeQuery</function>,
     le spécificateur de colonne est requis puisqu'il y a d'autres tables
     dans les métadonnées avec le nom de colonne
     <varname>nom</varname>
     et
     <varname>id</varname>.
     S'il n'y avait pas d'ambiguïté possible, il aurait pu être omis.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1c-R">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/**************************************************************
 * Construit le DAS avec les métadonnées
 ***************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

/**************************************************************
 * Récupère la connexion à la base de données
 ***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);

/**************************************************************
 * Effectue une requête pour obtenir un objet compagnie - possiblement
 * plusieurs s'ils existent
 ***************************************************************/
$root = $das->executeQuery($dbh,
           'select nom, id from compagnie where nom="Acme"',
                        array('compagnie.nom', 'compagnie.id') );

/**************************************************************
 * Affiche le nom et le id
 ***************************************************************/
foreach ($root['compagnie'] as $compagnie) {
    echo "La compagnie obtenue de la base de données a le nom = " .
    $compagnie['nom'] . " et un id " . $compagnie['id'] . "\n";
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Mise à jour d'objet de données</title>
    <para>
     Cet exemple combine les deux précédent, dans le sens que pour être mis
     à jour, l'objet doit être premièrement récupéré. L'application renverse
     le nom de compagnie (alors <literal>"Acme"</literal> devient <literal>"emcA"</literal>) et alors les
     changements sont écrits à la base de données de la même manière qu'ils
     étaient lorsque l'objet avait été créé. Puisque la requête cherche pour
     le nom, on peut chercher des deux manières le nom à
     plusieurs reprises pour trouver la compagnie et renverser son nom
     chaque fois.
    </para>
    <para>
     Dans cet exemple, la même instance de DAS Relationnel est réutilisée
     pour
     <function>applyChanges</function>,
     avec le descripteur de base de données PDO. Ceci est tout à fait
     correcte; il est aussi possible d'autoriser les instances précédentes
     d'être ramassées par le ramasse-miettes et d'obtenir de nouvelles
     instances. Aucune données d'état concernant le graphique n'est tenue
     par le DAS Relationnel une fois qu'il a retourné un graphique de
     données à l'application. Toutes les données nécessaires sont soit dans
     le graphique ou peuvent être reconstruites à partir des métadonnées.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1c-RU">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/**************************************************************
 * Construit le DAS avec les métadonnées
 ***************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

/**************************************************************
 * Récupère la connexion à la base de données
 ***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);

/**************************************************************
 * Effectue une requête pour obtenir un objet compagnie - possiblement
 * plusieurs s'ils existent
 ***************************************************************/
$root = $das->executeQuery($dbh,
    'select nom, id from compagnie where nom="Acme" or nom="emcA"',
    array('compagnie.nom', 'compagnie.id') );

/**************************************************************
 * Modifie le nom de la première compagnie seulement
 ***************************************************************/
$compagnie = $root['compagnie'][0];
echo "Compagnie obtenue avec le nom " . $compagnie->nom . "\n";
$compagnie->nom = strrev($compagnie->nom);

/**************************************************************
 * Écriture du changement
 ***************************************************************/
$das->applyChanges($dbh,$root);
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Suppression d'un objet de données</title>
    <para>
     Toutes compagnies appelées <literal>"Acme"</literal> ou son inverse <literal>"emcA"</literal> sont récupérées.
     Elles sont ensuite toutes supprimées du graphique avec unset.
    </para>

    <para>
     Dans l'exemple, elles sont toutes supprimées en un seul coup en
     supprimant la propriété contenue (la propriété définissant la relation
     contenue). Il est aussi possible de les supprimer individuellement.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1c-RD">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/**************************************************************
 * Construit le DAS avec les métadonnées
 ***************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

/**************************************************************
 * Récupère la connexion à la base de données
 ***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);

/**************************************************************
 * Effectue une requête pour obtenir un objet compagnie - possiblement
 * plusieurs s'ils existent
 ***************************************************************/
$root = $das->executeQuery($dbh,
    'select nom, id from compagnie where nom="Acme" or nom="emcA"',
    array('company.name', 'company.id') );

/**************************************************************
 * Supprime les compagnies trouvées du graphique de données
 ***************************************************************/
unset($root['compagnie']);

/**************************************************************
 * Écrit le(s) changement(s)
 ***************************************************************/
$das->applyChanges($dbh,$root);
?>
]]>
    </programlisting>
   </example>
  </para>

 </section> <!-- one-table -->

 <section xml:id="sdo.das.rel.examples.two-table">
  <title>Exemples avec deux tables</title>
  <para>
   Les exemples suivants utilisent tous deux tables de la base de données
   compagnie : les tables compagnie et departement. Ces exemples montrent
   plus le fonctionnement de DAS Relationnel.
  </para>
  <para>
   Dans cette série d'exemples, une compagnie et un département son créé,
   récupéré, mis à jour et finalement supprimé. Ceci montre le cycle de vie
   pour un graphique de données contenant plus d'un objet. Notez que cet
   exemple vide les tables compagnie et departement au démarrage, ainsi
   les résultats exacts des requêtes peuvent être connus.
  </para>
  <para>
   Vous pouvez trouvez ces exemples combinés dans un script appelé
   <filename>1cd-CRUD</filename> dans le répertoire <filename>Scenarios</filename>
   du paquetage DAS Relationnel.
  </para>

  <para>
   <example>
    <title>Une compagnie, un département - Création</title>
    <para>
     Comme dans l'exemple précédent où l'on créait juste un objet de données
     de compagnie, la première action après la construction du DAS
     Relationnel est d'appeler <function>createRootDataObject</function>
     pour obtenir l'objet racine spécial du graphique de données vide.
     L'objet compagnie est alors créé en tant que fils de cet objet racine,
     et l'objet departement en tant que fils de l'objet compagnie.
    </para>
    <para>
     Lorsqu'il est venu le temps d'appliquer les changements, le DAS Relationnel doit
     effectuer des traitements spéciaux pour maintenir la clé étrangère qui
     supporte les relations contenues, en particulier si une clé
     primaire générée automatiquement est en jeu. Dans cet exemple, les
     relations entre la clé primaire générée automatiquement
     <varname>id</varname> dans la table compagnie et la colonne
     <varname>co_id</varname> dans la table departement doivent être maintenues.
     Lors de l'insertion de la compagnie et du département pour la première
     fois, le DAS Relationnel doit premièrement insérer une ligne de compagnie,
     ensuite appeler la méthode de PDO <function>getLastInsertId</function>
     pour obtenir la clé primaire générée automatiquement, et ensuite
     ajouter la valeur à la colonne <varname>co_id</varname>
     lors de l'insertion de la ligne departement.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1cd-C">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/*************************************************************************************
* Vidage des deux tables
*************************************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);
$pdo_stmt = $dbh->prepare('DELETE FROM COMPAGNIE;');
$rows_affected = $pdo_stmt->execute();
$pdo_stmt = $dbh->prepare('DELETE FROM DEPARTEMENT;');
$rows_affected = $pdo_stmt->execute();

/**************************************************************
* Crée une compagnie avec le nom Acme et un département, département de Chaussure
***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

$root = $das -> createRootDataObject();

$acme = $root -> createDataObject('compagnie');
$acme -> nom = "Acme";

$chaussure = $acme->createDataObject('departement');
$chaussure->nom = 'Chaussure';

$das -> applyChanges($dbh, $root);

?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Une compagnie, un département - Récupération et Mise à jour</title>

    <para>
     Dans ce cas, la requête SQL passé à
     <function>executeQuery</function>
     exécute un inner join pour joindre les données des tables compagnie et
     departement. Les clés primaires pour les tables compagnie et
     departement doivent être incluses dans la requête. Le jeu de résultats
     est normalisé de nouveau pour former un graphique de données normalisé. Notez
     que le spécificateur de colonne est passé en troisième argument de
     l'appel
     <function>executeQuery</function>
     qui autorise DAS Relationnel de savoir quelle colonne est laquelle dans
     le jeu de résultats.
    </para>
    <para>
     Notez que la colonne
     <varname>co_id</varname>
     bien qu'utilisée dans la requête n'est pas requis dans le jeu de
     résultats. Afin de comprendre que fait DAS Relationnel lorsqu'il
     construit le graphique de données, il peut être utile de visualiser
     à quoi ressemble les jeu de résultats. Bien que les données dans la
     base de données sont normalisée, alors plusieurs lignes de département
     peuvent pointer vers la clé étrangère d'une ligne de compagnie, les
     données dans le jeu de résultats sont non-normalisée : c'est, s'il y a
     une compagnie et de multiples département, les valeurs pour la
     compagnie qui sont répétées à chaque ligne. Le DAS Relationnel doit
     renverser ce processus et retourner le jeu de résultats dans un graphique
     normalisé, avec seulement un objet compagnie.
    </para>
    <para>
     Dans cet exemple, le DAS Relationnel examine le jeu de résultats et le
     spécificateur de colonne, trouve les données pour les tables compagnie
     et departement, trouve les clés primaires pour les deux et interprète
     chaque ligne comme contenant des données d'un département et comme
     parent compagnie. S'il n'a pas vue de données de la compagnie
     auparavant (il utilise la clé primaire pour vérifier), il crée un objet
     compagnie et ensuite l'objet compagnie sous lui. S'il a vu des données
     pour la compagnie avant et a déjà créé l'objet compagnie, il crée
     simplement l'objet departement sous lui.
    </para>

    <para>
     De cette manière, le DAS Relationnel peut récupérer et normaliser de
     nouveau les données pour de multiples compagnies et de multiples
     départements sous ceux-ci.
    </para>

    <programlisting role="php" xml:id="sdo.das.rel.examples.1cd-RU">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/**************************************************************
 * Récupération de la compagnie et du département de Chaussure, ensuite
 * supprime Chaussure et ajoute IT
 ***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

$root = $das->executeQuery($dbh,
'select c.id, c.nom, d.id, d.nom from compagnie Â«c, departement d where d.co_id = c.id',
array('compagnie.id','compagnie.nom','departement.id','departement.nom'));

$acme      = $root['compagnie'][0];            // récupère la première compagnie - sera 'Acme'
$chaussure = $acme['departement'][0];          // récupère le premier département en dessous - sera 'Chaussure'

unset($acme['departement'][0]);

$it = $acme->createDataObject('departement');
$it->name = 'IT';

$das -> applyChanges($dbh, $root);
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Une compagnie, deux départements - Récupération et Suppression</title>
    <para>
     Dans cet exemple, la compagnie et le département sont récupérés et
     ensuite supprimés. Il n'est pas nécessaire de les supprimer
     individuellement (bien que cela est possible) - la suppression de
     l'objet compagnie du graphique de données supprime aussi tous les
     départements sous lui.
    </para>
    <para>
     Notez le moyen de l'objet compagnie est actuellement supprimé en
     utilisant l'appel unset de PHP. La suppression doit être effectuée
     sur la propriété qui est dans ce cas la propriété de compagnie sur
     l'objet racine spécial. Vous devez utiliser :
     <programlisting role="php" xml:id="sdo.das.rel.examples.1cd-CRUD.good-delete">
<![CDATA[
<?php
unset($root['company'][0]);
?>
]]>
     </programlisting>
     et non pas :
     <programlisting role="php" xml:id="sdo.das.rel.examples.1cd-CRUD.bad-delete">
<![CDATA[
<?php
unset($acme); //FAUX
?>
]]>
     </programlisting>
     La suppression de <varname>$acme</varname>
     détruira simplement la variable mais laissera les données dans le
     graphique intacte.
    </para>

    <programlisting role="php" xml:id="sdo.das.rel.examples.1cd-RD">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/**************************************************************
 * Récupération de la compagnie et du département IT, ensuite supprime la
 * compagnie entière
 ***************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);

$root = $das->executeQuery($dbh,
'select c.id, c.nom, d.id, d.nom from compagnie c, departement d where d.co_id = c.id',
array('compagnie.id','compagnie.nom','departement.id','departement.nom'));

$acme = $root['compagnie'][0];
$it = $acme['departement'][0];

unset($root['compagnie'][0]);

$das -> applyChanges($dbh, $root);

?>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="sdo.das.rel.examples.three-table">
  <title>Exemple avec trois tables</title>
  <para>
   Les exemples suivant utilisent tous trois tables de la base de données
   compagnie : les tables compagnie, departement et employe. Elles
   introduisent le dernier morceau du fonctionnement non expliqué dans les
   exemples ci haut : la référence non contenue
   <varname>employe_du_mois</varname>.
  </para>
  <para>
   Comme les exemples ci haut pour la compagnie et le département, la série
   d'exemples illustre le cycle de vie complet d'un graphique de données.
  </para>


  <para>
   <example>
    <title>Une compagnie, un département, un employé - Création</title>
    <para>
     Dans cet exemple, une compagnie est créée contenant un département et
     seulement un employé. Notez que dans cet exemple, les trois tables sont
     vidées à leur démarrage ainsi les résultats exacts des requêtes peuvent
     être connus.
    </para>
    <para>
     Notez comment une fois que la compagnie, le département et l'employé
     est créé que la propriété
     <varname>employe_du_mois</varname>
     de la compagnie peut être faite pour pointer au nouvel employé.
     Puisque c'est une référence qui n'est pas contenue, ceci ne peut être
     effectué tant que l'objet employé ait été créé dans le graphique. Les
     références non contenues doivent être gérées prudemment. Par exemple,
     si un employé est maintenant supprimé de son département, il ne serait
     pas correcte d'essayer de sauver le graphique sans premièrement
     effacer ou réassigner la propriété
     <varname>employe_du_mois</varname>.
     Cette règle SDO requiert que tous les objets
     pointé par une référence qui n'est pas contenue doit être aussi
     accessible par des relations contenues.
    </para>
    <para>
     Lorsque vient le moment d'insérer le graphique dans la base de données,
     la procédure est similaire à l'exemple d'insertion d'une compagnie et
     d'un département, cependant, la propriété
     <varname>employe_du_mois</varname>
     introduit une plus grande complexité.
     Le DAS Relationnel doit insérer les objets en descendant l'arbre formée
     des relations contenues, donc la compagnie, ensuite le département et
     ensuite l'employée. Ceci est nécessaire puisqu'il y a toujours une clé
     primaire générée automatiquement du parent pour l'inclure dans une ligne
     du fils. Mais lorsque la compagnie est insérée, l'employée qui est
     l'employé du mois n'est pas encore inséré et la clé primaire est
     inconnue. La procédure est qu'après l'insertion de l'employé et que sa
     clé primaire soit connue, une dernière étape est effectuée qui permet
     de modifier la compagnie avec la clé primaire de l'employé.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1cde-C">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/*************************************************************************************
* Vidage des deux tables
*************************************************************************************/
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);
$pdo_stmt = $dbh->prepare('DELETE FROM COMPAGNIE;');
$rows_affected = $pdo_stmt->execute();
$pdo_stmt = $dbh->prepare('DELETE FROM DEPARTEMENT;');
$rows_affected = $pdo_stmt->execute();
$pdo_stmt = $dbh->prepare('DELETE FROM EMPLOYE;');
$rows_affected = $pdo_stmt->execute();

/*************************************************************************************
* Crée une compagnie minuscule mais complète.
* Le nom de la compagnie est Acme.
* Il y a un département, Chaussure.
* Il y a une employé, Bob.
* L'employé du mois est Bob.
*************************************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);

$root        = $das  -> createRootDataObject();
$acme        = $root -> createDataObject('compagnie');
$acme -> nom = "Acme";
$chaussure   = $acme -> createDataObject('departement');
$chaussure -> nom         = 'Chaussure';
$chaussure -> emplacement = 'Bloc-A';
$bob                              = $chaussure -> createDataObject('employe');
$bob -> nom              = 'Bob';
$acme -> employe_du_mois = $bob;

$das -> applyChanges($dbh, $root);

echo "Écriture de Acme avec un département et un employé\n";
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Une compagnie, un département, un employé - Récupération et Mise à Jour</title>
    <para>
     La requête SQL passée à DAS Relationnel est cette fois un inner join
     qui récupère les données des trois tables. Autrement, cet exemple
     n'introduit rien de nouveau de l'exemple précédent
    </para>
    <para>
     Le graphique est mis à jour avec l'addition d'un nouveau département et
     d'un nouvel employé et quelques modifications au propriétés de nom des
     objets existant dans le graphique. Les changements combinés sont écrits.
     Le DAS Relationnel traitera et appliquera un mélange arbitraire des
     additions, des modifications et des suppressions provenant et allant
     vers le graphique.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1cde-RU">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/*************************************************************************************
 * Trouve la compagnie encore et change certains aspects.
 * Change le nom de la compagnie, le département et l'employé.
 * Ajoute un second département et un nouvel employé.
 * Change l'employé du mois
 *************************************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);

$root = $das->executeQuery($dbh,
    "select c.id, c.nom, c.employe_du_mois, d.id, d.nom, e.id, e.nom " .
    "from compagnie c, departement d, employe e " .
    "where e.dept_id = d.id and d.co_id = c.id and c.nom='Acme'",
     array('compagnie.id','compagnie.nom','compagnie.employe_du_mois',
     'departement.id','departement.nom','employe.id','employe.nom'));
$acme   = $root['compagnie'][0];

$chaussure      = $acme->departement[0];
$bob          = $chaussure -> employe[0];

$it     = $acme->createDataObject('departement');
$it->nom = 'IT';
$it->location = 'Bloc-G';
$billy  = $it->createDataObject('employe');
$billy->nom = 'Billy';

$acme->nom = 'MegaCorp';
$chaussure->nom = 'Footwear';
$sue->nom = 'Suzan';

$acme->employe_du_mois = $billy;
$das -> applyChanges($dbh, $root);
echo "Écriture de la compagnie avec un département en plus et un employé et
tous les noms ont changés Megacorp/Footwear/Suzan)\n";

?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Une compagnie, deux départements, deux employés - Récupération et Suppression</title>
    <para>
     La compagnie est récupéré en tant qu'un graphique de données complet
     contenant cinq objets de données - la compagnie, deux départements et
     deux employés. Ils sont tous supprimés en supprimant l'objet compagnie.
     La suppression d'un objet du graphique supprime tous les objets sous
     celui-ci dans le graphique. Cinq requêtes DELETE SQL sera générées et
     exécutée. Comme d'habitude, elles seront qualifiées avec une clause
     WHERE qui contient tous les champs qui ont été récupérés, alors toutes
     les mises à jour des données dans la base de données pendant ce temps
     par un autre processus seront détectées.
    </para>
    <programlisting role="php" xml:id="sdo.das.rel.examples.1cde-RD">
<![CDATA[
<?php
require_once 'SDO/DAS/Relational.php';
require_once 'company_metadata.inc.php';

/*************************************************************************************
 * Maintenant lit une ou plusieurs fois et supprime.
 * Vous pouvez supprimer par partie, appliquer les changements, et ensuite
 * continuer à travailler avec le même graphique de données mais la précaution
 * est requise pour garder véracité - vous ne pouvez pas supprimer l'employé
 * qui est l'employé du mois sans le réassigner. Pour plus de précaution ici,
 * nous supprimons la compagnie en entier d'un seul coup.
 *************************************************************************************/
$das = new SDO_DAS_Relational ($database_metadata,'compagnie',$SDO_containment_metadata);
$dbh = new PDO(PDO_DSN,DATABASE_USER,DATABASE_PASSWORD);

$root = $das->executeQuery($dbh,
    "select c.id, c.nom, c.employe_du_mois, d.id, d.nom, e.id, e.nom " .
    "from compagnie c, departement d, employe e " .
    "where e.dept_id = d.id and d.co_id = c.id and c.nom='MegaCorp';",
     array('compagnie.id','compagnie.nom','compagnie.employe_du_mois',
     'departement.id','departement.nom','employe.id','employe.nom'));
$megacorp = $root['compagnie'][0];

unset($root['compagnie']);
$das -> applyChanges($dbh, $root);

echo "Suppression de la compagnie, des départements et des employés d'un seul coup.\n";

?>
]]>
    </programlisting>
   </example>
  </para>
 </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->