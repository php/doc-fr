<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 39752929cd4ab78db8a7310dfb328444c558df99 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->
<refentry xml:id="function.create-function" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>create_function</refname>
  <refpurpose>Crée une fonction anonyme</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  &warn.deprecated.function-7-2-0.removed-8-0-0;
 </refsynopsisdiv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>string</type><methodname>create_function</methodname>
   <methodparam><type>string</type><parameter>args</parameter></methodparam>
   <methodparam><type>string</type><parameter>code</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>create_function</function> crée une fonction anonyme,
   à partir des paramètres passés, et retourne un nom de fonction unique.
  </para>
  <caution>
   <para>
    Cette fonction, en interne, utilise la fonction
    <function>eval</function> et donc les exigences en termes
    de sécurité sont identiques à celles de la fonction <function>eval</function>.
    De plus, les performances ne sont pas au rendez-vous et l'usage mémoire
    est significatif.
   </para>
   <para>
    Une <link linkend="functions.anonymous">fonction anonyme</link> native
    devrait être utilisée à la place.
   </para>
  </caution>
 </refsect1>
 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   Généralement, les arguments <parameter>args</parameter> sont
   présentés sous la forme d'une chaîne à guillemets simples, et la même
   recommandation vaut pour <parameter>code</parameter>.
   La raison de l'utilisation des guillemets simples est de protéger
   les noms de variables du remplacement par leur valeur. Si l'on utilise
   les guillemets doubles, n'oubliez pas d'échapper les noms
   de variables (c.-à-d. <literal>\$avar</literal>).
   <variablelist>
    <varlistentry>
     <term><parameter>args</parameter></term>
     <listitem>
      <para>
       Les arguments de la fonction, sous forme d'une seule chaîne séparée par des virgules.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>code</parameter></term>
     <listitem>
      <para>
       Le code de la fonction.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne un nom de fonction unique, sous la forme d'une &string;,
   ou &false; si une erreur survient. Il est à noter que le nom contient
   un caractère non imprimable (<literal>"\0"</literal>), il faut donc
   faire attention lors de l'affichage du nom ou de son incorporation dans
   une autre chaîne.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>
     Création d'une fonction dynamique avec <function>create_function</function>
     ou les fonctions anonymes
    </title>
    <para>
     Il est possible d'utiliser une fonction créée dynamiquement pour (par exemple)
     créer une fonction à partir d'informations récoltées durant l'exécution.
     D'abord, en utilisant <function>create_function</function> :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');
echo $newfunc(2, M_E) . "\n";
?>
]]>
    </programlisting>
    <para>
     Maintenant le même code, en utilisant une
     <link linkend="functions.anonymous">fonction anonyme</link> ;
     il est à noter que le code et les arguments ne sont plus contenus dans des chaînes :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$newfunc = function($a,$b) { return "ln($a) + ln($b) = " . log($a * $b); };
echo $newfunc(2, M_E) . "\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
ln(2) + ln(2.718281828459) = 1.6931471805599
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>
     Traitement générique par fonction avec <function>create_function</function>
     ou les fonctions anonymes
    </title>
    <para>
     Une autre utilisation pourrait être d'avoir une fonction de traitement générique
     qui peut appliquer un ensemble d'opérations à une liste de paramètres :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
function process($var1, $var2, $farr)
{
    foreach ($farr as $f) {
        echo $f($var1, $var2) . "\n";
    }
}

// Création d'une série de fonctions mathématiques
$farr = array(
    create_function('$x,$y', 'return "un peu de trigo : ".(sin($x) + $x*cos($y));'),
    create_function('$x,$y', 'return "une hypoténuse : ".sqrt($x*$x + $y*$y);'),
    create_function('$a,$b', 'if ($a >=0) {return "b*a^2 = ".$b*sqrt($a);} else {return false;}'),
    create_function('$a,$b', "return \"min(b^2+a, a^2,b) = \".min(\$a*\$a+\$b,\$b*\$b+\$a);"),
    create_function('$a,$b', 'if ($a > 0 && $b != 0) {return "ln(a)/b = ".log($a)/$b; } else { return false; }')
);

echo "\nUtilisation de la première liste de fonctions anonymes\n";
echo "paramètres : 2.3445, M_PI\n";
process(2.3445, M_PI, $farr);

// Maintenant une liste de fonctions sur chaîne de caractères
$garr = array(
    create_function('$b,$a', 'if (strncmp($a, $b, 3) == 0) return "** \"$a\" '.
        'and \"$b\"\n** Look the same to me! (looking at the first 3 chars)";'),
    create_function('$a,$b', 'return "CRCs: " . crc32($a) . ", ".crc32($b);'),
    create_function('$a,$b', 'return "similar(a,b) = " . similar_text($a, $b, $p) . "($p%)";')
);
echo "\nUtilisation de la seconde liste de fonctions anonymes\n";
process("Twas brilling and the slithy toves", "Twas the night", $garr);
?>
]]>
    </programlisting>
    <para>
     Encore une fois, voici le même code en utilisant les
     <link linkend="functions.anonymous">fonctions anonymes</link>.
     Il est à noter que les noms de variables dans le code n'ont plus besoin d'être échappés,
     car ils ne sont plus inclus dans une chaîne.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
function process($var1, $var2, $farr)
{
    foreach ($farr as $f) {
        echo $f($var1, $var2) . "\n";
    }
}

// Création d'une série de fonctions mathématiques
$farr = array(
    function($x,$y) { return "un peu de trigo : ".(sin($x) + $x*cos($y)); },
    function($x,$y) { return "une hypoténuse : ".sqrt($x*$x + $y*$y); },
    function($a,$b) { if ($a >=0) {return "b*a^2 = ".$b*sqrt($a);} else {return false;} },
    function($a,$b) { return "min(b^2+a, a^2,b) = " . min($a*$a+$b, $b*$b+$a); },
    function($a,$b) { if ($a > 0 && $b != 0) {return "ln(a)/b = ".log($a)/$b; } else { return false; } }
);

echo "\nUtilisation de la première liste de fonctions anonymes\n";
echo "paramètres : 2.3445, M_PI\n";
process(2.3445, M_PI, $farr);

// Maintenant une liste de fonctions sur chaîne de caractères
$garr = array(
    function($b,$a) { if (strncmp($a, $b, 3) == 0) return "** \"$a\" " .
        "and \"$b\"\n** Look the same to me! (looking at the first 3 chars)"; },
    function($a,$b) { return "CRCs: " . crc32($a) . ", ".crc32($b); },
    function($a,$b) { return "similar(a,b) = " . similar_text($a, $b, $p) . "($p%)"; }
);
echo "\nUtilisation de la seconde liste de fonctions anonymes\n";
process("Twas brilling and the slithy toves", "Twas the night", $garr);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Utilisation de la première liste de fonctions anonymes
paramètres : 2.3445, M_PI
un peu de trigo : -1.6291725057799
une hypoténuse : 3.9199852871011
b*a^2 = 4.8103313314525
min(b^2+a, a^2,b) = 8.6382729035898
ln(a)/b = 0.27122299212594

Utilisation de la seconde liste de fonctions anonymes
** "Twas the night" and "Twas brilling and the slithy toves"
** Look the same to me! (looking at the first 3 chars)
CRCs: 3569586014, 342550513
similar(a,b) = 11(45.833333333333%)
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Utilisation de fonctions dynamiques comme fonction de rappel</title>
    <para>
     L'utilisation la plus courante des fonctions dynamiques est probablement
     de les passer comme fonctions de rappel, par exemple lors de l'utilisation de
     <function>array_walk</function> ou <function>usort</function>.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$av = array("la ", "une ", "cette ", "une certaine ");
array_walk($av, create_function('&$v,$k', '$v = $v . "maison";'));
print_r($av);
?>
]]>
    </programlisting>
    <para>
     Conversion en <link linkend="functions.anonymous">fonction anonyme</link> :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$av = array("la ", "une ", "cette ", "une certaine ");
array_walk($av, function(&$v,$k) { $v = $v . "maison"; });
print_r($av);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
  [0] => la maison
  [1] => une maison
  [2] => cette maison
  [3] => une certaine maison
)
]]>
    </screen>
    <para>
     Tri de chaînes de la plus longue à la plus courte avec <function>create_function</function> :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$sv = array("petite", "une longue chaîne", "longue", "une phrase toute entière");
echo "Original :\n";
print_r($sv);
echo "Trié :\n";
usort($sv, create_function('$a,$b','return strlen($b) - strlen($a);'));
print_r($sv);
?>
]]>
    </programlisting>
    <para>
     Conversion en <link linkend="functions.anonymous">fonction anonyme</link> :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$sv = array("petite", "une longue chaîne", "longue", "une phrase toute entière");
echo "Original :\n";
print_r($sv);
echo "Trié :\n";
usort($sv, function($a,$b) { return strlen($b) - strlen($a); });
print_r($sv);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Original :
Array
(
  [0] => petite
  [1] => une longue chaîne
  [2] => longue
  [3] => une phrase toute entière
)
Trié :
Array
(
  [0] => une phrase toute entière
  [1] => une longue chaîne
  [2] => longue
  [3] => petite
)
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><link linkend="functions.anonymous">Fonctions anonymes</link></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
