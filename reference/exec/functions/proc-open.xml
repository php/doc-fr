<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- splitted from ./en/functions/exec.xml, last change in rev 1.28 -->
  <refentry id="function.proc-open">
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     Exécute une commande et ouvre les pointeurs de fichiers pour les entrées sorties
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>descriptorspec</parameter></methodparam>
      <methodparam><type>array</type><parameter>pipes</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> est similaire à <function>popen</function>
     mais fournie un plus grand degré de contrôle sur l'exécution du programme.
     <parameter>cmd</parameter> est la commande qui doit être exécutée par le shell.
     <parameter>descriptorspec</parameter> est un tableau indexé, dont les clés
     représentent le numéro de descripteur, et la valeur représente la méthode
     avec laquelle &php; va passer ce descripteur au processus fils.
     <parameter>pipes</parameter> recevra un tableau indexé de pointeurs de
     fichiers, qui correspondent aux sorties dans &php; de tous les pipes
     qui sont créés. La valeur retournée est une ressource, qui représente le
     processus. Il faudra la détuire avec la fonction <function>proc_close</function>
     lorsque vous aurez fini.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>proc_open</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin est un pipe où le processus va lire
   1 => array("pipe", "w"),  // stdout est un pipe où le processus va écrire
   2 => array("file", "/tmp/error-output.txt", "a"), // stderr est un fichier
);
$process = proc_open("php", $descriptorspec, $pipes);
if (is_resource($process)) {
    // $pipes ressemble à : 
    // 0 => fichier accessible en écriture, connecté à l'entrée standard du prcessus fils
    // 1 => fichier accessible en lecture, connecté à la sortie standard du prcessus fils
    // Toute erreur sera ajoutée au fichier /tmp/error-output.txt

    fwrite($pipes[0], "<?php echo \"Bonjour le monde!\"; ?>");
    fclose($pipes[0]);

    while(!feof($pipes[1])) {
        echo fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);
    // Il est important que vous fermiez les pipes avant d'appeler
    // proc_close() afin d'éviter un verrouillage.
    $return_value = proc_close($process);

    echo "La commande a retournée $return_value\n";
}
?>
]]>
     </programlisting>
     </example>
    </para>
    <para>
     Les numéros de descripteurs de fichiers de <parameter>descriptorspec</parameter> 
     ne sont pas limitées à 0, 1 et 2 : vous pouvez spécifier n'importe quel
     numéro de descripteur valide, et il sera passé au processus fils. Cela 
     permettra à votre script d'inter opérer avec d'autres scripts, et d'être
     exécuté comme "co-processus". En particulier, c'est très pratique pour
     passer des mots de passes à des programmes comme PGP, GPG et openssl,
     avec une méthode très protégée. C'est aussi pratique pour lire des
     informations de statut fournies par ces programmes, sur des descripteurs
     auxiliaires.
    </para>
    <note>
     <para>
      Compatibilité Windows : les descripteurs au-dela de 2 (stderr) sont
      accessibles au processus fils, sous la forme de pointeurs héritables, mais
      comme l'architecture Windows n'associe pas de nombre aux descripteurs
      de bas niveau, le processus fils n'a (actuellement) aucun moyen 
      d'y accéder. Stdin, stdout et stderr fonctionnent comme d'habitude.
     </para>
    </note>
    <note>
     <para>
      Cette fonction a été introduite en PHP 4.3.0.
     </para>
    </note>
    <note>
     <para>
      Si vous n'avez besoin que d'un processus uni-directionnel,
      <function>popen</function> sera plus pratique, car plus simple à 
      utiliser.
     </para>
    </note>

    <para>
     Voir aussi
     <function>exec</function>, 
     <function>system</function>,
     <function>passthru</function>, 
     <function>popen</function>,
     <function>escapeshellcmd</function>, et 
     <link linkend="language.operators.execution">l'opérateur de backticks</link>.
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
