<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.14 Maintainer: dams Status: ready -->
<!-- Reviewed: no -->
<refentry id='function.proc-open'>
 <refnamediv>
  <refname>proc_open</refname>
  <refpurpose>
   Exécute une commande et ouvre les pointeurs de fichiers pour les entrées / sorties
  </refpurpose>
 </refnamediv>
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>resource</type><methodname>proc_open</methodname>
   <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
   <methodparam><type>array</type><parameter>descriptorspec</parameter></methodparam>
   <methodparam><type>array</type><parameter role="reference">pipes</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>cwd</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>env</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>other_options</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>proc_open</function> est similaire à <function>popen</function>
   mais fournit un plus grand degré de contrôle sur l'exécution du programme.
  </para>
  <para>
   &php; 5 introduit le support pty pour les systèmes avec Unix98 ptys. 
   Cela permet à votre script d'interagir avec des applications qui
   s'attendent à dialoguer avec un terminal. Un pty fonctionne comme un pipe,
   mais est bi-directionnel : il n'y a pas besoin de spécifier de mode lecture
   ou écriture. L'exemple ci-dessous montre comment utiliser un pty. Notez
   que tous les pointeurs de fichier ne doivent pas nécessairement dialoguer
   avec le pty. Notez aussi que seul un pty est créé, même si pty est
   spécifié 3 fois. Dans les futures versions de &php; il sera possible de faire
   plus que simplement lire et écrire dans un pty.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>cmd</parameter></term>
     <listitem>
      <para>
       La commande à exécuter
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>descriptorspec</parameter></term>
     <listitem>
      <para>
       Un tableau indexé, dont les clés représentent le numéro de descripteur 
       et la valeur la méthode avec laquelle &php; va passer ce descripteur au 
       processus fils. 0 est stdin, 1 est stdout, et 2 est stderr.
      </para>
      <para>
       Les types de descripteurs actuellement supportés sont
       <literal>file</literal>, <literal>pipe</literal> et <literal>pty</literal>.
      </para>
      <para>
       Les numéros de descripteurs de fichiers ne sont pas limités à 0, 1 et 2 -
       vous pouvez spécifier n'importe quel numéro de descripteur valide, et
       il sera passé au processus fils. Cela permettra à votre script d'inter opérer
       avec d'autres scripts, et d'être exécuté comme "co-processus". En particulier,
       c'est très pratique pour passer des mots de passes à des programmes comme
       PGP, GPG et openssl, avec une méthode très protégée. C'est aussi pratique
       pour lire des informations de statut fournies par ces programmes, sur des
       descripteurs auxiliaires.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>pipes</parameter></term>
     <listitem>
      <para>
       Doit être défini en un tableau indexé de pointeurs de fichiers qui 
       correspondent à la fin de n'importe quel descripteur &php; qui sont
       crés.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>cwd</parameter></term>
     <listitem>
      <para>
       Le dossier initial de travail de la commande. Cela doit être
       un chemin <emphasis role="strong">absolu</emphasis>
       vers le dossier ou &null; si vous voulez utiliser la valeur
       par défaut (le dossier de travail du processus courant &php;)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>env</parameter></term>
     <listitem>
      <para>
       Un tableau contenant les variables d'environnement pour la commande
       qui doit être exécutée, ou &null; pour utiliser le même environnement
       que le processus &php; courant
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>other_options</parameter></term>
     <listitem>
      <para>
       Vous permet de spécifier des options aditionnelles. Actuellement,
       uniquement <literal>suppress_errors</literal> est supporté,
       qui supprime les erreurs générées par cette fonction lorsqu'il est
       défini à &true;
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne une ressource représentant le processus, qui pourra être utilisé par 
   la fonction <function>proc_close</function> lorsque vous n'en aurez plus besoin.
   En cas d'échec, &false; sera retourné.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>5.0.0.</entry>
       <entry>
        Ajout des paramètres <parameter>cwd</parameter>, <parameter>env</parameter> et
        <parameter>other_options</parameter>. Ajout du support pour
        Unix98 ptys.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Exemple avec <function>proc_open</function></title>
    <programlisting role="php">
<![CDATA[
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // // stdin est un pipe où le processus va lire
   1 => array("pipe", "w"),  // stdout est un pipe où le processus va écrire
   2 => array("file", "/tmp/error-output.txt", "a") // stderr est un fichier
);

$cwd = '/tmp';
$env = array('quelques_options' => 'aeiou');

$process = proc_open('php', $descriptorspec, $pipes, $cwd, $env);

if (is_resource($process)) {
    // $pipes ressemble à :
    // 0 => fichier accessible en écriture, connecté à l'entrée standard du processus fils
    // 1 => fichier accessible en lecture, connecté à la sortie standard du processus fils
    // Toute erreur sera ajoutée au fichier /tmp/error-output.txt

    fwrite($pipes[0], '<?php print_r($_ENV); ?>');
    fclose($pipes[0]);

    echo stream_get_contents($pipes[1]);
    fclose($pipes[1]);

    // Il est important que vous fermiez les pipes avant d'appeler
    // proc_close afin d'éviter un verrouillage.
    $return_value = proc_close($process);

    echo "La commande a retourné $return_value\n";
}
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Array
(
    [some_option] => aeiou
    [PWD] => /tmp
    [SHLVL] => 1
    [_] => /usr/local/bin/php
)
La commande a retourné 0
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Utilisation de ptys</title>
    <programlisting role="php">
<![CDATA[
<?php
// Crée un pseudo terminal pour le processus fils
$descriptorspec = array(
   0 => array("pty"),
   1 => array("pty"),
   2 => array("pty")
);
$process = proc_open("cvs -d:pserver:cvsread@cvs.php.net:/repository login", $descriptorspec, $pipes);
if (is_resource($process)) {
   // Travaille sur la documentation PHP ici
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    Compatibilité Windows : les descripteurs au-delà de 2 (stderr) sont
    accessibles au processus fils, sous la forme de pointeurs héritables, mais
    comme l'architecture Windows n'associe pas de nombre aux descripteurs
    de bas niveau, le processus fils n'a (actuellement) aucun moyen 
    d'y accéder. Stdin, stdout et stderr fonctionnent comme d'habitude.
   </para>
  </note>
  <note>
   <para>
    Si vous n'avez besoin que d'un processus uni-directionnel,
    <function>popen</function> sera plus pratique, car plus simple à 
    utiliser.
   </para>
  </note>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>popen</function></member>
    <member><function>exec</function></member>
    <member><function>system</function></member>
    <member><function>passthru</function></member>
    <member><function>stream_select</function></member>
    <member>The <link linkend="language.operators.execution">les guillemets obliques</link></member>
   </simplelist>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->