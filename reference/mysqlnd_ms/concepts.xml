<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 55f2060721a1ea31a52a8a8cec267b1777812227 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-ms.concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Concepts</title>
 <para>
  Cette section détaille l'architecture et les concepts associés au plugin, puis
  décrit l'impact de la réplication MySQL et du plugin sur la tâche de
  développement. Comprendre ces concepts est nécessaire pour bien utiliser
  le plugin.
 </para>
 <section xml:id="mysqlnd-ms.architecture">
  <title>Architecture</title>
  <para>
   Le plugin mysqlnd de réplication et de répartition de charge est implémenté sous
   forme d'extension PHP. Il est écrit en C et agit sous PHP et durant la phase de
   démarrage de l'interpréteur PHP (phase d'initialisation des modules) il est enregistré
   comme plugin <link linkend="book.mysqlnd">mysqlnd</link> pour remplacer des fonctions
   C spécifiques.
  </para>
  <para>
   Au déroulement de PHP, il inspecte les requêtes envoyées depuis mysqlnd(PHP) au serveur
   MySQL. Si une requête est reconnue comme étant de type lecture seule, elle sera aiguillée
   vers un des serveurs esclaves configurés. Ceci est le cas pour les requêtes commençant
   par <literal>SELECT</literal>, au moyen de l'astuce SQL <literal>/*ms=slave*/</literal> ou alors
   si un esclave a été choisi pour exécuter la requête précédente et qu'elle utilisait l'astuce
   SQL <literal>/*ms=last_used*/</literal>. Dans tous les autres cas, la requête sera envoyée au
   serveur maitre.
  </para>
  <para>
   Les applications doivent utiliser les 
   <link linkend="mysqlnd-ms.constants">constantes prédéfinies</link>
   <constant>MYSQLND_MS_MASTER_SWITCH</constant>,
   <constant>MYSQLND_MS_SLAVE_SWITCH</constant> et
   <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>
   au lieu de leurs valeurs littérales, comme
   <literal>/*ms=slave*/</literal>, et ce, dans un souci de portabilité.
  </para>
  <para>
   Le plugin se charge en interne d'ouvrir et fermer des connexions au maitre et aux esclaves.
   Du point de vue de l'application, il n'y a qu'une seule connexion visible. Cependant, en interne,
   cette connexion est représentée par un groupe de connexions réseaux gérées par le plugin.
   Le plugin aiguille les requêtes vers le maitre ou les esclaves en utilisant de multiples
   connexions.
  </para>
  <para>
   Les connexions aux bases de données ont des états, par exemple, le statut des transactions,
   lejeu de caractères, les tables temporaires. Le plugin va tenter de garder les états des
   connexions de manière transparente pour les requêtes qu'il traite, lorsque cela lui est
   possible. Dans les cas contraires, comme par exemple via l'utilisation de
   <literal>BEGIN TRANSACTION</literal>, le plugin laisse l'utilisateur gérer les connexions.
  </para>  
 </section>
 
 <section xml:id="mysqlnd-ms.pooling">
  <title>Groupe de connexions et bascule entre les connexions</title>
  <para>
   Le plugin de réplication et répartition de charge change la sémantique d'une
   connexion MySQL de PHP. Les API existantes des extensions PHP pour MySQL
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link> et
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) sont inchangées, mais leur
   comportement est modifié lorsque le plugin est utilisé. Les applications
   existantes n'ont pas de changement à opérer pour utiliser la nouvelle API,
   mais elles devront peut-être être modifiées en ce qui concerne le comportement
   du plugin.
  </para>
  <para>
   Le plugin casse la relation un-à-un entre une connexion
   <link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link> et
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link> et la connexion réseau à
   MySQL. Lorsque le plugin est utilisé, la connexion de
   <link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link> représente en fait un groupe
   de connexions vers un serveur maitre MySQL et des serveurs esclaves.
   Le plugin aiguille les requêtes vers le serveur maitre ou un des esclaves.
   A un moment donné, une connexion vue depuis PHP peut pointer vers le maitre
   et juste après vers un esclave, ou alors toujours le maitre. La manipulation
   et le remplacement d'une connexion réseau référencée par un gestionnaire
   de connexion PHP MySQL n'est pas une opération transparente.
  </para>
  <para>
   Chaque connexion MySQL possède un état, et les différentes connexions, gérées dans
   un groupe par le plugin, peuvent avoir chacune des états différents. Lorsque le
   plugin bascule d'une connexion à une autre, l'état est susceptible de changer.
   L'application doit prendre cela en compte.
  </para>
  <para>
   La liste suivante indique ce qui est caractérisé par un état de connexion.
   Cette liste peut ne pas être totalement complète.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      Les statuts des transactions
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les tables temporaires
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les verrous des tables
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les variables de session système ou utilisateur
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Le jeu de bases de données courantes, utilisant
      <literal>USE</literal> ainsi que d'autres commandes de statut SQL
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les requêtes préparées
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les variables <literal>HANDLER</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les verrous retournés par <literal>GET_LOCK()</literal>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Le changement de connexions intervient juste avant l'exécution de la requête.
   Le plugin ne change la connexion courante qu'au moment où la prochaine
   requête est exécutée.
  </para>
  <note>
   <title>Problèmes liés à la réplication</title>
   <para>
    Voyez aussi le manuel de référence de MySQL concernant 
    <link xlink:href="&url.mysql.docs.replication;">la réplication</link> et
    ses problématiques. Certaines restrictions ne sont pas dûes au plugin PHP mais
    sont des caractéristiques du mécanisme de réplication de MySQL.
   </para>
  </note>
  <para>Messages diffusés</para>
  <para>
   La philosophie du plugin est d'aligner le statut des connexions dans la file
   d'attente uniquement si le statut est sous le contrôle total du plugin,
   ou si c'est nécessaire d'un point de vue de la sécurité. Seulement quelques
   actions modifiants le statut de la connexion rentrent dans cette catégorie.
  </para>
  <para>
   Voici la liste des appels diffusés de la bibliothèques clientes qui modifient
   le statut de toutes les connexions contenus dans la file d'attente.
  </para>
  <para>
   Si un des appels listés ci-dessous est exécuté, le plugin
   parcourt toutes les connexions actuellement ouvertes vers
   le maître et les esclaves. Le parcourt continue tant que tous
   les serveurs n'ont pas été contactés. Le parcourt ne s'interrompt
   pas lorsqu'un des serveurs indique une erreur. Si possible, l'erreur
   sera propagée pour appeler la fonction de l'API utilisateur. Suivant
   cette fonction, qui a été lancée par la fonction de la bibliothèque
   sous-jacente, l'utilisateur peut être capable de détecter l'erreur.
  </para>
  <informaltable>
   <tgroup cols="3">
    <colspec colwidth="1*"/>
    <colspec colwidth="7*"/>
    <colspec colwidth="2*"/>
    <thead>
     <row>
      <entry>Appel de la bibliothèque</entry>
      <entry>Notes</entry>
      <entry>Version</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <literal>change_user()</literal>
      </entry>
      <entry>
       Appelé par l'appel de l'API utilisateur <function>mysqli_change_user</function>.
       Également émise lors de la réutilisation d'une connexion
       <literal>mysqli</literal> persistante.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>select_db</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysql_select_db</function>,
       <function>mysql_list_tables</function>,
       <function>mysql_db_query</function>,
       <function>mysql_list_fields</function>,
       <function>mysqli_select_db</function>.
       Notez que <literal>USE</literal> n'est pas surveillé.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_charset()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysql_set_charset</function>.
       <function>mysqli_set_charset</function>.
       Notez que <literal>SET NAMES</literal> n'est pas surveillé.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_server_option()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_multi_query</function>,
       <function>mysqli_real_query</function>,
       <function>mysqli_query</function>,
       <function>mysql_query</function>.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_client_option()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_options</function>,
       <function>mysqli_ssl_set</function>,
       <function>mysqli_connect</function>,
       <function>mysql_connect</function>,
       <function>mysql_pconnect</function>.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_autocommit()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_autocommit</function>,
       <literal>PDO::setAttribute(PDO::ATTR_AUTOCOMMIT)</literal>.
      </entry>
      <entry>Depuis la version 1.0.0. PHP &gt;= 5.4.0.</entry>
     </row>
     <row>
      <entry>
       <literal>ssl_set()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_ssl_set</function>.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  <para>Les connexions diffusées et paresseuses</para>
  <para>
   Le plugin n'utilise pas de proxy ou bien ne se "souvient" pas de
   toutes les configurations à appliquer aux futures connexions.
   Il est important de se rappeler de cela lors de l'utilisation des
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.lazy-connections">connexions paresseuses</link>.
   Les connexions paresseuses sont des connexions qui ne sont pas ouvertes
   tant que le client n'envoie pas la première connexion.
   Le plugin utilise par défaut de telles connexions.
  </para>
  <para>
   Les appels de la bibliothèque modifiant la configuration et le statut des connexions
   ci-après sont enregistrés pour être utilisés lors de l'ouverture
   d'une connexion paresseuse afin de s'assurer que le statut de cette connexion
   est comparable avec le statut de toutes les connexions de la file d'attente.
  </para>
  <informaltable>
   <tgroup cols="3">
    <colspec colwidth="1*"/>
    <colspec colwidth="7*"/>
    <colspec colwidth="2*"/>
    <thead>
     <row>
      <entry>Appel de la bibliothèque</entry>
      <entry>Notes</entry>
      <entry>Version</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <literal>change_user()</literal>
      </entry>
      <entry>
       Utilisateur, mot de passe et base de données sont enregistrés
       pour une utilisation ultérieure.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
     <row>
      <entry>
       <literal>select_db</literal>
      </entry>
      <entry>
       Base de données enregistré pour utilisation ultérieure.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_charset()</literal>
      </entry>
      <entry>
       Appel <literal>set_client_option(MYSQL_SET_CHARSET_NAME, charset)</literal>
       sur les connexions paresseuses pour s'assurer que
       <literal>charset</literal> sera utilisé lors de l'ouverture d'une connexion
       paresseuse.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_autocommit()</literal>
      </entry>
      <entry>
       Ajoute <literal>SET AUTOCOMMIT=0|1</literal> à la liste des commandes
       d'initialisation pour une connexion paresseuse utilisant
       <literal>set_client_option(MYSQL_INIT_COMMAND, &quot;SET AUTOCOMMIT=...%quot;)</literal>.
      </entry>
      <entry>Depuis la version 1.1.0. PHP &gt;= 5.4.0.</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  
  <caution>
   <title>Statut de connexion</title>
   <para>
    Notez que le statut de la connexion n'est pas changé que par des appels
    API. Aussi, même si PECL mysqlnd_ms surveille tous les appels API, l'application
    a toujours besoin de maintenir le statut de la connexion, si besoin.
   </para>
  </caution>
  
  <para>Jeux de caractères et échappement des chaînes</para>
  <para>
   En raison de l'utilisation des connexions paresseuses, qui sont actives
   par défaut, il peut survenir qu'une application tente d'échapper une chaîne
   pour une utilisation dans une requête SQL avant qu'une connexion ne soit
   établie. Dans ce cas, l'échappement de la chaîne n'est pas possible.
   La fonction d'échappement de chaînes ne connait pas le jeu de caractères
   à utiliser avant qu'une connexion ne soit établie.
  </para>
  <para>
   Pour éviter ce problème, une nouvelle option de configuration
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.server-charset"><literal>server_charset</literal></link>
   a été introduite en version 1.4.0.
  </para>
  <para>
   Une attention particulière doit être portée lors de l'échappement de chaînes
   avec un certain jeu de caractères, mais utilisant le résultat sur une connexion
   qui utilise un jeu de caractères différent. Notez que PECL/mysqlnd_ms
   manipule les connexions et qu'une connexion au niveau applicatif représente une
   file de plusieurs connexions qui peuvent avoir différents jeux de caractères
   par défaut. Il est recommandé de configurer le serveur pour utiliser le même
   jeu de caractères par défaut. L'option de configuration <literal>server_charset</literal>
   va être utile dans cette situation. Si vous utilisez l'option
   <literal>server_charset</literal>, le plugin va définir le jeu de caractères
   fourni sur toutes les nouvelles connexions ouvertes.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.transaction">
  <title>Gestion des transactions locales</title>
  <para>
   La gestion des transactions est impactée en profondeur. Une transaction est une unité logique
   lancée par le serveur. Cette unité peut se composer d'une ou plusieurs requêtes.
  </para>
  <para>
   Par défaut, le plugin ne se soucie pas des transactions SQL. Il est donc possible qu'il
   décide de basculer de connexions dans le cadre de la répartition de charge, et ceci peut
   arriver au milieu d'une transaction. C'est contre la nature même d'une transaction SQL, le
   plugin n'est donc, par défaut, pas au courant des transactions.
  </para>
  <para>
   Toute type de balance de charge MySQL peut être touché entre le début et la fin
   d'une transaction. Ce peut être de façon explicitie en monitorant les appels API
   ou en utilisant des astuces SQL. L'API de monitorage nécessite PHP 5.4.0 ou supérieur.
   Le plugin, tout comme n'importe quel répartiteur de charge MySQL, ne peut pas
   détecter les limites d'une transaction en se basant sur le protocole client serveur
   de MySQL. Aussi, une transparence totale d'une transaction avec un répartiteur
   de charge n'est pas possible. L'option la moins intrusive est l'API de monitorage,
   qui nécessite très peu de modifications de l'application.
  </para>
  <para>
   Vous trouverez des exemples d'utilisation d'astuces SQL ou de l'API de
   monitorage dans la <link linkend="mysqlnd-ms.quickstart">section des exemples</link>.
   Les détails de l'API de monitorage, qui rend les transactions au niveau du plugin
   sûres, sont décrits ci-dessous.
  </para>
  <para>
   Depuis PHP 5.4.0, la bibliothèque <link linkend="book.mysqlnd">mysqlnd</link>
   autorise ce plugin à surcharger l'appel API C <literal>set_autocommit()</literal>,
   afin de détecter le statut du mode <literal>autocommit</literal>.
  </para>
  <para>
   Les extensions PHP pour MySQL effectuent une requête (comme <literal>SET AUTOCOMMIT=0|1</literal>),
   ou utilisent l'appel mysqlnd <literal>set_autocommit()</literal> pour contrôler le statut de
   l'<literal>autocommit</literal>. Si une extension utilise
   <literal>set_autocommit()</literal>, le plugin sera au courant des transactions, ce
   n'est pas le cas si du SQL est utilisé.
   L'appel <literal>set_autocommit()</literal> est utilisé par
   <function>mysqli_autocommit</function> et
   <literal>PDO::setAttribute(PDO::ATTR_AUTOCOMMIT)</literal>.
  </para>
  <para>
   L'option de configuration du plugin <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness=master</link>
   peut être utilisée pour rendre le plugin sensible aux transactions.
   Grâce à ça, le plugin arrête la répartition de charge si l'autocommit est désactivé,
   et la réactive dans le cas contraire.
  </para>
  <para>
   Une application qui ne veut pas utiliser les astuces SQL pour les transactions
   mais souhaite utiliser l'API de monitorage pour éviter les modifications applicatifs
   doit s'assurer que la configuration autocommit est bien modifiée que via les appels
   API listés.
  </para>
  <para>
   La détection des limites d'une transaction en se basant que l'API a été
   améliorée avec PHP 5.5.0 et PECL/mysqlnd_ms 1.5.0 pour couvrir non seulement
   les appels à <function>mysqli_autocommit</function> mais aussi à
   <function>mysqli_begin</function>, <function>mysqli_commit</function> et
   <function>mysqli_rollback</function>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.errorhandling">
  <title>Gestion des erreurs</title>
  <para>
   Les applications utilisant PECL/mysqlnd_ms doivent gérer proprement
   les erreurs pouvant survenir de tous les appels API utilisateur.
   En raison du fait que le plugin modifie la sémantique d'un gestionnaire
   de connexion, les appels API peuvent retourner des erreurs inattendues.
   Si vous utilisez le plugin, un gestionnaire de connexion ne représente
   plus une connexion réseau individuelle mais un groupe de connexions.
   Un code erreur et un message d'erreur peuvent être définis sur le gestionnaire
   de connexion, que l'erreur survienne sur n'importe quelle connexion
   réseau du groupe.
  </para>
  <para>
   Si vous utilisez les connexions paresseuses, (ce qui est le comportement
   par défaut), les connexions ne sont pas ouvertes tant qu'elle n'est pas
   nécessaire pour l'exécution d'une requête. Toutefois, il peut survenir
   qu'un appel API pour l'exécution d'une requête retourne une erreur
   de connexion. Dans l'exemple suivant, une erreur est provoquée lorsque
   l'on tente d'exécuter une requête sur un esclave. L'ouverture de la
   connexion esclave échoue car le fichier de configuration du plugin
   liste un nom d'hôte invalide pour l'esclave.
  </para>
  <para>
   <example>
    <title>On provoque une erreur de connexion</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "invalid_host_name",
            }
        },
        "lazy_connections": 1
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   L'activation explicite des connexions paresseuses est effectuée ici
   que dans un but de démonstration.
  </para>
  <para>
   <example>
    <title>Erreur de connexion sur l'exécution d'une requête</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Bien sûr, votre gestion des erreurs est bien meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connexion 1, la connexion lie la variable SQL ; ce n'est pas un SELECT, la requête sera donc exécuté sur le maître */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connexion 2, exécution sur l'esclave car SELECT provoque une erreur de connexion */
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
PHP Warning:  mysqli::query(): php_network_getaddresses: getaddrinfo failed: Name or service not known in %s on line %d
PHP Warning:  mysqli::query(): [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known (trying to connect via tcp://invalid_host_name:3306) in %s on line %d
[2002] php_network_getaddresses: getaddrinfo failed: Name or service not known
]]>
    </screen>
   </example>
  </para>
  <para>
   Les applications doivent être capables de gérer les erreurs de connexions.
   au moyen d'un gestionnaire d'erreurs correct.
  </para>
  <para>
   Suivant le cas rencontré, les applications peuvent vouloir gérer les erreurs
   de connexions différemment des autres erreurs. Typiquement, les erreurs
   de connexions sont
   <literal>2002 (CR_CONNECTION_ERROR) - Can't connect to local MySQL server through socket '%s' (%d)</literal>,
   <literal>2003 (CR_CONN_HOST_ERROR) - Can't connect to MySQL server on '%s' (%d)</literal> et
   <literal>2005 (CR_UNKNOWN_HOST) - Unknown MySQL server host '%s' (%d)</literal>.
   Par exemple, l'application doit tester les codes erreurs et manuellement exécuter
   une fonction appropriée. La philosophie du plugin n'est pas d'offrir
   de fonction adéquate lors d'un échec du maître, car ces échecs ne sont
   pas des opérations transparentes.
  </para>
  <para>
   <example>
    <title>On provoque une erreur de connexion</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "invalid_host_name"
            },
            "slave_1": {
                "host": "192.168.78.136"
            }
        },
        "lazy_connections": 1,
        "filters": {
            "roundrobin": [

            ]
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   L'activation explicite des connexions paresseuses est effectuée ici
   uniquement dans un but démonstratif. Notez que la balance de charge
   round robin est utilisée en lieu et place de la méthode par défaut
   <literal>random once</literal>
  </para>
  <para>
   <example>
    <title>Échec les plus courants</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Évidemment, votre gestionnaire d'erreur est bien meilleur... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connexion 1, la connexion lie la variable SQL user ; pas de SELECT, la requête peut se faire sur le maître */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connexion 2, d'abord, sur l'esclave */
$res = $mysqli->query("SELECT VERSION() AS _version");
/* Échec manuel */
if (2002 == $mysqli->errno || 2003 == $mysqli->errno || 2004 == $mysqli->errno) {
  /* Connexion 3, la première connexion à l'esclave échoue, tentative du prochain esclave */
  $res = $mysqli->query("SELECT VERSION() AS _version");
}

if (!$res) {
  printf("ERROR, [%d] '%s'\n", $mysqli->errno, $mysqli->error);
} else {
 /* Les messages d'erreur sont récupérés de la connexion 3, et donc, aucune erreur */
 printf("SUCCESS, [%d] '%s'\n", $mysqli->errno, $mysqli->error);
 $row = $res->fetch_assoc();
 $res->close();
 printf("version = %s\n", $row['_version']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
[1045] Access denied for user 'username'@'localhost' (using password: YES)
PHP Warning:  mysqli::query(): php_network_getaddresses: getaddrinfo failed: Name or service not known in %s on line %d
PHP Warning:  mysqli::query(): [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known (trying to connect via tcp://invalid_host_name:3306) in %s on line %d
SUCCESS, [0] ''
version = 5.6.2-m5-log
]]>
    </screen>
   </example>
  </para>
  <para>
   Dans quelques cas, il n'est pas possible facilement de récupérer toutes
   les erreurs qui surviennent sur toutes les connexions réseaux via le gestionnaire
   de connexions. Supposons qu'un groupe de connexions contient 3 connexions ; une
   vers le maître et deux autres vers des esclaves. L'application modifie la base
   de données courante en utilisant l'appel API <function>mysqli_select_db</function>,
   qui appelle la fonction de la bibliothèque mysqlnd pour modifier le schéma.
   mysqlnd_ms surveille la fonction et tente de changer la base de données
   courante sur toutes les connexions afin d'harmoniser leurs statuts.
   Supposons que le maître arrive à changer la base de données, mais que les
   esclaves échouent. Lors de la première erreur depuis le premier esclave,
   le plugin définira une erreur appropriée sur le gestionnaire de connexions.
   La même chose est effectuée lorsque le second esclave échoue. Le message
   d'erreur depuis le premier esclave est alors perdu.
  </para>
  <para>
   Un tel cas peut être débogué soit en vérifiant les erreurs de type
   <literal>E_WARNING</literal> (voir ci-dessus), ou soit, s'il n'y a
   pas d'autres options, en investiguant les
   <link linkend="mysqlnd-ms.debugging">traces et l'historique de déboguage mysqlnd_ms</link>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.transient_errors">
  <title>Les erreurs passagères</title>
  <para>
   Quelques clusters de bases de données utilisent les erreurs passagères.
   Une erreur passagère est une erreur temporaire qui normalement doit
   disparaître rapidement. Par définition, il est sécurisé pour un client
   d'ignorer une erreur passagère et de re-tenter l'opération en échec
   sur le même serveur de base de données. La nouvelle tentative n'a
   aucun effet secondaire. Les clients ne sont pas obligés de stopper
   leurs travaux ou de basculer sur un autre serveur de base de données
   immédiatement. Ils doivent plutôt entrer dans une boucle de tentatives
   pour attendre que l'erreur disparaisse avant d'abandonner le serveur de
   base de données au profit d'un autre. Les erreurs passagères peuvent
   être observées, par exemple, lors de l'utilisation d'un cluster MySQL.
   Mais elles ne sont pas liées à une solution de clusters spécifique.
  </para>
  <para>
   <literal>PECL/mysqlnd_ms</literal> peut lancer une boucle de tentatives
   automatiquement dans le cas d'erreurs passagères. Ce mécanisme permet de rendre
   encore plus transparent la distribution, et ainsi, rend simple la migration
   d'une application fonctionnant sur un seul serveur de base de données sur
   un cluster de serveurs de bases de données sans avoir à changer le source
   de l'application.
  </para>
  <para>
   La boucle de tentatives automatique va répéter l'opération demandée
   autant de fois que le nombre configuré, et effectuera une pause entre
   les tentatives pendant une durée configurée. Si l'erreur disparaît pendant
   la boucle, l'application ne la verra jamais. Sinon, l'erreur sera envoyée
   à l'application afin qu'elle la gère.
  </para>
  <para>
   Dans l'exemple ci-dessous, une erreur concernant une clé dupliquée
   est provoquée pour que le plugin entre dans un cycle de deux nouvelles
   tentatives avant de passer l'erreur à l'application. Entre les deux
   tentatives, le plugin va attendre 100 millisecondes.
  </para>
  <para>
   <example>
    <title>Provoque une erreur passagère</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.collect_statistics=1
]]>
    </programlisting>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
       },
       "transient_error": {
          "mysql_error_codes": [
            1062
          ],
          "max_retries": 2,
          "usleep_retry": 100
       }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Boucle de tentative pour une erreur passagère</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Bien évidemment, votre gestionnaire d'erreurs est bien meilleur... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT PRIMARY KEY)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1))")) {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* La boucle de tentatives est totalement transparente.
   La vérification des statistiques est la seule façon de
   voir les tentatives implicites */
$stats = mysqlnd_ms_get_stats();
printf("Tentatives sur l'erreur passagère avant de lancer l'erreur : %d\n", $stats['transient_error_retries']);

/* Provoque une erreur concernant une clé dupliquée pour voir les statistiques changer */
if (!$mysqli->query("INSERT INTO test(id) VALUES (1))")) {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

$stats = mysqlnd_ms_get_stats();
printf("Tentatives sur l'erreur passagère après le lancement de l'erreur : %d\n", $stats['transient_error_retries']);

$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Tentatives sur l'erreur passagère avant de lancer l'erreur : 0
[1062] Duplicate entry '1' for key 'PRIMARY'
Tentatives sur l'erreur passagère après le lancement de l'erreur : 2
]]>
    </screen>
   </example>
  </para>
  <para>
   En raison du fait de l'exécution transparente d'un point de vue utilisateur
   de la boucle de tentatives, l'exemple vérifie les
   <link linkend="function.mysqlnd-ms-get-stats">statistiques</link> fournies par
   le plugin pour en savoir plus.
  </para>
  <para>
   Comme l'exemple le montre, le plugin peut considérer toutes les erreurs
   comme passagères au regard de la sémantique des erreurs des serveurs
   de base de données. La seule erreur que le serveur MySQL considère comme
   temporaire est l'erreur code <constant>1297</constant>. Lorsque vous configurez
   d'autres codes erreurs autre que la <constant>1297</constant>, assurez-vous
   que votre configuration reflète la sémantique des codes erreurs de votre cluster.
  </para>
  <para>
   Les appels mysqlnd C API suivants sont surveillés par le plugin pour vérifier
   les erreurs passagères : <literal>query()</literal>,
   <literal>change_user()</literal>, <literal>select_db()</literal>,
   <literal>set_charset()</literal>, <literal>set_server_option()</literal>
   <literal>prepare()</literal>, <literal>execute()</literal>,
   <literal>set_autocommit()</literal>,
   <literal>tx_begin()</literal>, <literal>tx_commit()</literal>,
   <literal>tx_rollback()</literal>, <literal>tx_commit_or_rollback()</literal>.
   Les appels API utilisateur ont des noms similaires.
  </para>
  <para>
   La durée d'attente du plugin entre plusieurs tentatives dans la boucle
   dépend de la fonction en question. Dans une boucle de tentative pour
   <literal>query()</literal>, <literal>prepare()</literal> ou <literal>execute()</literal>,
   la durée d'attente sera <literal>max_retries * usleep_retry</literal> millisecondes.
  </para>
  <para>
   Cependant, les fonctions qui
   <link linkend="mysqlnd-ms.pooling">contrôle le statut de la connexion</link>
   sont dispatchées pour toutes les connexions. La configuration de la boucle
   de tentative est appliquée à chaque connexion sur laquelle la commande est exécutée.
   Aussi, une fonction peut interrompre l'exécution du programme plus longtemps qu'une
   fonction qui est exécutée sur un seul serveur. Par exemple, <literal>set_autocommit()</literal>
   est dispatché sur l'ensemble des connexions, et peut attendre
   <literal>(max_retries * usleep_retry) * nombre_de_connexions_ouvertes)</literal>
   millisecondes. Veuillez garder cela à l'esprit lorsque vous définissez une durée
   élevée ainsi qu'un grand nombre de tentatives. L'utilisation de la configuration
   par défaut (<literal>max_retries=1</literal>, <literal>usleep_retry=100</literal> et
   <literal>lazy_connections=1</literal>) est vivement conseillé, car vous n'aurez jamais
   de délai supérieur à 1 seconde.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.failover">
  <title>Gestion des incidents (Failover)</title>
  <para>
   Par défaut, la gestion des incidents de connexion est laissée à l'utilisateur. L'application
   est responsable de la vérification des valeurs de retour des fonctions concernant
   les bases de données, et doit réagir en cas de detection d'erreur. Par exemple, si le
   plugin reconnait une requête de type lecture-seule  et l'aiguille vers un serveur esclave
   dont la connexion n'est pas disponible, il renverra une erreur.
  </para>
  <para>
   <emphasis role="bold">Défaut : failover manuel</emphasis>
  </para>
  <para>
   C'est à l'application de gérer l'erreur, et, si besoin, de re-présenter la requête
   afin qu'elle soit re-prise en charge par le plugin et aiguillée vers un autre serveur.
   Le plugin ne se charge pas de ça lui-même, car il pourrait risquer d'impacter l'état des
   connexions, ce qui n'est pas du tout désirable. Par exemple, l'application peut avoir
   envoyé une requête comportant des variables de session MySQL, celles-ci sont
   dépendantes de la connexion utilisée. Une telle requête ne pourrait donc être
   prise en charge par un mécanisme automatique implémenté dans le plugin.
   L'application doit donc gérer ces cas-là, et aucune gestion des incidents de connexion
   n'est implémentée à l'intérieur du plugin.
  </para>
  <para>
   Un utilisateur ne changeant pas le statut d'une connexion après l'avoir ouverte peut activer
   la gestion des incidents. Notez que la logique de failover automatique n'est pas
   utilisée pour les connexions déjà ouvertes. Il n'y a aucune façon pour indiquer
   au plugin de tenter un failover sur une connexion qui a été déjà connectée
   à MySQL dans le passé.
  </para>
  <para>
   <emphasis role="bold">Failover automatique</emphasis>
  </para>
  <para>
   Cette gestion des incidents se configure dans le fichier de configuration du plugin au moyen
   de la directive
   <literal><link linkend="ini.mysqlnd-ms-plugin-config-v2.failover">failover</link></literal>.
  </para>
  <para>
   Le failover automatique et silencieux peut être activé via la directive
   de configuration <link linkend="ini.mysqlnd-ms-plugin-config-v2.failover">failover</link>.
   Le failover automatique peut être configuré soit pour essayer exactement un maître
   après l'échec d'un esclave ou bien, pour parcourir tous les esclaves et tous les
   maîtres avant de retourner une erreur à l'utilisateur. Le nombre de tentative de
   connexion peut être limité et les hôtes en échec peuvent être exclus des
   futurs tentatives de balance de charge. Liimiter le nombre de tentatives
   et le fait de retenir les hôtes en échec sont considérés comme des fonctionnalités
   expérimentales malgré le fait qu'elles sont relativement stables.
   Leur syntaxe et leur signification peuvent être modifiées dans les futures
   versions.
  </para>
  <para>
   Notez que depuis la version 1.5.0, le failover automatique est désactivé
   pour la durée d'une transaction si les transactions gluantes sont actives,
   et que les limites de transaction ont été détectées. Le plugin ne va pas
   changer de connexions durant une transaction. De même, il ne va pas faire
   de failover automatique et silencieux. A la place, une erreur sera émise.
   Il est alors du ressort de l'utilisateur de gérer l'échec de la transaction.
   Veuillez vous raporter à la documentation de
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness"><literal>trx_stickiness</literal></link>
   sur la façon de réaliser ceci.
  </para>
  <para>
   Un exemple d'échec manuel est fourni dans la section sur les
   <link linkend="mysqlnd-ms.errorhandling">gestionnaires d'erreurs</link>.
  </para>
  <para>
   <emphasis role="bold">Serveurs de secours</emphasis>
  </para>
  <para>
   En utilisant la <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-random">balance
   de charge pondérée</link>, introduite en PECL/mysqlnd 1.4.0, il est possible de configurer
   des serveurs de secours qui sont peu utilisés lors d'opérations normales.
   Un server de secours qui est utilisé comme cible en failover peut se voir
   assigner une priorité/un poids faible par rapport aux autres serveurs.
   Tant que tous les serveurs sont prêts et fonctionnels, la mageur partie
   de la charge est assignée aux serveurs qui ont un poids élevé. Une petite
   partie des requêtes sera redirigée vers le système de secours qui possède
   un poids faible.
  </para>
  <para>
   Lors d'un échec d'un serveur possédant une priorité élevée, vous pouvez toujours
   basculer vers le secours, qui s'est vu attribué une priorité de balance de charge
   faible en y assignant un poids faible. Le failover peut être manuel ou automatique.
   S'il est automatique, vous pouvez vouloir le combiner avec l'option
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.failover"><literal>remember_failed</literal></link>.
  </para>
  <para>
   A ce moment là, il n'est pas possible d'indiquer à la balance de charge
   de ne rediriger aucune requête au secours. Ceci ne peut être considéré
   comme une limitation sachant que le poids le plus élevé pouvant être assigné
   à un serveur est 65535. Si l'on prend deux esclaves, dont un va servir de secours
   avec un poids de 1, le secours devra gérer moins de un pourcent de la
   charge totale.
  </para>
  <para>
   <emphasis role="bold">Failover et copie primaire</emphasis>
  </para>
  <para>
   Veuillez noter que si vous utilisez une copie de cluster primaire,
   comme une réplication MySQL, il est difficile de faire un failover de connexion
   dans le cas où la connexion au maître échoue. A tout moment, il n'y a
   qu'un seul maître dans le cluster pour un jeu de données.
   Le maître représent un seul point. Si il échoue, les clients n'ont plus
   de cible à utiliser pour effectuer les requêtes en écriture. Dans le cas où
   le maître tombe en panne, l'administrateur de base de données doit prendre
   en compte la situation et mettre à jour les configurations
   des clients.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.loadbalancing">
  <title>Répartition de charge</title>
  <para>
   Il existe quatre stratégies pour distribuer les requêtes
   sur les esclaves configurés :
  </para>
  <para>
   <variablelist>
    <varlistentry>
     <term>random</term>
     <listitem>
      <para>
       Choix effectué au hasard, à chaque requête.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>random once (défaut)</term>
     <listitem>
      <para>
       Choix effectué au hasard à la première requête, puis garde
       ce serveur pour les requêtes suivantes.
      </para>
      <para>
       C'est le choix par défaut et le moins impactant concernant l'état
       des connexions.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>round robin</term>
     <listitem>
      <para>
       Itère sur la liste des serveurs déclarés.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Utilisateur : via une callback</term>
     <listitem>
      <para>
       Utilisé pour implémenté une stratégie personnalisée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   L'équilibrage de charge est configuré via les fichiers de configuration
   au moyen des valeurs
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-random">random</link>,
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-roundrobin">roundrobin</link>,
   and <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-user">user</link>
   <link linkend="mysqlnd-ms.filter">filters</link>.
  </para>
  <para>
   Les serveurs peuvent être priorisés en leur assignant un poids.
   Un serveur dont le poids est de 2 recevra deux fois plus de requêtes
   qu'un serveur dont le poids est de 1 (poids par défaut). La priorisation
   peut être utile en environnement hétérogène. Par exemple, vous pouvez
   vouloir assigner plus de requêtes à une machine puissante plutôt
   qu'à une autre qui l'est moins. Ou bien, vous pouvez configurer
   différemment des serveurs qui sont plus ou moins éloignés du client,
   réduisant ainsi les latences.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.rwsplit">
  <title>Séparation des lectures et écritures</title>
  <para>
   Le plugin envoie les requêtes de type lecture seule sur un des esclaves de réplication
   configurés, et les autres requêtes sur le maitre. Les requêtes sont considérées de type
   lecture seule si elles commencent par <literal>SELECT</literal>, si elles comportent
   l'astuce SQL <literal>/*ms=slave*/</literal> ou si un esclave a été choisi lors de la
   dernière requête et que l'astuce SQL <literal>/*ms=last_used*/</literal> est employée.
   Dans tous les autres cas, la requête sera aiguillée vers le serveur maitre. Il est
   recommandé d'utiliser les constantes <constant>MYSQLND_MS_SLAVE_SWITCH</constant>,
   <constant>MYSQLND_MS_MASTER_SWITCH</constant> et <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>
   au lieu de <literal>/*ms=slave*/</literal>. Reportez-vous à
   <link linkend="mysqlnd-ms.constants">la liste des constantes mysqlnd_ms</link>.
  </para>  
  <para>
   Les astuces SQL représentent des commentaires SQL spéciaux. Le plugin vérifie toutes les
   requêtes à la recherche de telles astuces. Les astuces SQL sont décrites dans les
   <link linkend="mysqlnd-ms.constants">constantes mysqlnd_ms</link> exportées par l'extension. Les
   autres organes éventuellement présents dans le mécanisme de réplication (serveur MySQL,
   firewalls SQL ou proxies SQL) ne sont pas affectés par les astuces SQL car ils sont sensés
   ignorer les commentaires SQL.
  </para>
  <para>
   L'implémentation interne du séparateur de requêtes lecture/écriture peut être remplacée
   par un filtre utilisateur, voyez le filtre
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-user"><literal>user</literal></link>.
  </para>
  <para>
   Une implémentation personnalisée du séparateur de requêtes lecture/écriture peut demander
   au plugin où envoyer la requête, en appelant <function>mysqlnd_ms_is_select</function>.
  </para>
  <note>
   <para>
    Le séparateur de requêtes lecture/écriture interne ne gère pas les requêtes multiples qui
    sont vues comme une seule requête. Le séparateur va vérifier le début de la requête pour savoir
    vers quel serveur l'envoyer. Si, par exemple, une requête multiple commence par
    <literal>SELECT 1 FROM DUAL; INSERT INTO test(id) VALUES (1); ...</literal>
    le plugin l'enverra vers un esclave, alors que cette requête n'est pas de type lecture seule.
   </para>
  </note> 
 </section>
 
 <section xml:id="mysqlnd-ms.filter">
  <title>Les filtres</title>
  <note>
   <title>Version requise</title>
   <para>
    Les filtres existent depuis mysqlnd_ms version 1.1.0-beta.
   </para>
  </note>
  <para>
   <link linkend="mysqlnd-ms.plugin-ini-json">Filtres</link>.
   Toutes les applications PHP utilisant un type de cluster de réplication MySQL
   ont besoin d'abord d'identifier un groupe de serveurs dans le cluster qui pourront
   exécuter une requête donnée avant que la requête ne soit exécutée sur un
   des candidats. En d'autres termes, une liste donnée de serveurs doit être filtrée
   pour n'en faire sortir qu'un.
  </para>
  <para>
   Le processus de filtrage peut inclure l'utilisation d'un ou plusieurs filtres.
   Les filtres peuvent être chaînés. Ils sont exécutés dans l'ordre de leurs
   apparitions dans le fichier de configuration du plugin.
  </para>
  <note>
   <title>Comparaison du chainage des filtres avec les tubes (pipes)</title>
   <para>
    Le concept de chaînage des filtres peut être comparé à l'utilisation des tubes des utilitaires de ligne
    de commande d'un shell d'un système d'exploitation : un flux entrant est passé
    au processus, et transféré à la sortie. Puis, la sortie est passé comme
    entrée à la prochaine commande qui est connectée à la précédente en utilisant
    un opérateur pipe.
   </para>
  </note>
  <para>
   Les filtres suivants sont disponibles
   <itemizedlist>
    <listitem>
     <simpara>
      Filtre de balance de charge :
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">random</link>,
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">roundrobin</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre de sélection :
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">user</link>,
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">user_multi</link>,
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">quality_of_service</link>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  
  <para>
   Le filtre <literal>random</literal> implémente les
   stratégies random et random once. Round robin peut être configuré via le
   filtre <literal>roundrobin</literal>. La définition d'une fonction de rappel utilisateur
   peut être utilisée pour la sélection des serveurs avec le filtre
   <literal>user</literal>.Le filtre <literal>quality_of_service</literal> trouve des noeuds
   capables de répondre à un certain service, par exemple, "lit tes écritures" ou encore
   ne pas avoir plus de X secondes de retard sur le maitre.
  </para>
  <para>
   Les filtres peuvent accepter des paramètres pour changer leurs comportements.
   Le filtre <literal>random</literal> accepte un paramètre optionnel
   <literal>sticky</literal>. Si définit à &true;, le filtre modifie la balance
   de charge de random à random once. Random sélectionne un serveur aléatoirement
   à chaque fois qu'une requête est exécutée. Random once sélectionne un serveur
   aléatoirement lors de la première requête et le ré-utilise pour toutes les
   autres requêtes PHP.
  </para>
  <para>
   Une des plus grosses particularités des filtres est la possibilité de
   les chaîner. La puissance de ce concept n'est pas immédiatement
   visible car les filtres <literal>random</literal>, <literal>roundrobin</literal>
   et <literal>user</literal> ne sont supposés sortir pas plus d'un serveur. Si un
   filtre réduit la liste des candidats pour l'exécution d'une requête
   sur un seul serveur, il prend un sens limité en utilisant un serveur
   comme sortie pour les autres filtres pour une réduction future
   de la liste des candidats.
  </para>
  <para>
   Un exemple d'une séquence de filtre qui va échouer:
   <itemizedlist>
    <listitem>
     <simpara>
      Requête à exécuter : <literal>SELECT 1 FROM DUAL</literal>.
      Passé à tous les filtres.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Tous les noeuds configurés sont passés comme entrée au premier filtre.
      Nœuds maîtres : <literal>master_0</literal>.
      Nœuds esclaves : <literal>slave_0</literal>, <literal>slave_1</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre : <literal>random</literal>, argument <literal>sticky=1</literal>.
      Sélectionne un esclave aléatoire à utiliser pour le reste des requêtes PHP.
      Sortie : <literal>slave_0</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Sortie de <literal>slave_0</literal> et la requête à exécuter
      est passée comme entrée pour le prochain filtre. Ici : <literal>roundrobin</literal>,
      liste de serveurs passé au filtre est : <literal>slave_0</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre : <literal>roundrobin</literal>. La liste des serveurs consiste
      en un seul serveur, round robin retourne toujours le même serveur.
     </simpara>
    </listitem>
   </itemizedlist>
   Si vous tentez d'utiliser de telles séquences de filtres, le plugin
   peut émettre une alerte comme <literal>(mysqlnd_ms) Error while creating
   filter '%s' . Non-multi filter '%s' already created. Stopping in %s on
   line %d</literal>. Par la suite, une erreur appropriée sur le gestionnaire
   de connexion devrait être définie.
  </para>
  <para>
   Il existe un second type de filtre : le multi filtre. Ce type ressort zéro, un ou plusieurs
    serveurs. Le filtre <literal>quality_of_service</literal> en est un exemple. Si la qualité de
    service est réglée avec une limite de retard des esclaves et que plus d'un esclave est victime
    de retard dans la limite, le filtre retourne alors plus d'un noeud. Un filtre multi doit être
    chainé avec un autre pour réduire la liste.
  </para>
  <para>
   Voici une séquence de filtres avec <literal>quality_of_service</literal> suivi d'un filtre
   d'équilibre de charge.
   <itemizedlist>
    <listitem>
     <simpara>
      Requête à exécuter: <literal>SELECT sum(price) FROM orders WHERE order_id = 1</literal>.
      Passée à tous les filtres.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Tous les noeuds configurés sont passés en entrée du premier filtre.
      Noeuds maitres: <literal>master_0</literal>.
      Noeuds esclaves: <literal>slave_0</literal>, <literal>slave_1</literal>,
      <literal>slave_2</literal>, <literal>slave_3</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre: <literal>quality_of_service</literal>, règle: session_consistency ("lit tes écritures")
      Sortie: <literal>master_0</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Sortie <literal>master_0</literal> et la requête à exécuter est passée en entrée du filtre suivant,
      un filtre <literal>roundrobin</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre: <literal>roundrobin</literal>. La liste des serveurs ne contient qu'un seul serveur.
      Round robin selectionne <literal>master_0</literal>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Une séquence de filtres ne doit pas se terminer sur un filtre multi, sinon le plugin risque
   d'envoyer un avertissement du type <literal>(mysqlnd_ms) Error in configuration. Last filter is multi
   filter. Needs to be non-multi one. Stopping in %s on line %d</literal>.
   Aussi, une erreur sur la connexion risque d'arriver.
  </para>
  <para>
   <note>
    <title>Spéculation sur le futur: Filtres de réplication MySQL</title>
    <para>
     Dans les futures versions, il devrait y avoir plus de filtres multi. Par exemple,
     il devrait exister un filtre <literal>table</literal> pour supporter le filtrage
     de réplication MySQL. Le filtre de réplication MySQL vous autorise de définir
     des règles où la base de données ou la table sera répliquée vers un noeud
     précis d'un cluster de réplication. Supposons que votre cluster de
     réplication consiste en 4 esclaves (<literal>slave_0</literal>, <literal>slave_1</literal>,
     <literal>slave_2</literal>, <literal>slave_3</literal>), 2 d'entre eux répliquent
     une base de données nommée <literal>sales</literal> (<literal>slave_0</literal>,
     <literal>slave_1</literal>). Si l'application requête la base de données
     <literal>slaves</literal>, l'hypothétique filtre <literal>table</literal>
     réduit la liste des serveurs possibles à <literal>slave_0</literal>,
     <literal>slave_1</literal>. En raison du fait que la sortie et que la liste
     des serveurs candidats contient plus d'un serveur, il est nécessaire et possible
     aux futures filtres de filtrer la liste des candidats, par exemple,
     en utilisant le filtre de balance de charge pour identifier un serveur
     pour l'exécution de la requête.
    </para>  
   </note>
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.qos-consistency">
  <title>Niveaux de service et consistence</title>
  <note>
   <title>Version requise</title>
   <para>
    Les niveaux de service ont été ajoutés dans mysqlnd_ms version 1.2.0-alpha.
    <function>mysqlnd_ms_set_qos</function> requiert PHP 5.4.0 ou plus récent.
   </para>
  </note>
  <para>
   Le plugin peut être utilisé avec différents types de clusters MySQL.
   Différents clusters vont délivrer différents niveaux de service à l'application.
   Les niveaux de services peuvent être classés par niveau de concistence des données
   qu'ils proposent. Le plugin reconnait:
   <itemizedlist>
    <listitem>
     <simpara>eventual consistency</simpara>
    </listitem>
    <listitem>
     <simpara>session consistency</simpara>
    </listitem>
    <listitem>
     <simpara>strong consistency</simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   En fonction de la manière dont le cluster est utilisé, il est possible d'avoir des
   niveaux de service plus hauts que celui par défaut. Par exemple, une lecture depuis
   un esclave MySQL asynchrone est éventuellement consistente. Ainsi, on peut dire que
   le niveau de consistence d'un cluster de réplication MySQL est éventuelle, cependant,
   si le maitre est seulement utilisé pour lire et écrire durant une session, on a
   une consistence de session ("lit tes écritures"). PECL mysqlnd 1.2.0 abstrait les détails
   concernant le choix d'un noeud approprié de la couche de service sur-jascente
   de l'utilisateur.
  </para>
  <para>
   Les niveaux de service peuvent être ajoutés via le filtre qualify-of-service dans le
   <link linkend="mysqlnd-ms.plugin-ini-json">fichier de configuration des plugins</link>
   et pendant l'exécution au moyen de la fonction <function>mysqlnd_ms_set_qos</function>.
  </para>
  <para>
   Les différents niveaux de service sont définis comme suit.
  </para>
  <para>
   La consistence éventuelle est le niveau de service par défaut proposé par un cluster
   asynchrone comme la réplication MySQL classique. Une opération de lecture sur un noeud
   peut éventuellement retourner une données à jour, ou pas. La consistence est éventuelle.
  </para>
  <para>
   La consistence de session est proposée lorsque le client peut toujours lire ses écritures.
   Un cluster de réplication MySQL asynchrone peut fournir la consistence de session si les
   clients utilisent toujours le maitre après la première écriture ou n'interrogent jamais
   un esclave qui n'a pas encore répliqué la donnée écrite.
  </para>
  <para>
   Le plugin voit la consistence forte comme le fait que tout client puisse toujours voir
   des données écrites des autres clients. C'est le cas par défaut avec le cluster MySQL
   ou tout autre type de cluster proposant une distribution synchrone des données.
  </para>
  <para>
   <emphasis role="bold">Paramètres des niveaux de service</emphasis>
  </para>
  <para>
   Les consistences éventuelle et de session acceptent des paramètres.
  </para>
  <para>
   La consistence éventuelle est le service proposé par la réplication classique MySQL.
   Par défaut, tous les noeuds peuvent être éligibles à la lecture. Un paramètre optionnel
   <literal>age</literal> peut être utilisé pour filtrer les noeuds qui ont un certain retard
   en secondes sur le maitre. Le plugin utilise <literal>SHOW SLAVE STATUS</literal>
   pour mesurer le retard. Voyez le manuel de référence de MySQL pour plus d'informations sur
   la précision et la fiabilité de la commande <literal>SHOW SLAVE STATUS</literal>.
  </para>
  <para>
   La consistence de session ("lit tes écritures") accepte un paramètre optionnel
   <literal>GTID</literal> permettant d'autoriser la lecture pas seulement sur le maitre, mais
   aussi sur un esclave qui a répliqué la donnée, par son identifiant de transaction.
   Ainsi, dans la réplication asynchrone, les lectures peuvent être équilibrées sur des esclaves
   tout en assurant une consistence au niveau session.
  </para>
  <para>
   Vous devez utiliser pour cela
   <link linkend="mysqlnd-ms.gtid">L'injection d'identifiant de transaction coté client</link>.
  </para>
  <para>
   <emphasis role="bold">Avantages de la nouvelle approche</emphasis>
  </para>
  <para>
   La nouvelle approche dépasse l'utilisation d'astuces SQL et l'option
   <literal>master_on_write</literal> sur certains axes. Si une application qui tourne avec
   une réplication MySQL asynchrone ne peut accepter de données non fraiches sur certaines
   lectures, il est plus simple de laisser le plugin choisir le noeud approprié que de
   préfixer toutes ses requêtes d'astuces SQL pour forcer l'utilisation du maitre. Aussi,
   le plugin peut selectionner des esclaves dans ce cas.
  </para>
  <para>
   L'option <literal>master_on_write</literal> fait en sorte que le plugin choisisse le maitre
   après la première écriture (consistence de session). Dans certains cas, la consistence de
   session pourrait n'être utile que pour certaines lectures, et non toute la session courante.
   De ce fait, <literal>master_on_write</literal> pourrait engendrer plus de lectures sur le
   maitre que nécessaire. Dans de tels cas, il est mieux de vouloir un niveau de consistence plus
   haut que celui par défaut, juste pour certaines lectures le nécessitant. Une fois les lectures
   passées, le niveau de consistence peut retomber à la normale. Changer de niveau de service
   n'est possible qu'avec <function>mysqlnd_ms_set_qos</function>.
  </para>
  <para>
   <emphasis role="bold">Considerations de performance</emphasis>
  </para>
  <para>
   Une réplication MySQL ne peut indiquer aux clients quels esclaves sont capables de délivrer
   tel ou tel niveau de consistence. Ainsi, dans certains cas, les clients doivent requêter
   les esclaves pour connaitre leur statut. PECL mysqlnd_ms exécute de manière transparente
   les requêtes necéssaires, mais cette opération est lourde, elle est exécutée si la
   consistence éventuelle est combinée avec une limite d'âge (retard de l'esclave), ou si
   la consistence de session est combinée avec un identifiant de transaction.
  </para>
  <para>
   Si la concistence éventuelle est combinée avec une limite d'âge, le plugin selectionne
   le noeud pour chaque requête. Si c'est une écriture, tous les maitres sont candidats, les
   esclaves ne sont pas vérifiés. Si c'est une lecture, le plugin exécute
   <literal>SHOW SLAVE STATUS</literal> sur tous les esclaves, les candidats sont ceux qui
   répondent <literal>Slave_IO_Running=Yes</literal>,
   <literal>Slave_SQL_Running=Yes</literal> et qui ont
   <literal>Seconds_Behind_Master</literal> inférieur ou égal à l'âge maximum demandé.
   Dans le cas d'une erreur SQL, le plugin envoie un message d'erreur mais ne considère pas
   la connexion comme mauvaise, l'erreur ne permet pas au plugin d'écarter tel ou tel noeud.
  </para>
  <para>
   Si la consistence de session est combinée à un identifiant de transaction global, le plugin
   exécute la requête SQL avec <literal>fetch_last_gtid</literal> équivalant à la section
   <literal>global_transaction_id_injection</literal> du fichier de configuration du plugin.
  </para>
  <para>
   En version 1.2.0, aucune optimisation supplémentaire n'est effectuée concernant les requêtes
   en arrière plan. Les versions futures pourraient embarquer de telles optimisation, en fonction
   des demandes utilisateur.
  </para>
  <para>
   Si aucun paramètre ou option n'est précisé, aucun SQL n'est nécessaire. Dans ce cas, le plugin
   considère tous les noeuds comme suit.
   <itemizedlist>
    <listitem>
     <simpara>Consistence éventuelle, pas d'option passée: tous les maitres, tous les esclaves</simpara>
    </listitem>
    <listitem>
     <simpara>Consistence de session, pas d'options passée: tous les maitres</simpara>
    </listitem>
    <listitem>
     <simpara>Consistence forte (pas d'option possible): tous les maitres</simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   <emphasis role="bold">Etranglement</emphasis>
  </para>
  <para>
   La qualité d'un filtre de service peut être combinée avec
   <link linkend="mysqlnd-ms.gtid">les identifiants globaux de transaction</link>
   pour limiter les clients. L'étranglement va réduire la charge en écriture
   sur le maître en ralentissant les clients. Si une consistence de
   session est demandée, et que les identifiants globaux de session
   sont utilisés pour vérifier le statut d'un esclave, la vérification
   peut être effectuée de deux façons différentes. Par défaut, un esclave
   est vérifiée et écartée immédiatement s'il ne correspond pas aux critères
   d'une consistence de session. Alternativement, le plugin peut attendre
   pour attrapper un esclave pour le maître qu'une consistence de session
   soit possible. Pour activer l'étranglement, vous devez définir
   l'option de configuration
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.gtid">wait_for_gtid_timeout</link>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.gtid">
  <title>Identifiants de transaction</title>
  <note>
   <title>Version requise</title>
   <para>
    L'injection d'identifiant de transaction coté client existe depuis mysqlnd_ms version 1.2.0-alpha.
    Les identifiants de transaction sont détectés en scrutant les appels API. C'est possible depuis
    PHP 5.4.0. Voyez aussi <link linkend="mysqlnd-ms.transaction">la gestion des transactions</link>.
   </para>
   <para>
    Depuis MySQL 5.6.5-m8, le serveur MySQL fournit des identifiants de transaction globaux.
    Cette nouvelle fonctionnalité est supportée par <literal>PECL/mysqlnd_ms</literal>
    1.3.0-alpha et suivant. Aucune configuration n'est requise si vous choisissez 
    d'utiliser la fonctionnalité interne du serveur.
   </para>
   <para>
    Veuillez noter que toutes les versions de production de MySQL 5.6 ne fournissent
    pas de clients avec suffisamment d'informations pour utiliser les GTIDs pour
    renforcer la consistence de sessions. Dans ce cas, le plugin choisira seulement
    le maître.
   </para>
  </note>
  <para>
   <emphasis role="bold">Idées et émulation côté client</emphasis>
  </para>
  <para>
   <literal>PECL/mysqlnd_ms</literal> peut effectuer de l'injection d'identifiant de transaction coté client, de manière transparente.
   Dans sa forme la plus basique, un identifiant de transaction est un compteur incrémenté à chaque transaction
   exécutée sur le maitre. Le compteur est sauvé dans une table sur le maitre. Les esclaves répliquent cette table.
  </para>
  <para>
   Dans le cas d'un problème sur le maitre, un administrateur peut identifier facilement l'esclave le plus récent
   pour le passer en maitre. L'esclave le plus récent possède l'identifiant de transaction le plus élevé.
  </para>
  <para>
   Les développeurs coté application peuvent demander au plugin l'identifiant de transaction
   (GTID) pour leur dernière opération d'écriture. Il peut alors être passé comme paramètre
   au filtre QoS dans le cadre de la consistence de session ("lit tes écritures"). Le filtre
   s'assure que toutes les lectures sont dirigées vers un hôte (maitre ou esclave) ayant répliqué
   la transaction référencée par le GTID.
  </para>
  <para>
   <emphasis role="bold">Lorsque l'injection a été effectuée</emphasis>
  </para>
  <para>
   Le plugin maintient la table GTID sur le maitre, de manière transparente. En mode autocommit, le
   plugin injecte un <literal>UPDATE</literal> avant d'exécuter les requêtes de l'utilisateur,
   pour chaque utilisation du maitre. EN mode transactionnel manuel, l'injection est effectuée avant
   l'appel à <literal>commit()</literal>. L'option de configuration <literal>report_error</literal>
   de la section GTID permet de contrôler si une transaction échouée doit annuler l'opération ou
   être ignorée silencieusement (cas par défaut).
  </para>
  <para>
   Veuillez noter les versions de PHP requises pour
   <link linkend="mysqlnd-ms.transaction">la surveillance des transactions</link> ainsi que leurs
   limites.
  </para>
  <para>
   <emphasis role="bold">Limites</emphasis>
  </para>
  <para>
   Les problèmes éventuels de l'injection d'identifiant de transaction ont des limites qui
   ne sont pas propres à <literal>PECL/mysqlnd_ms</literal>.
   <itemizedlist>
    <listitem>
     <simpara>
      Les tables d'identifiants de transaction globale doivent être déployées
      sur tous les maîtres et les réplications.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Le GTID peut avoir des trous, seuls les clients PHP utilisant le plugin vont maintenir la table,
      pas les autres clients.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      La détection des transactions n'est basée que sur les appels à l'API.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      La détection des transactions coté client ne prend pas en compte les commits
      implicites. Certaines requêtes de MySQL causent un commit implicite.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   <emphasis role="bold">Utilisation côté serveur de l'identifiant de transaction globale</emphasis>
  </para>
  <para>
   Depuis <literal>PECL/mysqlnd_ms</literal> 1.3.0-alpha, les identifiants de transaction globale
   apportés par MySQL 5.6.5-m8 ou supérieure sont supportés. L'utilisation
   de cette fonctionnalité serveur supprime toutes les limitations vues
   précédemment. Reportez-vous au manuel de référence MySQL pour les limitations
   ainsi que les préconditions concernant l'utilisation des identifiants de transaction
   globale internes.
  </para>
  <para>
   Choisir entre l'utilisation de l'émulation côté client ou la fonctionnalité interne
   du serveur est une question qui n'est pas en relation directe avec le plugin, aussi,
   la discussion restera superficielle. Il n'est pas actuellement prévu de supprimer
   l'émulation côté client et vous pouvez continuer de l'utiliser, si la solution
   interne du serveur n'est pas une option pour vous. Ce peut être le cas en
   environnement hétérogène comprenant de vieux serveurs MySQL ou, si une des limitations
   des solutions côté serveur n'est pas acceptable.
  </para>
  <para>
   D'un point de vue applicatif, il y a une énorme différent dans l'utilisation de
   l'une ou l'autre des approches. Les propriétés suivantes diffèrent :
   <itemizedlist>
    <listitem>
     <simpara>
      L'émulation côté client, comme vu dans le manuel, fournie une solution simple
      pour comparer un numéro de séquence pour les transactions globales. Les multi-maîtres
      ne sont pas traités pour conserver les exemples du manuel simples.
     </simpara>
     <simpara>
      La fonctionnalité côté serveur utilise une combinaison d'un identifiant de serveur
      et d'un numéro de séquence comme identifiant de transaction globale. La
      comparaison ne peut utiliser l'algèbre. A la place de cela, une fonction
      SQL doit être utilisé. Reportez-vous au manuel de référence MySQL pour plus
      de détails.
     </simpara>
     <simpara>
      Les fonctionnalités internes côté serveur de MySQL 5.6 ne peuvent être utilisées pour
      assurer la consistence de sessions dans toutes les circonstances. Ne les utilisez donc pas
      dans le cas de la qualité de service. Voici un exemple simple montrant des résultats
      non fiables. Il y a plusieurs cas non pris en charge en raison des fonctionnalités limitées
      proposées par le serveur. Actuellement, les clients peuvent demander au service maître de
      réplication MySQL la liste de toutes les IDs de transactions globaux exécutées.
      Si un esclave est configuré pour ne pas répliquer toutes les transactions, par exemple,
      en raison de la définition de certains filtres, alors l'esclave ne montrera jamais le même
      jeu d'IDs de transactions globaux exécutées. Malgré le fait que l'esclave peut avoir
      répliqué les écritures des clients, et qu'il peut être candidat pour une lecture consistente,
      il ne sera jamais retenu par le plugin. Pendant l'écriture, le plugin apprend du maître
      que l'historique des transactions terminées des serveurs est GTID=1..3.
      Il n'y a aucun moyen pour le plugin de demander le GTID de la transaction d'écriture,
      soit GTID=3. Imaginez qu'un esclave ne réplique pas les transactions GTID=1..2 mais seulement
      GTID=3 en raison d'une fonctionnalité de la réplication. Alors, l'historique de transaction
      de l'esclave sera GTID=3. Cependant, le plugin tente de trouver un noeud qui a un historique
      de transactions de GITD=1...3. Malgré le fait que l'esclave a répliqué les écritures des clients
      et que la consistence de session a été réalisée pendant la lecture depuis l'esclave,
      il ne sera pas considéré par le plugin. Ceci n'est pas la faute de l'implémentation du plugin,
      mais d'une fonctionnalité côté serveur. Notez que cet exemple est trivial, et ne permet
      que d'illustrer le propos, mais il y a d'autres cas. En résumé, vous ne devriez pas utiliser
      les GTIDs internes à MySQL 5.6 pour renforcer la consistence de session. Tôt ou tard, la balance
      de charge arrêtera de fonctionner normalement, et le plugin va diriger toutes les requêtes
      de consistence de sessions vers le maître.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les statistiques du plugin concernant l'identifiant de transaction globale
      ne sont disponibles qu'avec l'émulation côté client car elles surveillent
      l'émulation.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <note>
   <title>Les identifiants de transaction globale dans les systèmes distribués</title>
   <para>
    Les identifiants de transaction globale peuvent servir de différentes façon dans
    un contexte de systèmes distribués, comme un cluster de base de données. Les
    identifiants de transaction globale peuvent être utilisés, par exemple, comme
    identification système des transactions, comme tri global des transaction,
    comme mécanisme permettant de savoir si le serveur est toujours disponible,
    et pour vérifier le statut de réplication pour les serveurs de réplication.
    <literal>PECL/mysqlnd_ms</literal>, un driver côté client basé sur un sofware, ne focalise sur l'utilisation
    des GTIDs pour les tâches qui peuvent être gérées par le client, comme la vérification
    du statut de réplication des serveurs de réplication pour les configurations
    asynchrones de réplication.
   </para>
  </note>
 </section>
 
 <section xml:id="mysqlnd-ms.concept_cache">
  <title>Intégration du cache</title>
  <note>
   <title>Version requise</title>
   <para>
    Cette fonctionnalité requière l'utilisation de
    <literal>PECL/mysqlnd_ms</literal> 1.3.0-beta ou supérieure et de
    <literal>PECL/mysqlnd_qc</literal> 1.1.0-alpha ou supérieure.
    <literal>PECL/mysqlnd_ms</literal> doit être compilé pour supporter cette
    fonctionnalité. PHP 5.4.0 ou supérieure est requise.
   </para>
  </note>
  <note>
   <title>Configuration : ordre de chargement de l'extension</title>
   <para>
    <literal>PECL/mysqlnd_ms</literal> doit être chargé avant
    <literal>PECL/mysqlnd_qc</literal>, lors de l'utilisation des
    extensions partagées.
   </para>
  </note>
  <note>
   <title>Stabilité des fonctionnalités</title>
   <para>
    L'intégration du cache est en qualité béta.
   </para>
  </note>
  <note>
   <title>Clusters MySQL appropriés</title>
   <para>
    Cette fonctionnalité est prévue pour une utilisation avec un serveur
    de réplication MySQL (copie primaire). Actuellement, aucun autre type
    de cluster MySQL n'est supporté. Les utilisateurs d'un tel cluster
    doivent contrôler PECL/mysqlnd_qc manuellement s'ils sont intéressés
    dans la mise en cache de requête côté client.
   </para>
  </note>
  <para>
   Le support des clusters de réplication MySQL (copie primaire asynchrone)
   est le principal but de <literal>PECL/mysqlnd_ms</literal>. Les esclaves d'un cluster de
   réplication MySQL peuvent ou non refléter les dernières mises à jour
   depuis le maître. Les esclaves sont asynchrones, et peuvent lagger derrière
   le maître. Une lecture depuis un esclave a une consistence éventuelle depuis
   une perspective cluster.
  </para>
  <para>
   Le même niveau de consistence est offert par un cache local en utilisant
   une stratégie d'invalidation time-to-live (TTL). Des données courantes ou
   des données non mises à jour peuvent être servies. Eventuellement, les données
   recherchées depuis le cache peuvent ne pas être disponibles et la source
   du cache peut devoir être accédé.
  </para>
  <para>
   En fournissant à la fois un esclage de réplication MySQL (secondaire asynchrone)
   et un cache local TTL, un niveau de service identique est fourni, et il est possible
   de remplacer de façon transparente un accès à une base de données distante par
   un accès au cache local afin d'améliorer les possibilités.
  </para>
  <para>
   Depuis <literal>PECL/mysqlnd_ms</literal> 1.3.0-beta, le plugin est capable de contrôler de façon
   transparente <literal>PECL/mysqlnd_ms</literal> 1.1.0-alpha ou supérieure pour mettre en cache une
   requête en lecture seule si c'est explicitement autorisé via la configuration
   d'une qualité de service appropriée en utilisant la fonction
   <function>mysqlnd_ms_set_qos</function>. Reportez-vous à la section
   <link linkend="mysqlnd-ms.quickstart.cache">Démarrage rapide</link> pour un exemple
   de code. Les deux plugins doivent être installés, et <literal>PECL/mysqlnd_ms</literal> doit avoir été
   compilé pour supporter la fonctionnalité de cache, et enfin, PHP 5.4.0 ou supérieure
   doit être utilisé.
  </para>
  <para>
   Les applications ont un contrôle total de l'utilisation du cache et peuvent
   demander la mise à jour des données à n'importe quel moment, si besoin.
   L'utilisation du cache peut être activée et désactivé lors de l'exécution
   du script. Le cache sera utilisé si la fonction <function>mysqlnd_ms_set_qos</function>
   définit la qualité de service à une consistence éventuelle, et active
   l'utilisation du cache. L'utilisation du cache est désactivé en demandant un
   niveau de consistence supérieur, par exemple, une consistence de session (lecture
   de vos écritures). Une fois que la qualité de service revient à une consistence
   éventuelle, le cache peut de nouveau être activé.
  </para>
  <para>
   Si la mise en cache est active pour une requête en lecture seule, <literal>PECL/mysqlnd_ms</literal>
   peut injecter <link linkend="mysqlnd-qc.quickstart.caching">une astuce SQL pour contrôler
   la mise en cache</link> via PECL/mysqlnd_qc. Cela va modifier la requête SQL
   récupérée depuis l'application. Les processeurs SQL suivants sont supposés
   ignorer les astuces SQL. Une astuce SQL est un commentaire SQL. Les commentaires
   ne doivent pas être ignorés, par exemple, par le serveur de base de données.
  </para>
  <para>
   Le TTL d'une entrée du cache est calculé pour chaque requête. Les applications
   définissent l'âge maximal des données qu'elles souhaitent récupérer en utilisant
   la fonction <function>mysqlnd_ms_set_qos</function>. L'âge définit une limite supérieure
   approximative en secondes des données pouvant être retournées depuis le maître en
   tenant compte du lag.
  </para>
  <para>
   La logique suivante est utilisée pour calculer le TTL courant si le cache
   est actif. La logique prend en compte le lag estimé de l'esclave pour choisir
   un TTL. Si, par exemple, il y a deux esclaves qui laguent de 5 et 10 secondes
   et que l'âge maximal autorisé est de 60 secondes, le TTL sera défini à 50 secondes.
   Notez également que la définission de l'âge ne dépassera pas le calcul estimé.
   <itemizedlist>
    <listitem>
     <simpara>
      Vérifie si la requête est une requête en lecture seule. Si ce n'est pas le cas,
      aucune mise en cache ne sera demandée.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Si le cache est actif, vérifie si le lag de tous les serveurs esclaves configurés.
      Etablissement des connexions aux esclaves si aucune n'existe et que les connexions
      paresseuses sont utilisées.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Envoi <literal>SHOW SLAVE STATUS</literal> à tous les esclaves. N'attends pas
      que le premier esclave réponde avant d'envoyer la demande au second.
      Les clients attendent souvent longtemps, aussi, tout est envoyé en même temps
      et l'analyse se fera dans un second temps.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      On parcourt tous les esclaves. Pour chaque esclave, on attend sa réponse.
      On ne commence pas l'analyse du prochain esclave avant que le courant n'ait
      répondu. On vérifie <literal>Slave_IO_Running=Yes</literal> et <literal>Slave_SQL_Running=Yes</literal>.
      Si les deux conditions sont vraies, on récupère la valeur de
      <literal>Seconds_Behind_Master</literal>. Dans le cas d'une erreur, ou d'un échec sur
      l'une des conditions, on définit une erreur sur la connexion de l'esclave.
      Cela permet d'ignorer ces connexions pour le reste du filtrage de connexion.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Recherche de la valeur maximale de <literal>Seconds_Behind_Master</literal>
      depuis tous les esclaves qui ont passés les conditions précédentes.
      On soustrait la valeur depuis l'âge maximal fourni par l'utilisateur avec 
      la fonction <function>mysqlnd_ms_set_qos</function>. Le reste de cette soustraction
      sera utilisé comme TTL.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Ce filtrage va trier tous les esclaves. Ainsi, l'âge maximal est utilisé
      comme TTL, car le lag maximal trouvé vaut zéro. Il est tout à fait valide
      de trier tous les esclaves. Le filtre de balance de charge interne
      prendra le maître.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Injection des astuces SQL appropriées pour activer la mise en cache par <literal>PECL/mysqlnd_qc</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Traitement avec la connexion filtrée, i.e. applique les règles de balance
      de charge pour récupérer un esclave.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>PECL/mysqlnd_qc</literal> est chargé après
      <literal>PECL/mysqlnd_ms</literal> par PHP. Aussi, il verra toutes
      les modifications de requêtes de <literal>PECL/mysqlnd_ms</literal>
      et mettra en cache la requête s'il en a reçu l'instruction.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   L'algorithme peut paraître impressionnant. <literal>SHOW SLAVE STATUS</literal> est une
   opération très rapide.En considérant un nombre de requêtes suffisants et les accès
   au cache par seconde, le coût de la vérification du lag des esclaves est largement
   inférieur au coût d'une décision du cache.
  </para>
  <para>
   Les suggestions sur un meilleur algorithme sont bien entendues les bienvenues.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.supportedclusters">
  <title>Clusters supportés</title>
  <para>
   Toute application utilisant n'importe quel cluster MySQL est soumises aux mêmes tâches:
   <itemizedlist>
    
    <listitem>
     <simpara>
      Identifier les noeuds capables d'exécuter une requête avec un niveau de service requis.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Equilibrer et distribuer la requête parmi les candidats.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Gestion automatique des pannes parmi les candidats, si nécessaire.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Le plugin est optimisé pour gérer ces tâches dans un contexte de réplication MySQL
   asynchrone classique, à savoir un seul maitre et plusieurs esclaves (copie primaire).
   Dans ce cas, toutes les tâches listées plus haut doivent être gérées coté client.
  </para>
  <para>
   D'autres types de clusters MySQL ont moins d'implication coté client.
   Par exemple, si tous les noeuds du cluster peuvent répondre aux lectures et aux écritures,
   aucune séparation ne sera nécessaire (plusieurs maîtres, mise à jour total).
   Si tous les noeuds sont synchrones, ils sont tous éligibles avec le même poids, ce qui
   simplifie la tâche de selection. Dans de tels cas, le plugin doit être reconfiguré pour
   désactiver certaines logiques, comme la séparation des lectures/écritures.
  </para>
  <note>
   <title>But de la documentation</title>
   <para>
    La documentation décrit l'utilisation du plugin dans un cas classique de réplication
    asynchrone (copie primaire). C'est le cas de base, qui a inspiré l'écriture du plugin.
    D'autres types de clusters sont décrits brièvement ci-dessous, nous continuons à
    travailler dessus actuellement.
   </para>
  </note>
  <para>
   <emphasis role="bold">Copie primaire (Réplication MySQL)</emphasis>
  </para>
  <para>
   C'est le but primaire de ce plugin. Suivez les astuces fournies dans les
   descriptions de chacune des fonctionnalités.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      Configure un maître et un ou plusieurs esclaves.
      <link linkend="mysqlnd-ms.plugin-ini-json.server-list-syntax">Les détails de la
       configuration du serveur</link> sont fournis dans la section sur l'installation.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Utilisez la politique de balance de charge aléatoire avec le flag
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-random">sticky</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Si vous ne prévoyez pas d'utiliser les appels API
      <link linkend="mysqlnd-ms.quickstart.qos-consistency">du niveau de service</link>,
      ajoutez le flag
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.master-on-write">d'écriture sur le maître</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Soyez prudent sur les propriétés du failover automatique avant d'ajouter
      la directive <link linkend="ini.mysqlnd-ms-plugin-config-v2.failover">failover</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Vous devriez considérer l'utilisation du flag
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness</link>
      pour exécuter les transactions uniquement sur le primaire. Veuillez lire
      attentivement son mode de fonctionnement avant de l'utiliser.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   <example>
    <title>Activation du plugin (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Configuration simple du plugin (mysqlnd_ms_plugin.ini) pour une réplication MySQL</title>
    <programlisting role="ini">
<![CDATA[
{
  "myapp": {
    "master": {
      "master_1": {
        "host": "localhost",
        "socket": "\/tmp\/mysql57.sock"
      }
    },
    "slave": {
      "slave_0": {
        "host": "127.0.0.1",
        "port": 3308
      },
      "slave_1": {
        "host": "192.168.2.28",
        "port": 3306
      }
    },
    "filters": {
      "random": {
        "sticky": "1"
      }
    }
  }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <emphasis role="bold">Copie primaire avec plusieurs primaires (MMM - MySQL Multi Master)</emphasis>
  </para>
  <para>
   La réplication MySQL vous permet de créer des topologies de cluster avec plusieurs maîtres (primaires).
   Les conflits d'écriture ne sont pas gérées par le système de réplication. Aussi,
   les données doivent être partitionnées manuellement et les clients doivent être redirigés suivant
   les règles de partitionnement. La configuration recommandée est identique à la configuration
   de fragmentation ci-dessous.
  </para>
  <para>
   <emphasis role="bold">Fragmentation manuelle, combinée éventuellement avec une copie primaire et plusieurs
    primaires</emphasis>
  </para>
  <para>
   Utilisez les astuces SQL et le filtre de groupe du noeud pour les clusters qui utilisent
   le partitionnement des données, mais laissez au client la redirection de la requête. L'exemple de configuration
   montre une configuration de plusieurs maîtres avec deux fragmentations.
  </para>
  <para>
   <example>
    <title>Plusieurs primaires - plusieurs maîtres (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
mysqlnd_ms.multi_master=1
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Copie primaire avec plusieurs primaires et le partitionnement</title>
    <programlisting role="ini">
<![CDATA[
{
  "myapp": {
    "master": {
      "master_1": {
        "host": "localhost",
        "socket": "\/tmp\/mysql57.sock"
      }
      "master_2": {
        "host": "192.168.2.27",
        "socket": "3306"
      }
    },
    "slave": {
      "slave_1": {
        "host": "127.0.0.1",
        "port": 3308
      },
      "slave_2": {
        "host": "192.168.2.28",
        "port": 3306
      }
    },
    "filters": {
      "node_groups": {
        "Partition_A" : {
          "master": ["master_1"],
          "slave": ["slave_1"]
        },
        "Partition_B" : {
          "master": ["master_2"],
          "slave": ["slave_2"]
        }
      },
      "roundrobin": []
    }
  }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Le plugin peut également être utilisé avec une collection mouvante de
   morceaux indépendants. Pour un tel cluster, configurez les maîtres uniquement
   et désactivez la séparation des lectures/écritures. Les noeuds d'un tel cluster
   sont appelés maîtres dans la configuration du plugin vu qu'ils acceptent à la fois
   les lectures et les écritures pour leur partition.
  </para>
  <para>
   <emphasis role="bold">Using synchronous update everywhere clusters such as MySQL Cluster</emphasis>
  </para>
  <para>
   MySQL Cluster est une solution de cluster synchrone. Tous les noeuds acceptent des lectures et des
   écritures. D'un point de vue du plugin, tous les noeuds devraient alors être considérés comme des
   maitres.
  </para>
  <para>
   Utilisez les fonctionnalités d'équilibre de charge et de reprise sur panne seulement.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      Désactivez le support de <link linkend="mysqlnd-ms.rwsplit">la séparation des lectures et écritures</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Ne configurez que les maitres.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Considerant la strategy "random once" (cas par défaut), seuls les maitres sont
      configurés et aucune astuce SQL n'est requise, aucune bascule de connexion
      n'arrivera durant la requête web. Ainsi, aucune directive particulière n'est requise
      en ce qui concerne les transactions, le plugin selectionnera un maitre au début du script
      PHP et l'utilisera jusqu'à la fin.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Ne précisez pas la qualité de service. Tous les noeuds possèdent toutes les données.
      Ceci vous fournit la consistence maximale (consistence forte).
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      N'activez pas l'injection d'identifiant de transaction coté client. Ceci ne sera d'aucune
      aide.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Désactiver la répartition des lectures/écritures.
   <itemizedlist>
    <listitem>
     <simpara>
      Mettez
      <link linkend="mysqlnd-ms.configuration"><literal>mysqlnd_ms.disable_rw_split=1</literal></link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      N'utilisez pas <link linkend="mysqlnd-ms.rwsplit">d'astuces SQL</link> pour forcer l'utilisation
      d'un noeud.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Ne configurez que les maitres.
   <itemizedlist>
    <listitem>
     <simpara>
      Mettez
      <link linkend="mysqlnd-ms.configuration"><literal>mysqlnd_ms.multi_master=1</literal>.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>Ne configurez aucun esclave.</simpara>
    </listitem>
    <listitem>
     <simpara>
      Mettez
      <literal><link linkend="mysqlnd-ms.plugin-ini-json">failover=loop_before_master</link></literal>
      dans le fichier de configuration du plugin, pour éviter les messages d'avertissement
      concernant une liste d'esclave vide et pour permettre à la logique de boucle du
      failover de parcourir tous les maîtres configurés avant d'émettre une erreur.
     </simpara>
     <simpara>
      Notez les alertes fournies à propos du failover automatique dans les précédentes
      sections.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   <example>
    <title>Plusieurs primaires - plusieurs maîtres (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
mysqlnd_ms.multi_master=1
mysqlnd_ms.disable_rw_split=1
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Mise à jour synchrone dans n'importe quel cluster</title>
    <programlisting role="ini">
<![CDATA[

  "myapp": {
    "master": {
      "master_1": {
        "host": "localhost",
        "socket": "\/tmp\/mysql57.sock"
      },
      "master_2": {
        "host": "192.168.2.28",
        "port": 3306
      }
    },
    "slave": {
    },
    "filters": {
      "roundrobin": {
      }
    },
    "failover": {
      "strategy": "loop_before_master",
      "remember_failed": true
    }
  }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Si vous exécutez une mise à jour dans n'importe quel cluster qui ne supporte
   pas le partitionnement afin d'éviter les points chauds et les collisions,
   vous devriez considérer l'utilisation du filtre sur les groupes de noeuds
   pour conserver les mises à jour sur les tables fréquemment utilisées sur
   un de ces noeuds. Ceci peut aider à réduire les collisions, et donc,
   améliorer les performances.
  </para>
 </section>

 <section xml:id="mysqlnd-ms.concept_xa_trx">
  <title>XA/Distributed transactions</title>
  <note>
   <title>Nécessité de version</title>
   <para>
    Les fonctions relatives à XA ont été introduites en
    <literal>PECL/mysqlnd_ms</literal> version 1.6.0-alpha.
   </para>
  </note>
  <note>
   <title>Ce que les premiers adaptateurs voulaient</title>
   <para>
    Cette fonctionnalité est actuellement en cours de développement. Il peut
    y avoir des problèmes et/ou des limitations dans la fonctionnalité. Ne
    pas utiliser en environnement de production, malgré le fait que les premiers
    tests indiquent une qualité satisfaisante.
   </para>
   <para>
    Merci de contacter l'équipe de développement si vous êtes intéressé par
    cette fonctionnalité. Nous sommes à la recherche de retours utilisateurs
    pour compléter la fonctionnalité.
   </para>
   <para>
    Voici une liste des restrictions actuelles de la fonctionnalité.
     <itemizedlist>
      <listitem>
       <para>
        Cette fonctionnalité n'est pour l'instant pas compatible avec le
        support MySQL Fabric. Ceci devrait s'arranger d'ici peu.
       </para>
       <para>
        Les identifiants de transaction XA sont actuellement restreints
        à des nombres. Cette limitation devrait bientôt disparaître ; ce
        n'est qu'une simplification induite lors de l'implémentation
        initiale.
       </para>
      </listitem>
    </itemizedlist>
   </para>
  </note>
  <note>
   <title>Restrictions du serveur MySQL</title>
   <para>
    Le support XA par le serveur MySQL a quelques limitations. La plus notable
    est que le binaire d'historisation du serveur peut rater des modifications
    effectuées par les transactions XA en cas de certaines erreurs. Veuillez
    vous rapporter au manuel de MySQL pour plus de détails.
   </para>
  </note>
  <para>
   Les transactions distribuées/XA peuvent impliquer plusieurs serveurs MySQL.
   Aussi, elles peuvent paraître comme un outil parfait pour les clusters
   partagés MySQL, par exemple, les clusters gérés avec MySQL Fabric.
   <literal>PECL/mysqlnd_ms</literal> cache la plupart des commandes SQL qui
   contrôlent les transactions XA, et réalise automatiquement des tâches
   administratives en cas d'erreur, pour fournir à l'utilisateur une API
   compréhensive. Les utilisateurs doivent configurer le plugin avec prudence,
   et faire attention aux restrictions des serveurs avant d'utiliser cette fonctionnalité.
  </para>
  <para>
   <example>
    <title>Masque général pour les transactions XA</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");

/* On commence ! */
mysqlnd_ms_xa_begin($mysqli, 1 /* xa id */);

/* Exécution de plusieurs requêtes sur divers serveurs */
$mysqli->query("UPDATE some_table SET col_a = 1");
...

/* Validaiton ! */
mysqlnd_ms_xa_commit($link, 1);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Les transactions XA utilisent un protocole de validation en deux phases.
   Ce protocole est bloquant. Pendant la première phase, les serveurs participants
   commencent une transaction et le client réalise son travail. Cette phase est
   suivie par une seconde phase de vote. Pendant le vote, les serveurs font d'abord
   la promesse ferme qu'ils sont prêts à réaliser le travail y compris s'il
   survient une erreur innatendue. Si un serveur crash pendant cette phase, il
   va appeler de nouveau la transaction interrompue après son redémarrage, et
   va attendre que le client décide si la transaction doit être validée ou annulée.
  </para>
  <para>
   Si un client qui a initié une transaction globale crash après que l'appel
   aux serveurs participants demandant leurs promesses de validation ne soit
   réalisé, alors les serveurs doivent attendre une décision. Les serveurs ne
   sont pas autorisés à prendre de façon unilatérale une décision sur la transaction.
  </para>
  <para>
   Un crash du client, une déconnection d'un participant, un crash serveur ou
   une erreur serveur durant la première phase n'est pas critique. Dans la plupart
   des cas, le serveur va oublier la transaction XA et réaliser une annulation.
   De plus, le plugin va tenter de contacter un maximum de participants pour les
   informer d'annuler immédiatement le travail. Il n'est pas possible de désactiver
   cette annulation implicite réalisée par <literal>PECL/mysqlnd_ms</literal> dans le
   cas d'erreurs survenues pendant la première phase du protocole. Ce comportement
   a été décidé afin de conserver une implémentation simple.
  </para>
  <para>
   Une erreur pendant la seconde phase du protocole de validation peut engendrer
   une situation plus sévère. Dans tous les cas, les serveurs ne vont pas
   oublier la transactions en cours (mais pas terminées). Le plugin ne va pas
   tenter de résoudre ce problème immédiatement, mais va attendre le passage
   en arrière plan du collecteur de données incorrectes pour s'assurer de la
   progression du protocole de validation. Il est supposé que cette solution prend
   un temps signification, car il inclue le temps d'attente d'un serveur participant
   pour redémarrer après un crash. Cette durée passée peut être plus longue
   qu'un développeur et un utilisateur peuvent prétendre lors d'une tentative
   de validation d'une transaction globale avec la fonction <function>mysqlnd_ms_xa_commit</function>.
   Aussi, la fonction va retourner avec une transation globale non terminée qui
   va continuer de demander toute l'attention. Faites attention à ce moment précis,
   tout n'est pas propre, sachant que la transaction globale peut toujours être
   validée ou annulée plus tard.
  </para>
  <para>
   Les erreurs pendant la seconde phase peuvent être annulées, gérées par vous même,
   ou résolues par la logique du collecteur de données incorrectes. Les ignorer n'est
   pas recommandé, sachant que vous pouvez avoir des transactions globales non terminées
   sur vos serveurs qui bloquent les ressources indéfiniement. La gestion de ces erreurs
   nécessite de connaître les participants, vérifier leurs statuts, et leur envoyer les
   requêtes SQL appropriées. Il n'existe pas d'appel API permettant de retrouver
   ces informations. Vous devez configurer un stockage de statuts et y enregistrer
   les actions du plugin pour retrouver l'information.
  </para>
  <para>
   Veuillez lire la section de
   <link linkend="mysqlnd-ms.quickstart.xa_transactions">démarrage rapide</link>
   ainsi que les <link linkend="ini.mysqlnd-ms-plugin-config-v2.xa.state-store">
   options du fichier de configuration</link> pour un exemple de configuration
   d'un stockage de statuts. En plus de configurer un stockage de statuts,
   vous devez configurer quelques tables SQL. Les définitions de ces tables sont
   fournies dans la description des options de configuration du plugin.
  </para>
  <para>
   La mise en place et la configuration d'un stockage de statut est également
   un prérequis à l'utilisation du collecteur de données incorrectes interne
   pour les transactions XA qui échoue pendant la seconde phase de la validation.
   L'enregistrement des informations sur les transactions XA entrantes est une
   tâche supplémentaire inévitable. Cette tâche consiste à mettre à jour le stockage
   de statuts après chaque opération qui modifie le statut de la transaction globale
   (démarrage, validation, annulation, erreurs et arrêt), après chaque ajout de
   participants (hôte, optionnellement, nom d'utilisateur et mot de passe de connexion)
   ainsi que toutes modifications de statuts des participants. Notez que, suivant
   la configuration, et votre politique de sécurité, ces enregistrements peuvent
   être très sensibles. Il est recommandé de restreindre l'accès au stockage de
   statuts. A moins que le stockage de statuts devienne surchargé, l'enregistrement
   des informations de statut contribue à la charge globale mais son impact
   reste très limité.
  </para>
  <para>
   Il est possible que les efforts que vous prendrez pour implémenter vos propres
   routines pour gérer les transactions XA en échec pendant la seconde phase de validation
   excèdent les bénéfices de l'utilisation de la fonctionnalité XA de
   <literal>PECL/mysqlnd_ms</literal>. Aussi, le manuel n'abordera que l'utilisation
   du collecteur de données incorrectes interne.
  </para>
  <para>
   Le collecteur de données incorrectes peut être lancé manuellement et automatiquement
   en arrière plan. Vous pouvez vouloir utiliser la fonction <function>mysqlnd_ms_xa_gc</function>
   immédiatement après un échec de validation pour tenter de résoudre le souci, mais
   réouvrir les transactions globales aussi tôt que possible. Vous pouvez aussi décider de
   désactiver le collecteur de données incorrectes automatique d'arrière plan,
   implémenter vos propres règles d'appel au collecteur de données incorrectes interne,
   et l'appeler lorsque vous le souhaitez.
  </para>
  <para>
   Par défaut, le plugin va démarrer le collecteur de données incorrectes en suivant
   une probabilité définie par la méthode <literal>RSHUTDOWN</literal> interne à l'extension.
   Le requête d'arrêt est appelé après la fin de votre script. Le moment du démarrage
   du collecteur de données incorrectes est déterminé en calculant une valeur aléatoire
   comprise dans l'intervalle <literal>1...1000</literal> et en la comparant avec
   l'option de configuration
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.xa.gc"><literal>probability</literal></link>
   (défaut : 5). Si l'option de configuration est supérieure ou égale à la valeur aléatoire,
   le collecteur de données incorrectes sera lancé.
  </para>
  <para>
   Une fois démarré, le collecteur de données incorrectes agira jusqu'à
    <literal>max_transactions_per_run</literal> (défaut : 100) enregistrements
   de transactions globales. Les enregistrements incluent les transactions
   terminées avec succès, mais aussi, les transactions XA non terminées. Les enregistrements
   pour les transactions terminées avec succès sont supprimés, et on tente de résoudre
   les transactions non terminées. Il n'y a aucune statistique permettant de trouver
   la balance juste entre la conservation de l'exécution courte du collecteur de données
   incorrectes en limitant le nombre de transactions considérées par exécution, et
   le fait d'éviter l'échec du collecteur de données incorrectes faisant qu'un grand
   nombre d'enregistrements ne soit réalisé.
  </para>
  <para>
   Pour chaque transaction XA en échec, le collecteur de données incorrectes va tenter
   <literal>max_retries</literal> (défaut : 5) fois de la terminer. Après cela,
   <literal>PECL/mysqlnd_ms</literal> va rendre la main. Il y a deux raisons à cela.
   Soit un serveur participant a crashé, et est devenu inaccessible pendant les
   <literal>max_retries</literal> invocations du collecteur de données incorrectes, ou
   bien, il y a un cas où le collecteur de données incorrectes internes ne peut
   pas faire face. Le dernier cas peut être considéré comme un bogue. Cependant, vous
   pouvez forcer manuellement plusieurs exécutions du collecteur de données incorrectes
   en appelant la fonction <function>mysqlnd_ms_xa_gc</function> avec le jeu de
   paramètres approprié. Si l'exécution de ces fonctions échoue dans la résolution
   de la situation, alors le problème doit être réglé par un opérateur.
  </para>
  <para>
   La fonction <function>mysqlnd_ms_get_stats</function>
   fournit quelques statistiques sur le nombre de transactions XA qui ont été démarrées,
   validées, échouées ou annulées.
  </para>

 </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
