<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 3a0cd9cd7d7f1c8bbda89188799f9d86c4dfb775 Maintainer: jpauli Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-ms.concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Concepts</title>
 <para>
  Cette section détaille l'architecture et les concepts associés au plugin, puis
  décrit l'impact de la réplication MySQL et du plugin sur la tâche de
  développement. Comprendre ces concepts est nécessaire pour bien utiliser
  le plugin.
 </para>
 <section xml:id="mysqlnd-ms.architecture">
  <title>Architecture</title>
  <para>
   Le plugin mysqlnd de réplication et de répartition de charge est implémenté sous
   forme d'extension PHP. Il est écrit en C et agit sous PHP et durant la phase de
   démarrage de l'interpréteur PHP (phase d'initialisation des modules) il est enregistré
   comme plugin <link linkend="book.mysqlnd">mysqlnd</link> pour remplacer des fonctions
   C spécifiques.
  </para>
  <para>
   Au déroulement de PHP, il inspecte les requêtes envoyées depuis mysqlnd(PHP) au serveur
   MySQL. Si une requête est reconnue comme étant de type lecture seule, elle sera aiguillée
   vers un des serveurs esclaves configurés. Ceci est le cas pour les requêtes commençant
   par <literal>SELECT</literal>, au moyen de l'astuce SQL <literal>/*ms=slave*/</literal> ou alors
   si un esclave a été choisi pour exécuter la requête précédente et qu'elle utilisait l'astuce
   SQL <literal>/*ms=last_used*/</literal>. Dans tous les autres cas, la requête sera envoyée au
   serveur maitre.
  </para>
  <para>
   Les applications doivent utiliser les 
   <link linkend="mysqlnd-ms.constants">constantes prédéfinies</link>
   <constant>MYSQLND_MS_MASTER_SWITCH</constant>,
   <constant>MYSQLND_MS_SLAVE_SWITCH</constant> et
   <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>
   au lieu de leurs valeurs littérales, comme
   <literal>/*ms=slave*/</literal>, et ce, dans un souci de portabilité.
  </para>
  <para>
   Le plugin se charge en interne d'ouvrir et fermer des connexions au maitre et aux esclaves.
   Du point de vue de l'application, il n'y a qu'une seule connexion visible. Cependant, en interne,
   cette connexion est représentée par un groupe de connexions réseaux gérées par le plugin.
   Le plugin aiguille les requêtes vers le maitre ou les esclaves en utilisant de multiples
   connexions.
  </para>
  <para>
   Les connexions aux bases de données ont des états, par exemple, le statut des transactions,
   lejeu de caractères, les tables temporaires. Le plugin va tenter de garder les états des
   connexions de manière transparente pour les requêtes qu'il traite, lorsque cela lui est
   possible. Dans les cas contraires, comme par exemple via l'utilisation de
   <literal>BEGIN TRANSACTION</literal>, le plugin laisse l'utilisateur gérer les connexions.
  </para>  
 </section>
 
 <section xml:id="mysqlnd-ms.pooling">
  <title>Groupe de connexions et bascule entre les connexions</title>
  <para>
   Le plugin de réplication et répartition de charge change la sémantique d'une
   connexion MySQL de PHP. Les API existantes des extensions PHP pour MySQL
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link> et
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) sont inchangées, mais leur
   comportement est modifié lorsque le plugin est utilisé. Les applications
   existantes n'ont pas de changement                                                                     à opérer pour utiliser la nouvelle API,
   mais elles devront peut-être être modifiées en ce qui concerne le comportement
   du plugin.
  </para>
  <para>
   Le plugin casse la relation un-à-un entre une connexion
   <link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link> et
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link> et la connexion réseau à
   MySQL. Lorsque le plugin est utilisé, la connexion de
   <link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link> représente en fait un groupe
   de connexions vers un serveur maitre MySQL et des serveurs esclaves.
   Le plugin aiguille les requêtes vers le serveur maitre ou un des esclaves.
   A un moment donné, une connexion vue depuis PHP peut pointer vers le maitre
   et juste après vers un esclave, ou alors toujours le maitre. La manipulation
   et le remplacement d'une connexion réseau référencée par un gestionnaire
   de connexion PHP MySQL n'est pas une opération transparente.
  </para>
  <para>
   Chaque connexion MySQL possède un état, et les différentes connexions, gérées dans
   un groupe par le plugin, peuvent avoir chacune des états différents. Lorsque le
   plugin bascule d'une connexion à une autre, l'état est susceptible de changer.
   L'application doit prendre cela en compte.
  </para>
  <para>
   La liste suivante indique ce qui est caractérisé par un état de connexion.
   Cette liste peut ne pas être totalement complète.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      Les statuts des transactions
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les tables temporaires
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les verrous des tables
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les variables de session système ou utilisateur
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Le jeu de bases de données courantes, utilisant
      <literal>USE</literal> ainsi que d'autres commandes de statut SQL
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les requêtes préparées
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les variables <literal>HANDLER</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les verrous retournés par <literal>GET_LOCK()</literal>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Le changement de connexions intervient juste avant l'exécution de la requête.
   Le plugin ne change la connexion courante qu'au moment où la prochaine
   requête est exécutée.
  </para>
  <note>
   <title>Problèmes liés à la réplication</title>
   <para>
    Voyez aussi le manuel de référence de MySQL concernant 
    <link xlink:href="&url.mysql.docs.replication;">la réplication</link> et
    ses problématiques. Certaines restrictions ne sont pas dûes au plugin PHP mais
    sont des caractéristiques du mécanisme de réplication de MySQL.
   </para>
  </note>
  <para>Messages diffusés</para>
  <para>
   La philosophie du plugin est d'aligner le statut des connexions dans la file
   d'attente uniquement si le statut est sous le contrôle total du plugin,
   ou si c'est nécessaire d'un point de vue de la sécurité. Seulement quelques
   actions modifiants le statut de la connexion rentrent dans cette catégorie.
  </para>
  <para>
   Voici la liste des appels diffusés de la bibliothèques clientes qui modifient
   le statut de toutes les connexions contenus dans la file d'attente.
  </para>
  <para>
   Si un des appels listés ci-dessous est exécuté, le plugin
   parcourt toutes les connexions actuellement ouvertes vers
   le maître et les esclaves. Le parcourt continue tant que tous
   les serveurs n'ont pas été contactés. Le parcourt ne s'interrompt
   pas lorsqu'un des serveurs indique une erreur. Si possible, l'erreur
   sera propagée pour appeler la fonction de l'API utilisateur. Suivant
   cette fonction, qui a été lancée par la fonction de la bibliothèque
   sous-jacente, l'utilisateur peut être capable de détecter l'erreur.
  </para>
  <informaltable>
   <tgroup cols="3">
    <colspec colwidth="10%"/>
    <colspec colwidth="70%"/>
    <colspec colwidth="20%"/>
    <thead>
     <row>
      <entry>Appel de la bibliothèque</entry>
      <entry>Notes</entry>
      <entry>Version</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <literal>change_user()</literal>
      </entry>
      <entry>
       Appelé par l'appel de l'API utilisateur <function>mysqli_change_user</function>.
       Également émise lors de la réutilisation d'une connexion
       <literal>mysqli</literal> persistante.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>select_db</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysql_select_db</function>,
       <function>mysql_list_tables</function>,
       <function>mysql_db_query</function>,
       <function>mysql_list_fields</function>,
       <function>mysqli_select_db</function>.
       Notez que <literal>USE</literal> n'est pas surveillé.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_charset()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysql_set_charset</function>.
       <function>mysqli_set_charset</function>.
       Notez que <literal>SET NAMES</literal> n'est pas surveillé.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_server_option()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_multi_query</function>,
       <function>mysqli_real_query</function>,
       <function>mysqli_query</function>,
       <function>mysql_query</function>.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_client_option()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_options</function>,
       <function>mysqli_ssl_set</function>,
       <function>mysqli_connect</function>,
       <function>mysql_connect</function>,
       <function>mysql_pconnect</function>.
      </entry>
      <entry>Depuis la version 1.0.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_autocommit()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_autocommit</function>,
       <literal>PDO::setAttribute(PDO::ATTR_AUTOCOMMIT)</literal>.
      </entry>
      <entry>Depuis la version 1.0.0. PHP &gt;= 5.4.0.</entry>
     </row>
     <row>
      <entry>
       <literal>ssl_set()</literal>
      </entry>
      <entry>
       Appelé par les appels de l'API utilisateur suivants :
       <function>mysqli_ssl_set</function>.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  <para>Les connexions diffusées et paresseuses</para>
  <para>
   Le plugin n'utilise pas de proxy ou bien ne se "souvient" pas de
   toutes les configurations à appliquer aux futures connexions.
   Il est important de se rappeler de cela lors de l'utilisation des
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.lazy_connections">connexions paresseuses</link>.
   Les connexions paresseuses sont des connexions qui ne sont pas ouvertes
   tant que le client n'envoie pas la première connexion.
   Le plugin utilise par défaut de telles connexions.
  </para>
  <para>
   Les appels de la bibliothèque modifiant la configuration et le statut des connexions
   ci-après sont enregistrés pour être utilisés lors de l'ouverture
   d'une connexion paresseuse afin de s'assurer que le statut de cette connexion
   est comparable avec le statut de toutes les connexions de la file d'attente.
  </para>
  <informaltable>
   <tgroup cols="3">
    <colspec colwidth="10%"/>
    <colspec colwidth="70%"/>
    <colspec colwidth="20%"/>
    <thead>
     <row>
      <entry>Appel de la bibliothèque</entry>
      <entry>Notes</entry>
      <entry>Version</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <literal>change_user()</literal>
      </entry>
      <entry>
       Utilisateur, mot de passe et base de données sont enregistrés
       pour une utilisation ultérieure.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
     <row>
      <entry>
       <literal>select_db</literal>
      </entry>
      <entry>
       Base de données enregistré pour utilisation ultérieure.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_charset()</literal>
      </entry>
      <entry>
       Appel <literal>set_client_option(MYSQL_SET_CHARSET_NAME, charset)</literal>
       sur les connexions paresseuses pour s'assurer que
       <literal>charset</literal> sera utilisé lors de l'ouverture d'une connexion
       paresseuse.
      </entry>
      <entry>Depuis la version 1.1.0.</entry>
     </row>
     <row>
      <entry>
       <literal>set_autocommit()</literal>
      </entry>
      <entry>
       Ajoute <literal>SET AUTOCOMMIT=0|1</literal> à la liste des commandes
       d'initialisation pour une connexion paresseuse utilisant
       <literal>set_client_option(MYSQL_INIT_COMMAND, &quot;SET AUTOCOMMIT=...%quot;)</literal>.
      </entry>
      <entry>Depuis la version 1.1.0. PHP &gt;= 5.4.0.</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  
  <caution>
   <title>Connection state</title>
  <para>
   Notez que le statut de la connexion n'est pas changé que par des appels
   API. Aussi, même si PECL mysqlnd_ms surveille tous les appels API, l'application
   a toujours besoin de maintenir le statut de la connexion, si besoin.
  </para>
  </caution>
 </section>
 
 <section xml:id="mysqlnd-ms.transaction">
  <title>Gestion des transactions</title>
  <para>
   La gestion des transactions est impactée en profondeur. Une transaction est une unité logique
   lancée par le serveur. Cette unité peut se composer d'une ou plusieurs requêtes.
  </para>
  <para>
   Par défaut, le plugin ne se soucie pas des transactions SQL. Il est donc possible qu'il
   décide de basculer de connexions dans le cadre de la répartition de charge, et ceci peut
   arriver au milieu d'une transaction. C'est contre la nature même d'une transaction SQL, le
   plugin n'est donc pas au courant des transactions par défaut.
  </para>
  <para>
   Les applications qui utilisent des transactions SQL avec le plugin doivent utiliser des
   <link linkend="mysqlnd-ms.quickstart.sqlhints">astuces SQL</link> (artefacts) pour désactiver
   la bascule automatique de connexion effectuée par le plugin. Voyez les détails dans
   <link linkend="mysqlnd-ms.quickstart">les sections d'exemple.</link>
  </para>
  <!-- TODO Refactor PHP 5.4.0 references -->
  <note>
   <title>Ajouts effectués depuis PHP 5.4.0</title>
   <para>
    La bibliothèque <link linkend="book.mysqlnd">mysqlnd</link> permet au plugin de
    surcharger l'appel C <literal>set_autocommit()</literal>, afin de détecter le statut
    du mode <literal>autocommit</literal>.
   </para>
   <para>
    Ajout du support de
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx_stickiness">trx_stickiness=master</link>
   </para>
  </note>
  
  <para>
   Les extensions PHP pour MySQL effectuent une requête (comme <literal>SET AUTOCOMMIT=0|1</literal>),
   ou utilisent l'appel mysqlnd <literal>set_autcommit()</literal> pour contrôler le statut de
   l'<literal>autocommit</literal>. Si une extension utilise
   <literal>set_autocommit()</literal>, le plugin sera au courant des transactions, ce
   n'est pas le cas si du SQL est utilisé.
   L'appel <literal>set_autocommit()</literal> est utilisé par
   <function>mysqli_autocommit</function> et
   <literal>PDO::setAttribute(PDO::ATTR_AUTOCOMMIT)</literal>.
  </para>
  <para>
   L'option de configuration du plugin <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx_stickiness">trx_stickiness=master</link>
   peut être utilisée pour rendre le plugin sensible aux transactions.
   Grâce à ça, le plugin arrête la répartition de charge si l'autocommit est désactivé,
   et la réactive dans le cas contraire.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.errorhandling">
  <title>Gestion des erreurs</title>
  <para>
   Les applications utilisant PECL/mysqlnd_ms doivent gérer proprement
   les erreurs pouvant survenir de tous les appels API utilisateur.
   En raison du fait que le plugin modifie la sémantique d'un gestionnaire
   de connexion, les appels API peuvent retourner des erreurs inattendues.
   Si vous utilisez le plugin, un gestionnaire de connexion ne représente
   plus une connexion réseau individuelle mais un groupe de connexions.
   Un code erreur et un message d'erreur peuvent être définis sur le gestionnaire
   de connexion, que l'erreur survienne sur n'importe quelle connexion
   réseau du groupe.
  </para>
  <para>
   Si vous utilisez les connexions paresseuses, (ce qui est le comportement
   par défaut), les connexions ne sont pas ouvertes tant qu'elle n'est pas
   nécessaire pour l'exécution d'une requête. Toutefois, il peut survenir
   qu'un appel API pour l'exécution d'une requête retourne une erreur
   de connexion. Dans l'exemple suivant, une erreur est provoquée lorsque
   l'on tente d'exécuter une requête sur un esclave. L'ouverture de la
   connexion esclave échoue car le fichier de configuration du plugin
   liste un nom d'hôte invalide pour l'esclave.
  </para>
  <para>
   <example>
    <title>On provoque une erreur de connexion</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "invalid_host_name",
            }
        },
        "lazy_connections": 1
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   L'activation explicite des connexions paresseuses est effectuée ici
   que dans un but de démonstration.
  </para>
  <para>
   <example>
    <title>Erreur de connexion sur l'exécution d'une requête</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Bien sûr, votre gestion des erreurs est bien meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connexion 1, la connexion lie la variable SQL ; ce n'est pas un SELECT, la requête sera donc exécuté sur le maître */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connexion 2, exécution sur l'esclave car SELECT provoque une erreur de connexion */
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
&example.outputs.similar;
    <screen>
<![CDATA[
PHP Warning:  mysqli::query(): php_network_getaddresses: getaddrinfo failed: Name or service not known in %s on line %d
PHP Warning:  mysqli::query(): [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known (trying to connect via tcp://invalid_host_name:3306) in %s on line %d
[2002] php_network_getaddresses: getaddrinfo failed: Name or service not known
]]>
    </screen>
   </example>
  </para>
  <para>
   Les applications doivent être capables de gérer les erreurs de connexions.
   au moyen d'un gestionnaire d'erreurs correct.
  </para>
  <para>
   Suivant le cas rencontré, les applications peuvent vouloir gérer les erreurs
   de connexions différemment des autres erreurs. Typiquement, les erreurs
   de connexions sont
   <literal>2002 (CR_CONNECTION_ERROR) - Can't connect to local MySQL server through socket '%s' (%d)</literal>,
   <literal>2003 (CR_CONN_HOST_ERROR) - Can't connect to MySQL server on '%s' (%d)</literal> et
   <literal>2005 (CR_UNKNOWN_HOST) - Unknown MySQL server host '%s' (%d)</literal>.
   Par exemple, l'application doit tester les codes erreurs et manuellement exécuter
   une fonction appropriée. La philosophie du plugin n'est pas d'offrir
   de fonction adéquate lors d'un échec du maître, car ces échecs ne sont
   pas des opérations transparentes.
  </para>
  <para>
   <example>
    <title>On provoque une erreur de connexion</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "invalid_host_name"
            },
            "slave_1": {
                "host": "192.168.78.136"
            }
        },
        "lazy_connections": 1,
        "filters": {
            "roundrobin": [

            ]
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   L'activation explicite des connexions paresseuses est effectuée ici
   uniquement dans un but démonstratif. Notez que la balance de charge
   round robin est utilisée en lieu et place de la méthode par défaut
   <literal>random once</literal>
  </para>
  <para>
   <example>
    <title>Échec les plus courants</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Évidemment, votre gestionnaire d'erreur est bien meilleur... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connexion 1, la connexion lie la variable SQL user ; pas de SELECT, la requête peut se faire sur le maître */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connexion 2, d'abord, sur l'esclave */
$res = $mysqli->query("SELECT VERSION() AS _version");
/* Échec manuel */
if (2002 == $mysqli->errno || 2003 == $mysqli->errno || 2004 == $mysqli->errno) {
  /* Connexion 3, la première connexion à l'esclave échoue, tentative du prochain esclave */
  $res = $mysqli->query("SELECT VERSION() AS _version");
}

if (!$res) {
  printf("ERROR, [%d] '%s'\n", $mysqli->errno, $mysqli->error);
} else {
 /* Les messages d'erreur sont récupérés de la connexion 3, et donc, aucune erreur */
 printf("SUCCESS, [%d] '%s'\n", $mysqli->errno, $mysqli->error);
 $row = $res->fetch_assoc();
 $res->close();
 printf("version = %s\n", $row['_version']);
}
$mysqli->close();
?>
]]>
    </programlisting>
&example.outputs.similar;
    <screen>
<![CDATA[
[1045] Access denied for user 'username'@'localhost' (using password: YES)
PHP Warning:  mysqli::query(): php_network_getaddresses: getaddrinfo failed: Name or service not known in %s on line %d
PHP Warning:  mysqli::query(): [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known (trying to connect via tcp://invalid_host_name:3306) in %s on line %d
SUCCESS, [0] ''
version = 5.6.2-m5-log
]]>
    </screen>
   </example>
  </para>
  <para>
   Dans quelques cas, il n'est pas possible facilement de récupérer toutes
   les erreurs qui surviennent sur toutes les connexions réseaux via le gestionnaire
   de connexions. Supposons qu'un groupe de connexions contient 3 connexions ; une
   vers le maître et deux autres vers des esclaves. L'application modifie la base
   de données courante en utilisant l'appel API <function>mysqli_select_db</function>,
   qui appelle la fonction de la bibliothèque mysqlnd pour modifier le schéma.
   mysqlnd_ms surveille la fonction et tente de changer la base de données
   courante sur toutes les connexions afin d'harmoniser leurs statuts.
   Supposons que le maître arrive à changer la base de données, mais que les
   esclaves échouent. Lors de la première erreur depuis le premier esclave,
   le plugin définira une erreur appropriée sur le gestionnaire de connexions.
   La même chose est effectuée lorsque le second esclave échoue. Le message
   d'erreur depuis le premier esclave est alors perdu.
  </para>
  <para>
   Un tel cas peut être débogué soit en vérifiant les erreurs de type
   <literal>E_WARNING</literal> (voir ci-dessus), ou soit, s'il n'y a
   pas d'autres options, en investiguant les
   <link linkend="mysqlnd-ms.debugging">traces et l'historique de déboguage mysqlnd_ms</link>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.failover">
  <title>Gestion des incidents (Failover)</title>
  <para>
   La gestion des incidents de connexion est laissée à l'utilisateur. L'application
   est responsable de la vérification des valeurs de retour des fonctions concernant
   les bases de données, et doit réagir en cas de detection d'erreur. Par exemple, si le
   plugin reconnait une requête de type lecture-seule  et l'aiguille vers un serveur esclave
   dont la connexion n'est pas disponible, il renverra une erreur.
  </para>
  <para>
   C'est à l'application de gérer l'erreur, et, si besoin, de re-présenter la requête
   afin qu'elle soit re-prise en charge par le plugin et aiguillée vers un autre serveur.
   Le plugin ne se charge pas de ça lui-même, car il pourrait risquer d'impacter l'état des
   connexions, ce qui n'est pas du tout désirable. Par exemple, l'application peut avoir
   envoyé une requête comportant des variables de session MySQL, celles-ci sont
   dépendantes de la connexion utilisée. Une telle requête ne pourrait donc être
   prise en charge par un mécanisme automatique implémenté dans le plugin.
   L'application doit donc gérer ces cas-là, et aucune gestion des incidents de connexion
   n'est implémentée à l'intérieur du plugin.
  </para>
  <para>
   Un utilisateur ne changeant pas le statut d'une connexion après l'avoir ouverte peut activer
   la gestion des incidents pour le maitre. 
  </para>
  <para>
   Cette gestion des incidents se configure dans le fichier de configuration du plugin au moyen
   de la directive
   <literal><link linkend="ini.mysqlnd-ms-plugin-config-v2.failover">failover</link></literal>.
  </para>
  <para>
   Un exemple d'échec manuel est fourni dans la section sur les
   <link linkend="mysqlnd-ms.errorhandling">gestionnaires d'erreurs</link>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.loadbalancing">
  <title>Répartition de charge</title>
  <para>
   Il existe quatre stratégies pour distribuer les requêtes de lecture-seule
   sur les esclaves configurés:
  </para>
  <para>
   <variablelist>
    <varlistentry>
     <term>random</term>
     <listitem>
      <para>
       Choix effectué au hasard, à chaque requête.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>random once (défaut)</term>
     <listitem>
      <para>
       Choix effectué au hasard à la première requête, puis garde
       ce serveur pour les requêtes suivantes.
      </para>
      <para>
       C'est le choix par défaut et le moins impactant concernant l'état
       des connexions.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>round robin</term>
     <listitem>
      <para>
       Itère sur la liste des serveurs déclarés.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Utilisateur : via une callback</term>
     <listitem>
      <para>
       Utilisé pour implémenté une stratégie personnalisée.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   L'équilibrage de charge est configuré via les fichiers de configuration
   au moyen des valeurs
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter_random">random</link>,
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter_roundrobin">roundrobin</link>,
   and <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter_user">user</link>
   <link linkend="mysqlnd-ms.filter">filters</link>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.rwsplit">
  <title>Séparation des lectures et écritures</title>
  <para>
   Le plugin envoie les requêtes de type lecture seule sur un des esclaves de réplication
   configurés, et les autres requêtes sur le maitre. Les requêtes sont considérées de type
   lecture seule si elle commencent par <literal>SELECT</literal>, si elles comportent
   l'astuce SQL <literal>/*ms=slave*/</literal> ou si un esclave a été choisi lors de la
   dernière requête et que l'astuce SQL <literal>/*ms=last_used*/</literal> est employée.
   Dans tous les autres cas, la requête sera aiguillée vers le serveur maitre. Il est
   recommandé d'utiliser les constantes <constant>MYSQLND_MS_SLAVE_SWITCH</constant>,
   <constant>MYSQLND_MS_MASTER_SWITCH</constant> et <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>
   au lieu de <literal>/*ms=slave*/</literal>. Reportez-vous à
   <link linkend="mysqlnd-ms.constants">la liste des constantes mysqlnd_ms</link>.
  </para>  
  <para>
   Les astuces SQL représentent des commentaires SQL spéciaux. Le plugin vérifie toutes les
   requêtes à la recherche de telles astuces. Les astuces SQL sont décrites dans les
   <link linkend="mysqlnd-ms.constants">constantes mysqlnd_ms</link> exportées par l'extension. Les
   autres organes éventuellement présents dans le mécanisme de réplication (serveur MySQL,
   firewalls SQL ou proxies SQL) ne sont pas affectés par les astuces SQL car ils sont sensés
   ignorer les commentaires SQL.
  </para>
  <para>
   L'implémentation interne du séparateur de requêtes lecture/écriture peut être remplacée
   par un filtre utilisateur, voyez le filtre
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter_user"><literal>user</literal></link>.
  </para>
  <para>
   Une implémentation personnalisée du séparateur de requêtes lecture/écriture peut demander
   au plugin où envoyer la requête, en appelant <function>mysqlnd_ms_is_select</function>.
  </para>
  <note>
   <para>
    Le séparateur de requêtes lecture/écriture interne ne gère pas les requêtes multiples qui
    sont vues comme une seule requête. Le séparateur va vérifier le début de la requête pour savoir
    vers quel serveur l'envoyer. Si, par exemple, une requête multiple commence par
    <literal>SELECT 1 FROM DUAL; INSERT INTO test(id) VALUES (1); ...</literal>
    le plugin l'enverra vers un esclave, alors que cette requête n'est pas de type lecture seule.
   </para>
  </note> 
 </section>
 
 <section xml:id="mysqlnd-ms.filter">
  <title>Les filtres</title>
  <note>
   <title>Version requise</title>
   <para>
    Les filtres existent depuis mysqlnd_ms version 1.1.0-beta.
   </para>
  </note>
  <para>
   <link linkend="mysqlnd-ms.plugin-ini-json">Filtres</link>.
   Toutes les applications PHP utilisant un type de cluster de réplication MySQL
   ont besoin d'abord d'identifier un groupe de serveurs dans le cluster qui pourront
   exécuter une requête donnée avant que la requête ne soit exécutée sur un
   des candidats. En d'autres termes, une liste donnée de serveurs doit être filtrée
   pour n'en faire sortir qu'un.
  </para>
  <para>
   Le processus de filtrage peut inclure l'utilisation d'un ou plusieurs filtres.
   Les filtres peuvent être chaînés. Ils sont exécutés dans l'ordre de leurs
   apparitions dans le fichier de configuration du plugin.
  </para>
  <note>
   <title>Comparaison du chainage des filtres avec les tubes (pipes)</title>
   <para>
   Le concept de chaînage des filtres peut être comparé à l'utilisation des tubes des utilitaires de ligne
   de commande d'un shell d'un système d'exploitation : un flux entrant est passé
   au processus, et transféré à la sortie. Puis, la sortie est passé comme
   entrée à la prochaine commande qui est connectée à la précédente en utilisant
   un opérateur pipe.
  </para>
  </note>
  <para>
   Les filtres suivants sont disponibles
   <itemizedlist>
    <listitem>
     <simpara>
      Filtre de balance de charge :
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">random</link>,
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">roundrobin</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre de sélection :
      <link linkend="ini.mysqlnd-ms-plugin-config-v2.filters">user</link>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  
  <note>
   <title>pick[] et les filtres</title>  
  <para>
   Les filtres <literal>random</literal> et <literal>roundrobin</literal> remplacent
   la directive de configuration
   <link linkend="ini.mysqlnd-ms-plugin-config.pick"><literal>pick[]</literal></link>
   des anciennes versions (avant mysqlnd_ms 1.1.0-beta).
   </para>
   <para>
    Le filtre <literal>user</literal> remplace la fonction
    <function>mysqlnd_ms_set_user_pick_server</function>, utilisée avant dans
    ce but.
   </para>
  </note>
  
  <para>
   Le filtre <literal>random</literal> implémente les
   stratégies random et random once. Round robin peut être configuré via le
   filtre <literal>roundrobin</literal>. La définition d'une fonction de rappel utilisateur
   peut être utilisée pour la sélection des serveurs avec le filtre
   <literal>user</literal>.
  </para>
  <para>
   Les filtres peuvent accepter des paramètres pour changer leurs comportements.
   Le filtre <literal>random</literal> accepte un paramètre optionnel
   <literal>sticky</literal>. Si définit à &true;, le filtre modifie la balance
   de charge de random à random once. Random sélectionne un serveur aléatoirement
   à chaque fois qu'une requête est exécutée. Random once sélectionne un serveur
   aléatoirement lors de la première requête et le ré-utilise pour toutes les
   autres requêtes PHP.
  </para>
  <para>
   Une des plus grosses particularités des filtres est la possibilité de
   chaîner les filtres. La puissance de ce concept n'est pas immédiatement
   visible avec les filtres fournis par la version 1.1.0-beta car tous les
   filtres ci-dessous sont supposés sortir pas plus d'un serveur. Si un
   filtre réduit la liste des candidats pour l'exécution d'une requête
   sur un seul serveur, il prend un sens limité en utilisant un serveur
   comme sortie pour les autres filtres pour une réduction future
   de la liste des candidats.
  </para>
  <para>
   Une séquence de filtre qui va échouer:
   <itemizedlist>
    <listitem>
     <simpara>
      Requête à exécuter : <literal>SELECT 1 FROM DUAL</literal>.
      Passé à tous les filtres.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Tous les noeuds configurés sont passés comme entrée au premier filtre.
      Nœuds maîtres : <literal>master_0</literal>.
      Nœuds esclaves : <literal>slave_0</literal>, <literal>slave_1</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre : <literal>random</literal>, argument <literal>sticky=1</literal>.
      Sélectionne un esclave aléatoire à utiliser pour le reste des requêtes PHP.
      Sortie : <literal>slave_0</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Sortie de <literal>slave_0</literal> et la requête à exécuter
      est passée comme entrée pour le prochain filtre. Ici : <literal>roundrobin</literal>,
      liste de serveurs passé au filtre est : <literal>slave_0</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre : <literal>roundrobin</literal>. La liste des serveurs consiste
      en un seul serveur, round robin retourne toujours le même serveur.
     </simpara>
    </listitem>
   </itemizedlist>
   Si vous tentez d'utiliser de telles séquences de filtres, le plugin
   peut émettre une alerte comme <literal>(mysqlnd_ms) Error while creating
   filter '%s' . Non-multi filter '%s' already created. Stopping in %s on
   line %d</literal>. Par la suite, une erreur appropriée sur le gestionnaire
   de connexion devrait être définie.
  </para>
  <note>
   <title>Spéculation sur le futur: Filtres de réplication MySQL</title>
  <para>
   Dans les futures versions, il devrait avoir des filtres qui retournent
   plus d'un candidat pour l'exécution des requêtes. Par exemple, il devrait
   exister un filtre <literal>table</literal> pour supporter le filtrage
   de réplication MySQL. Le filtre de réplication MySQL vous autorise de définir
   des règles où la base de données ou la table sera répliquée vers un noeud
   précis d'un cluster de réplication. Supposons que votre cluster de
   réplication consiste en 4 esclaves (<literal>slave_0</literal>, <literal>slave_1</literal>,
   <literal>slave_2</literal>, <literal>slave_3</literal>), 2 d'entre eux répliquent
   une base de données nommée <literal>sales</literal> (<literal>slave_0</literal>,
   <literal>slave_1</literal>). Si l'application requête la base de données
   <literal>slaves</literal>, l'hypothétique filtre <literal>table</literal>
   réduit la liste des serveurs possibles à <literal>slave_0</literal>,
   <literal>slave_1</literal>. En raison du fait que la sortie et que la liste
   des serveurs candidats contient plus d'un serveur, il est nécessaire et possible
   aux futures filtres de filtrer la liste des candidats, par exemple,
   en utilisant le filtre de balance de charge pour identifier un serveur
   pour l'exécution de la requête.
  </para>
  </note>
  <para>
   Une séquence de filtres hypothétiques, supposant l'existence d'un filtre
   <literal>table</literal> pour supporter le filtrage de la réplication MySQL
   (partitionnement côté client).
   <itemizedlist>
    <listitem>
     <simpara>
      Requête à exécuter : <literal>SELECT col FROM sales.reports</literal>.
      Passé à tous les filtres.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Tous les noeuds configurés sont passés comme entrée au premier filtre.
      Noeud maître : <literal>master_0</literal>.
      Noeuds esclave : <literal>slave_0</literal>, <literal>slave_1</literal>,
      <literal>slave_2</literal>, <literal>slave_3</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre : <literal>table</literal>, jeu de règles pour la base de données
      <literal>sales</literal>.
      Sortie : <literal>slave_0</literal>, <literal>slave_1</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Sortie de <literal>slave_0</literal>, <literal>slave_1</literal>
      et la requête à exécuter est passée comme entrée au prochain
      filtre, qui est <literal>roundrobin</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Filtre : <literal>roundrobin</literal>. La liste de serveurs 
      est composée de 2 serveurs. Round robin sélectionne <literal>slave_0</literal>.
      Après l'exécution de la sous-séquence, si la même liste de serveurs
      est fournie en tant qu'entrée, le filtre retournera <literal>slave_1</literal>
      suivi par <literal>slave_0</literal>, <literal>slave_1</literal>,
      <literal>slave_0</literal> et ainsi de suite.
     </simpara>
    </listitem>
   </itemizedlist>
   <note>
    <para>
     L'exemple a été conçu pour illustrer la puissance du concept
     des filtres. Il ne fait aucune promesse quant aux futures fonctionnalités.
    </para>
   </note>
  </para>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
