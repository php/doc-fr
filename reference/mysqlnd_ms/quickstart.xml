<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 708c4884f2400b7f788b728ea2fa73ea8aa789bb Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-ms.quickstart" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Exemples et démarrage rapide</title>
 <para>
  Le plugin d'équilibrage de charge mysqlnd est simple d'utilisation.
  Le guide de démarrage rapide va présenter des cas d'utilisation classiques et donner
  des exemples pratiques. 
 </para>
 <para>
  Il est fortement recommandé de lire le manuel de référence en plus du guide de
  démarrage rapide. Le guide évite de parler des limites et des aspects théoriques.
  Avant d'utiliser le plugin dans des cas critiques, veillez à bien lire les autres
  sections. 
 </para>
 <para>
  Le but ici est d'expliquer l'utilisation de mysqlnd_ms avec un cluster MySQL asynchrone,
  aussi appelé réplication MySQL. En règle général, un cluster asynchrone est plus
  complexe qu'un cluster synchrone, ainsi, les utilisateurs de MySQL Cluster par exemple,
  trouveront ici plus d'informations que nécessaire.
 </para>
 <section xml:id="mysqlnd-ms.quickstart.configuration">
  <title>Configuration</title>
  <para>
   Le plugin est une extension PHP. Veuillez lire
   <link linkend="mysqlnd-ms.installation">les instructions d'installation</link> pour
   installer l'extension
   <link xlink:href="&url.pecl.package;mysqlnd_ms">PECL/mysqlnd_ms</link>.
  </para>
  <para>
   Configurez une extension PHP pour MySQL (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) au choix pour profiter du support
   de <link linkend="book.mysqlnd">mysqlnd</link>. PECL/mysqlnd_ms
   est un plugin pour mysqlnd. Pour l'utiliser avec une extension PHP pour MySQL,
   celle-ci devra faire usage de mysqlnd.
  </para>
  <para>
   Ensuite, chargez l'extension dans PHP et activez le plugin en utilisant la directive
   de configuration <link linkend="ini.mysqlnd-ms.enable">mysqlnd_ms.enable</link>. 
  </para>
  <para>
   <example>
    <title>Activer le plugin (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Le plugin utilise son propre fichier de configuration. Utilisez la directive
   <link linkend="ini.mysqlnd-ms.config-file">mysqlnd_ms.config_file</link>
   pour indiquer le chemin complet vers le fichier de configuration du plugin.
   Ce fichier doit être accessible en lecture à PHP (e.g. l'utilisateur
   exécutant le serveur web). Veuillez noter que la directive de configuration
   <link linkend="ini.mysqlnd-ms.config-file">mysqlnd_ms.config_file</link>
   annule et remplace la directive
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link> depuis
   la version 1.4.0. C'est une erreur courante que d'utiliser l'ancienne,
   alors qu'elle n'est plus disponible comme directive de configuration.
  </para>
  <para>
   Créez un fichier de configuration pour le plugin. Indiquez son chemin complet dans
   <link linkend="ini.mysqlnd-ms.config-file">mysqlnd_ms.config_file</link>.
  </para>
  <para>
   Les <link linkend="mysqlnd-ms.plugin-ini-json">fichiers de configuration</link>
   sont décrits en <acronym>JSON</acronym>. Il existe dedans une ou plusieurs sections.
   Chaque section a un nom, par exemple, <literal>myapp</literal>. Chaque section comporte
   ses directives.
  </para>
  <para>
   Une section doit au minimum indiquer le serveur maitre de réplication MySQL
   et une liste d'esclaves. Le plugin ne supporte qu'un seul maitre par section.
   Le multi-maitre n'est pas encore pleinement supporté. Utilisez la directive
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.master">master</link>
   pour indiquer l'hote et le port ou le socket du serveur MySQL maitre.
   Les escalves MySQL sont indiqués via la directive
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.slave">slave</link>.
  </para>
  <para>
   <example>
    <title>Configuration minimale du plugin (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": [

        ]
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Une liste d'esclaves MySQL est obligatoire, même si celle-ci est vide.
   Il est recommandé de toujours posséder au moins un esclave.
  </para>
  <para>
   Les listes de serveurs peuvent utiliser <link linkend="mysqlnd-ms.plugin-ini-json.server-list-syntax">
   les syntaxes anonyme ou non-anonyme</link>. Les listes non-anonymes incluent un alias
   pour le nom du serveur, comme <literal>master_0</literal> pour un maitre.
   Le guide de démarrage rapide utilise la syntaxe non-anonyme.
  </para>
  <para>
   <example>
    <title>Configuration minimale recommandée pour le plugin (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   S'il existe au moins deux serveurs déclarés en configuration, le plugin peut commencer
   à équilibrer la charge entre les connexions. La bascule entre les connexions n'est
   pas tout le temps transparente et peut générer des problèmes. Voyez les références sur
   <link linkend="mysqlnd-ms.pooling">les pools de connexions et les bascules</link>,
   <link linkend="mysqlnd-ms.transaction">la gestion des transactions</link>,
   <link linkend="mysqlnd-ms.failover">la reprise sur incident</link> 
   <link linkend="mysqlnd-ms.loadbalancing">l'équilibre de la charge</link> et 
   <link linkend="mysqlnd-ms.rwsplit">la découpe des lectures-écritures</link> pour les détails.
   Vous pouvez désormais continuer de lire ce guide de démarrage. Les astuces
   et problèmes éventuels du plugin vont être détaillées par la suite.
  </para>
  <para>   
   Il est de la responsabilité de l'application de gérer les éventuels problèmes dûs à
   la bascule entre les connexions. En configurant au moins un maitre et un esclave,
   vous vous assurez que le plugin basculera les connexions, et vous détecterez les
   problèmes plus tôt.
  </para>
  <para>
   Les serveurs maitre et esclave que vous configurez peuvent être la même machine.
   Cela peut aider à détecter les erreurs dûes à la bascule entre les connexions,
   mais pas les erreurs dûes à la latence de la réplication. 
  </para>
  <para>
   <example>
    <title>Utiliser un seul serveur comme maitre et esclave (test seulement!)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Le plugin tente de vous notifier des configurations invalides. Depuis la version 1.5.0,
   il va émettre une alerte lors du démarrage de PHP si le fichier de configuration ne peut
   être lu, s'il est vide, ou si l'analyse JSON échoue. Suivant votre configuration de PHP,
   ces erreurs peuvent apparaître seulement dans des fichiers de log. Une autre validation
   est effectuée lorsqu'une connexion est établie et que le fichier de configuration est
   analysé pour y rechercher des sections valides. Le fait de définir la directive
   <link linkend="ini.mysqlnd-ms.force-config-usage">mysqlnd_ms.force_config_usage</link>
   peut vous aider à déboguer une configuration erronée. Voir aussi les
   <link linkend="mysqlnd-ms.plugin-ini-json.debug_config">notes relatives au débogage
    du fichier de configuration</link>.
  </para>
  
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.usage">
  <title>Exécuter des requêtes</title>
  <para>
   Le plugin peut être utilisé avec n'importe quelle extension PHP pour MySQL 
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link> et
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) 
   compilée avec le support <link linkend="book.mysqlnd">mysqlnd</link>.
   <literal>PECL/mysqlnd_ms</literal> se branche sur la bibliothèque <link linkend="book.mysqlnd">mysqlnd</link>.
   Ceci ne change pas les API des extensions de PHP pour MySQL.
  </para>
  <para>
   Dès lors qu'une connexion à MySQL est ouverte, le plugin compare l'hôte aux sections
   déclarées dans le fichier de configuration. Par exemple une section
   <literal>myapp</literal> sera chargée si une connexion MySQL à l'hôte
   <literal>myapp</literal> est effectuée.
  </para>
  <para>
   <example>
    <title>Fichier de configuration du plugin (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Ouvrir une connexion sujette à équilibrage</title>
    <programlisting role="php">
<![CDATA[
<?php
/* La section "myapp" du fichier de configuration du plugin sera chargée */
$mysqli = new mysqli("myapp", "username", "password", "database");
$pdo = new PDO('mysql:host=myapp;dbname=database', 'username', 'password');
$mysql = mysql_connect("myapp", "username", "password");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Les connexions ouvertes dans l'exemple ci-dessus seront équilibrées en charge. Le plugin
   enverra les requêtes en lecture au serveur ayant l'IP <literal>192.168.2.27</literal>
   sur le port<literal>3306</literal>. Toutes les autres requêtes seront dirigées vers
   l'hôte maitre à <literal>localhost</literal> sur son socket
   <literal>/tmp/mysql.sock</literal>. Le plugin utilisera le nom
   <literal>username</literal> et le mot de passe <literal>password</literal> pour se
   connecter à tout hôte déclaré dans la section <literal>myapp</literal>.
   Une fois connecté, le plugin va sélectionner <literal>database</literal> comme nom
   de base de données.
  </para>
  <para>
   Les nom d'utilisateur, mot de passe et nom de base sont issus des appels à l'API pour
   la connexion et sont utilisés pour tous les serveurs. En d'autres termes, vous devez utiliser
   les mêmes nom d'utilisateur et mot de passe pour tous les serveurs listés dans une section
   de configuration. Ce n'est pas une limite globale. Depuis <literal>PECL/mysqlnd_ms</literal> 1.1.0,
   il est possible d'utiliser un
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">nom d'utilisateur</link>
   et un 
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">mot de passe</link>
   pour chaque serveur listé dans le fichier de configuration.
  </para>
  <para>
   Le plugin ne change pas l'API pour les requêtes en cours.
   <link linkend="mysqlnd-ms.rwsplit">la découpe des lectures-écritures</link>
   fonctionne par défaut. L'exemple suivant suppose qu'il y a peu de latence entre le
   maitre et l'esclave.
  </para>
  <para>
   <example>
    <title>Exécuter des requêtes</title>
    <programlisting role="php">
<![CDATA[
<?php
/* Equilibré selon la section "myapp" du fichier de configuration du plugin */
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno()) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Requêtes lancées sur le maitre */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* lecture seule: requêtes lancées sur un esclave */
if (!($res = $mysqli->query("SELECT id FROM test")) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
    $row = $res->fetch_assoc();
    $res->close();
    printf("Slave returns id = '%s'\n", $row['id']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Slave returns id = '1'
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.connectionpooling">
  <title>État de la connexion</title>
  <para>
   Le plugin change la sémantique d'une connexion MySQL pour PHP. Une connexion n'est
   plus liée à un serveur MySQL unique, mais à un pool de connexions. Le pool est
   représenté par au moins une connexion maitre et zéro ou plusieurs connexions esclaves.
  </para>
  <para>
   Chaque connexion dans le pool possède son propre état.Par exemple, les variables SQL
   utilisateurs, les tables temporaires et les transactions font partie de l'état.
   Voyez la liste complète dans
   <link linkend="mysqlnd-ms.pooling">pools de connexions et bascule</link>.
   Si le plugin décide de basculer de connexion pour l'équilibre de la charge, l'application
   pourrait se retrouver avec des connexions d'états différents. Les applications doivent
   faire attention à ce point.
  </para>
  <para>
   <example>
    <title>Config du plugin avec un maitre et un esclave</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Problème possible : État de la connexion et variables SQL utilisateurs</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Connexion 1, la connexion a utilisé des variables SQL, pas de SELECT, donc maitre utilisé */
if (!$mysqli->query("SET @myrole='master'")) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connexion 2, sur un esclave car de type SELECT */
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
    $row = $res->fetch_assoc();
    $res->close();
    printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
@myrole = ''
]]>
    </screen>
   </example>
  </para>
  <para>
   L'exemple ouvre une conneXion équilibrée et exécute deux requêtes. La première
   <literal>SET @myrole='master'</literal> n'est pas de type <literal>SELECT</literal>,
   elle est donc exécutée sur une connexion à un maitre (ici il n'y en a qu'un seul).
   La requête change une variable SQL qui est donc liée à la connexion. L'état de
   la connexion au maitre vient donc de changer.
  </para>
  <para>
   La requête suivante, <literal>SELECT @myrole AS _role</literal> est lancée sur un
   esclave car elle est de type lecture seule (select). La connexion à l'esclave ne possède
   elle, aucune variable SQL affectée, son état est donc différent de celui de la
   connexion au maitre. Le script affiche donc en réponse
   <literal>@myrole = ''</literal>.
  </para>
  <para>
   Il est de la responsabilité du développeur de l'application de prendre garde aux états 
   des connexions balancées. Le plugin ne surveille pas toutes les activités des connexions,
   ceci serait beaucoup trop couteux en temps CPU.
  </para>
  <para>
   Ces problèmes peuvent être contournés grâce aux astuces SQL.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.sqlhints">
  <title>Astuces SQL</title>
  <para>
   Les astuces SQL peuvent être utilisées pour forcer le plugin à choisir un serveur particulier
   dans le pool. Ceci peut aider à palier aux problèmes de bascule entre les connexions
   oude changement d'état des connexions.
  </para>
  <para>
   Les astuces SQL sont des commentaires de la syntaxe SQL. Comme ils sont supposés être ignorés,
   ils n'interfèrent pas avec les serveurs MySQL, le proxy MySQL ou même un pare-feu.
  </para>
  <para>
   Trois astuces SQL sont supportées par le plugin : 
   <constant>MYSQLND_MS_MASTER_SWITCH</constant> indique au plugin d'exécuter une
   requête sur le maitre, <constant>MYSQLND_MS_SLAVE_SWITCH</constant> force
   l'utilisation de l'esclave et <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>
   exécutera la requête sur le même serveur que celui utilisé pour exécuter la
   requête précédente.
  </para>
  <para>
   Le plugin scanne le début de la requête pour rechercher une astuce SQL en commentaires.
   Les astuces SQL ne doivent être écrites qu'au début d'une requête pour être
   reconnues.
  </para>
  <para>
   <example>
    <title>Configuration du plugin avec un esclave et un maitre</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Astuces SQL pour éviter les bascules de connexion</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno()) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Connexion 1, la connexion a utilisé des variables SQL, pas de SELECT, donc maitre utilisé */
if (!$mysqli->query("SET @myrole='master'")) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connexion 1, exécutée sur le maitre à cause de l'astuce SQL présente */
if (!($res = $mysqli->query(sprintf("/*%s*/SELECT @myrole AS _role", MYSQLND_MS_LAST_USED_SWITCH)))) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
    $row = $res->fetch_assoc();
    $res->close();
    printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
@myrole = 'master'
]]>
    </screen>
   </example>
  </para>
  <para>
   Dans l'exemple ci-dessus, <constant>MYSQLND_MS_LAST_USED_SWITCH</constant> est utilisée
   pour éviter la bascule du maitre vers un esclave lors de l'exécution de la requête <literal>SELECT</literal>.
  </para>
  <para>
   Les astuces SQL peuvent aussi être utilisée pour lancer une requête <literal>SELECT</literal>
   sur le maitre. Par exemple, lorsque les esclaves sont derrière le maitre et que vous
   voulez selectionner des données fraiches.
  </para>
  <para>
   En version 1.2.0 le concept d'un niveau de service a été ajouté pour faire face aux cas
   où les données courantes sont demandées. Utiliser un niveau de service requiert moins
   d'attention et les astuce SQL ne sont plus obligatoires. Voyez les sections plus bas pour
   plus d'informations.
  </para>
  <para>
   <example>
    <title>Latence de réplication</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Force l'utilisation du maitre, le maitre a toujours des données fraiches */
if (!$mysqli->query(sprintf("/*%s*/SELECT critical_data FROM important_table", MYSQLND_MS_MASTER_SWITCH))) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
]]>
    </programlisting>    
   </example>
  </para>
  <para>
   Autre exemple concrêt : créer des tables sur un esclave. Si aucune astuce SQL n'est fournie,
   le plugin va envoyer les <literal>CREATE</literal> et <literal>INSERT</literal>
   vers le maitre. L'astuce <constant>MYSQLND_MS_SLAVE_SWITCH</constant> peut alors être
   utilisée pour forcer l'utilisation d'un esclave.
  </para>
  <para>
   <example>
    <title>Création de table sur un esclave</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}


/* Force l'utilisation d'un esclave */
if (!$mysqli->query(sprintf("/*%s*/CREATE TABLE slave_reporting(id INT)", MYSQLND_MS_SLAVE_SWITCH))) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Continue en utilisant cette connexion à l'esclave */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO slave_reporting(id) VALUES (1), (2), (3)", MYSQLND_MS_LAST_USED_SWITCH))) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* N'utilisez pas MYSQLND_MS_SLAVE_SWITCH qui autoriserait la bascule vers un autre esclave ! */
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM slave_reporting", MYSQLND_MS_LAST_USED_SWITCH))) {
    $row = $res->fetch_assoc();
    $res->close();
    printf("There are %d rows in the table 'slave_reporting'", $row['_num']);
} else {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
$mysqli->close();
?>
]]>
    </programlisting>    
   </example>
  </para>
  <para>
   L'astuce SQL <constant>MYSQLND_MS_LAST_USED</constant> interdit la bascule de connexion
   et force l'utilisation de la connexion de la requête précédente.   
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.transactions">
  <title>Transactions locales</title>
  <para>
   La version actuelle du plugin ne gère pas les transactions de façon sûre par
   défaut, car il n'est pas sûre d'exécuter des transactions dans tous les cas.
   Les transactions SQL sont des opérations atomiques exécutées sur un seul et
   même serveur. Le plugin ne sait pas toujours quand l'opération atomique commence
   et quand elle prend fin. Ainsi, il peut décider de basculer de connexion au milieu
   d'une transaction.
  </para>
  <para>
   Aucun type de balance de charge MySQL peut détecter les limites d'une
   transaction sans avoir d'astuce au sein de l'application.
  </para>
  <para>
   Vous devez utiliser des astuces SQL pour éviter un tel comportement, ou activer la
   surveillance des appels de transaction à l'API. Dans ce cas, vous devez utiliser des appels
   à l'API pour contrôler les transactions, voyez ci-après.
  </para>
  <para>
   <example>
    <title>Configuration du plugin avec un esclave et un maitre</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Utilisation des astuces SQL pour les transactions</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}
  
/* Pas un SELECT, utilisera le maitre */
if (!$mysqli->query("START TRANSACTION")) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure */
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Empêche le changement de connexion! */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO test(id) VALUES (1)", MYSQLND_MS_LAST_USED_SWITCH)))) { 
    /* Utilisez un ROLLBACK dans votre code, pas juste un die() */
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM test", MYSQLND_MS_LAST_USED_SWITCH)))) {
    $row = $res->fetch_assoc();
    $res->close();
    if ($row['_num'] > 1000) {
        if (!$mysqli->query(sprintf("/*%s*/INSERT INTO events(task) VALUES ('cleanup')", MYSQLND_MS_LAST_USED_SWITCH))) {
            die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
        }
    }
} else {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/UPDATE log SET last_update = NOW()", MYSQLND_MS_LAST_USED_SWITCH)))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/COMMIT", MYSQLND_MS_LAST_USED_SWITCH)))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Depuis PHP 5.4.0 la bibliothèque <literal>mysqlnd</literal> permet au plugin de
   surveiller le statut de l'<literal>autocommit</literal>, si celui-ci est utilisé via
   des appels à l'API plutot que via une requête du type <literal>SET AUTOCOMMIT=0</literal>.
   Ceci rend le plugin sensible et réactif aux transactions. Dans ce cas,
   vous n'avez pas besoin d'utiliser d'astuces SQL.
  </para>
  <para>
   Si vous utilisez PHP 5.4.0, les appels de l'API pour gérer l'<literal>autocommit</literal>
   et le paramètre
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness"><literal>trx_stickiness=master</literal></link>
   permettent au plugin de désactiver l'équilibrage de charge et la bascule entre les
   connexions si <literal>autocommit</literal> est désactivé, et de diriger les requêtes vers
   le maitre. Ceci évite la bascule de connexion au milieu d'une transaction. Une fois que
   <literal>autocommit</literal> est réactivé, le plugin reprend l'équilibrage de charge.
  </para>
  <para>
   La détecttion des limites d'une transaction en se basant que l'API a été améliorée
   avec PHP 5.5.0 et <literal>PECL/mysqlnd_ms</literal> 1.5.0 pour couvrir non seulement les appels à
   <function>mysqli_autocommit</function> mais aussi à <function>mysqli_begin</function>,
    <function>mysqli_commit</function> et <function>mysqli_rollback</function>.
  </para>
  <para>
   <example>
    <title>Le paramètre trx_stickiness</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "trx_stickiness": "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Gestion propre des transactions</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Evidemment, votre propre gestion des erreurs serait meilleure... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Désactive autocommit, le plugin utilisera le maitre pour toutes les requêtes */
$mysqli->autocommit(FALSE);

if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) { 
    /* Utilisez un ROLLBACK dans votre code, pas juste un die() */
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($res = $mysqli->query("SELECT COUNT(*) AS _num FROM test")) {
    $row = $res->fetch_assoc();
    $res->close();
    if ($row['_num'] > 1000) {
        if (!$mysqli->query("INSERT INTO events(task) VALUES ('cleanup')")) {
            die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
        }
    }
} else {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query("UPDATE log SET last_update = NOW()")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->commit()) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Le plugin sait que la trasaction est terminée, il reprend l'équilibrage de charge */
$mysqli->autocommit(TRUE);
$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <note>
   <title>Versions requises</title>
   <para>
    La directive de configuration du plugin
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness=master</link>
    requiert PHP 5.4.0 ou plus récent.
   </para>
  </note>
  <para>
   Veuillez également prendre en compte les restrictions abordées dans la section
   sur les concepts de <link linkend="mysqlnd-ms.transaction">gestion des transactions</link>.
  </para>
 </section>

 <section xml:id="mysqlnd-ms.quickstart.xa_transactions">
  <title>Transactions distribuées / XA</title>
  <note>
   <title>Requis pour la version</title>
   <para>
    Les fonctions relatives à XA ont été introduites en
    PECL mysqlnd_ms version 1.6.0-alpha.
   </para>
  </note>
  <note>
   <title>Béta-testeur</title>
   <para>
    Cette fonctionnalité est actuellement en cours de développement.
    Il peut y avoir des bogues ou des limitations dans les fonctionnalités.
    Ne pas utiliser en environnement de production, malgré tout,
    les premiers tests indiquent une qualité raisonnable.
   </para>
   <para>
    Veuillez contacter le groupe de développement si vous êtes intéressé
    par cette fonctionnalité. Nous sommes à la recherche de retour de
    véritables environnements pour compléter cette fonctionnalité.
   </para>
  </note>
  <para>
   Les transactions XA sont des méthodes standardisées pour l'exécution
   de transactions via plusieurs ressources. Ces ressources peuvent êre
   des bases de données ou tout autre système transactionnel. Le serveur
   MySQL supporte les requêtes SQL XA qui permettent aux utilisateurs
   de mener à bien une transaction distribuée SQL qui touchent plusieurs
   serveurs de base de données ou tout autre système supportant les requêtes
   SQL. Dans un tel cas, il en est de la responsabilité de l'utilisateur de
   coordonner les serveurs participants.
  </para>
  <para>
   <literal>PECL/mysqlnd_ms</literal> peut agir comme un coordinateur de transaction
   pour une transaction global (distribuée, XA) menée sur des serveurs MySQL
   seulement. Comme coordinateur de transaction, le plugin surveille tous les serveurs
   participants à la transaction globale, et envoie les requêtes SQL appropriées
   en toute transparence aux participants. Les transactions globales sont contrôlées
   avec <function>mysqlnd_ms_xa_begin</function>, <function>mysqlnd_ms_xa_commit</function>
   et <function>mysqlnd_ms_xa_rollback</function>. Les détails SQL sont cachées de
   l'application ainsi que la nécessité de suivre et coordonner les participants.
  </para>
  <para>
   <example>
    <title>Masque général pour les transactions XA</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Bien évidemment, votre gestionnaire d'erreurs est bien meilleur... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Démarre une transaction globale */
$gtrid_id = "12345";
if (!mysqlnd_ms_xa_begin($mysqli, $gtrid_id)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Exécute les requêtes comme d'habitude : XA BEGIN sera injecté lors de l'exécution de la requête */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
    /* Soit l'INSERT échoue, soit l'injection de XA BEGIN échoue */
    if ('XA' == substr($mysqli->sqlstate, 0, 2)) {
        printf("Global transaction/XA related failure, [%d] %s\n", $mysqli->errno, $mysqli->error);
    } else {
        printf("INSERT failed, [%d] %s\n", $mysqli->errno, $mysqli->error);
    }
    /* Annulation de la transaction globale */
    mysqlnd_ms_xa_rollback($mysqli, $xid);
    die("Stopping.");
}

/* Continue de mener à bien les requêtes sur les autres serveurs, i.e. les autres serveurs partagés */

/* commit the global transaction */
if (!mysqlnd_ms_xa_commit($mysqli, $xa_id)) {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Contrairement aux transactions locales, qui sont envoyées à un seul serveur,
   les transactions XA ont un identifiant (xid) associé.
   L'identifiant de transaction XA est composé d'un identifiant de transaction
   globale (gtrid), un qualificatif de branche (bqual), ainsi qu'un identifiant
   de format (formatID). Seul l'identifiant de transaction globale peut et doit
   être fourni lors de l'appel à n'importe laquelle des fonctions XA du plugin.
  </para>
  <para>
   Une fois qu'une transaction globale a commencé, le plugin commence à surveiller
   les serveurs tant que la transaction globale n'est pas terminée. Lorsqu'un
   serveur est sélectionné pour l'exécution de la requête, le plugin injecte
   la requête SQL <literal>XA BEGIN</literal> avant d'exécuter la requête
   SQL sur le serveur. <literal>XA BEGIN</literal> rend le serveur participant
   à la transaction globale. Si la requête SQL injectée échoue, le plugin
   va rapporter l'erreur dans la réponse à la fonction utilisée pour l'exécution
   de la requête. Dans l'exemple ci-dessus,
   <literal>$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")</literal>
   va indiquer une telle erreur. Vous pouvez vouloir vérifier le code statut
   des erreurs SQL pour déterminer si la requête actuelle a échoué (ici : <literal>INSERT</literal>)
   ou si l'erreur est en relation avec la transaction globale. Il vous appartient
   de choisir d'ignorer l'erreur pour commencer la transaction globale sur un
   serveur et continuer l'exécution sans que le serveur ne participe à la
   transaction globale.
  </para>
  <para>
   <example>
    <title>Les transactions locales et globales sont mutuellement exclusives</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Bien évidemment, votre gestionnaire d'erreurs est bien mieux... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Démarre une transaction locale */
if (!$mysqli->begin_transaction()) {
    die(sprintf("[%d/%s] %s\n", $mysqli->errno, $mysqli->sqlstate, $mysqli->error));
}

/* Impossible de commencer la transaction globale maintenant - on doit terminer la transaction locale d'abord */
$gtrid_id = "12345";
if (!mysqlnd_ms_xa_begin($mysqli, $gtrid_id)) {
    die(sprintf("[%d/%s] %s\n", $mysqli->errno, $mysqli->sqlstate, $mysqli->error));
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[

Warning: mysqlnd_ms_xa_begin(): (mysqlnd_ms) Some work is done outside global transaction. You must end the active local transaction first in ... on line ...
[1400/XAE09] (mysqlnd_ms) Some work is done outside global transaction. You must end the active local transaction first
]]>
    </screen>
   </example>
  </para>
  <para>
   Une transaction globale ne peut être démarrée lorsqu'une transaction locale
   est active. Le plugin tente de détecter cette situation au plus tôt, i.e.
   lors de l'appel à la fonction <function>mysqlnd_ms_xa_begin</function>.
   Si vous utilisez uniquement des appels API pour contrôler les transactions, le
   plugin va savoir qu'une transaction locale est ouverte, et va retourner une
   erreur pour <function>mysqlnd_ms_xa_begin</function>. Cependant, notez
   les <link linkend="mysqlnd-ms.transaction">limitations sur les limites des
   transactions</link>. Dans le pire des cas, si vous utilisez des requêtes SQL
   directes pour les transactions locales (<literal>BEGIN</literal>,
   <literal>COMMIT</literal>, ...), il se peut qu'une erreur ne soit relayée
   pendant que des requêtes SQL soient exécutées sur un serveur.
  </para>
  <para>
   Pour terminer une transaction globale, appelez la fonction
   <function>mysqlnd_ms_xa_commit</function> ou <function>mysqlnd_ms_xa_rollback</function>.
   Lorsqu'une transaction globale se termine, tous les participants doivent
   être informés de cette fin. Toutefois, PECL/mysqlnd_ms va envoyer les requêtes
   SQL XA appropriées sur une partie ou la totalité des participants. Toute
   erreur pendant cette phase va engendrer une annulation implicite. L'API relative
   à XA est intentionnellement simple ici. Une API plus complexe, qui donne plus de
   contrôle, aurait peu d'avantage par rapport à une implémentation utilisateur
   qui se charge lui même des requêtes SQL XA bas niveaux.
  </para>
  <para>
   Les transactions XA utilisent un protocole de validation en deux phases.
   Le protocole de validation en deux phases est un protocole bloquant.
   Il y a des cas où aucune progression ne peut avoir lieu, y compris en utilisant
   des délais maximals d'attente. Les coordinateurs de transaction doivent survivre
   à leur propre échec, être capable de détecter les blocages et de rompre des liens.
   <literal>PECL/mysqlnd_ms</literal> prend le rôle de coordinateur de transaction
   et peut être configuré pour survivre à son propre échec pour éviter des soucis
   avec les serveurs MySQL bloqués. Toutefois, le plugin peut et doit être configuré
   pour utiliser un statut persistent et résistant au crash pour permettre la collection
   des données incorrectes, et stopper les transactions globales. Une transaction globale
   peut être stoppée dans un statut ouvert si, soit le plugin échoue (crash),
   soit une connexion depuis le plugin vers un participant de la transaction globale
   échoue.
  </para>
  <para>
   <example>
    <title>Stockage du statut du coordinateur de transaction</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "xa": {
            "state_store": {
                "participant_localhost_ip": "192.168.2.12",
                "mysql": {
                    "host": "192.168.2.13",
                    "user": "root",
                    "password": "",
                    "db": "test",
                    "port": "3312",
                    "socket": null
                }
            }
        },
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.14",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Actuellement, <literal>PECL/mysqlnd_ms</literal> supporte uniquement les tables
   de base de données MySQL comme espace de stockage de statut. Les définitions
   des tables SQL sont fournies dans la
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.xa">section de configuration du plugin</link>.
   Assurez-vous d'utiliser un moteur transactionel et résistant au crash pour les
   tables, comme InnoDB. InnoDB est le moteur de table par défaut dans les versions
   récentes du serveur MySQL. Assurez-vous également que le serveur de base de données
   lui-même a une haute disponibilité.
  </para>
  <para>
   Si un stockage de statut a été configuré, le plugin peut effectuer une collection
   des données incorrectes. Pendant la collection de données incorrectes, il peut
   être nécessaire de se connecter à un participant à une transaction globale qui
   a échouée. Aussi, le stockage de staut accueille une liste des
   participants et, entre autres, leurs noms d'hôte. Si la collection de données
   incorrectes est exécutée sur un autre hôte que celui qui a été noté comme participant
   avec le nom d'hôte <literal>localhost</literal>, alors <literal>localhost</literal>
   va résoudre différentes machines. Il y a deux solutions à ce problème.
   Soit vous ne configurez aucun serveur avec le nom d'hôte <literal>localhost</literal> 
   mais configurez une adresse IP (et un port), ou, vous utilisez la collection
   de données incorrectes. Dans l'exemple ci-dessus, <literal>localhost</literal>
   est utilisé pour <literal>master_0</literal>, et va résourdre le mauvais hôte
   durant la collection des données incorrectes. Cependant, <literal>participant_localhost_ip</literal>
   est également défini pour utiliser la collection de données incorrectes où
   <literal>localhost</literal> correspond à l'IP <literal>192.168.2.12</literal>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.qos-consistency">
  <title>Niveau de service et consistence</title>
  <note>
   <title>Versions requises</title>
   <para>
    Les niveaux de services ont été ajoutés dans mysqlnd_ms version 1.2.0-alpha.
    <function>mysqlnd_ms_set_qos</function>
    est disponible pour PHP 5.4.0 ou plus récent.
   </para>
  </note>
  <para>
   Differents types de solutions de cluster MySQL offrent différents niveaux de consistence
   des données à leurs utilisateurs. Un cluster asynchrone offre une consistence éventuelle
   par défaut. Une lecture exécutée sur un esclave peut retourner une donnée fraiche, 
   dépassée, ou pas de donnée du tout en fonction de l'état d'avancement de la réplication
   de l'esclave sur le maitre.
  </para>
  <para>
   Les applications utilisant le cluster de replication MySQL doivent être conçues pour
   fonctionner avec une consistence éventuelle des données. Dans certains cas, des données
   non fraiches ne sont pas acceptables. Dans ces cas-là, seuls certains esclaves voire même
   uniquement le maitre sont autorisés pour atteindre la qualité de service nécessaire.
  </para>
  <para>
   Depuis mysqlnd_ms 1.2.0, le plugin peut sélectionner un noeud automatiquement pour assurer
   une consistence de session ou une consistence forte. La consistence de session implique
   qu'un client peut lire ses écritures, les autres clients peuvent voir ou non les écritures.
   La consistence forte assure que tous les autres clients verront les écritures.
  </para>
  <para>
   <example>
    <title>Consistence de session: lire ses écritures</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Requêtage en consistence de session</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Utilisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Séparation des lectures/écritures: maitre utilisé */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
     /* Utlisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Activation de la consistence de session */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Le plugin sélectionne un noeud qui possède le changement, ici : le maitre */
if (!$res = $mysqli->query("SELECT item FROM orders WHERE order_id = 1")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($res->fetch_assoc());

/* Retour à la consistence éventuelle : des données non fraiches sont tolérées */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Le plugin choisit un esclave, des données non fraiches peuvent être retournées */
if (!$res = $mysqli->query("SELECT item, price FROM specials")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Les niveaux de service peuvent être indiqués dans le fichier de configuration et
   durant l'exécution via <function>mysqlnd_ms_set_qos</function>.
   Dans l'exemple la fonction est utilisée pour forcer la consistence de session pour
   toutes les requêtes futures jusqu'à nouvel ordre. La requête
   <literal>SELECT</literal> sur la table <literal>orders</literal> est lancée sur le
   maitre pour s'assurer que l'écriture précédente peut être vue par le client.
   La logique de spération des lectures/écritures a donc été adaptée pour satisfaire le
   niveau de service demandé.
  </para>
  <para>
   Après que l'application n'ait lue ses changements depuis la table <literal>orders</literal>
   elle retourne dans le niveau de service par défaut, c'est-à-dire la consistence éventuelle.
   Celle-ci ne propose aucune restriction quant au choix du noeud, ainsi, la requête
   <literal>SELECT</literal> sur la table <literal>specials</literal> est exécutée sur l'esclave.
  </para>
  <para>
   Cette fonctionnalité est supérieure aux astices SQL et à l'option de configuration
   <literal>master_on_write</literal>. Dans beaucoup de cas,
   <function>mysqlnd_ms_set_qos</function> est plus facile à utiliser, plus puissante et plus
   portable.
  </para>
  <para>
   <example>
    <title>Age maximum / retard de l'esclave</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "failover" : "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Limiter le retard de l'esclave</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Utilisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Lit depuis des esclaves ayant un retard de 4 secondes maximum */
$ret = mysqlnd_ms_set_qos(
    $mysqli,
    MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
    MYSQLND_MS_QOS_OPTION_AGE,
    4
);

if (!$ret) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Le plugin sélectionne un des esclaves, qui a ou pas la donnée */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}


/* Retour au comportement par défaut : utilisation de tous les esclaves et du maitre */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Le niveau de consistence éventuelle peut utiliser un paramètre optionnel permettant
   d'indiquer l'âge maximum de retard des esclaves pour leur sélection. Ainsi,
   le plugin vérifiera <literal>SHOW SLAVE STATUS</literal> pour tous les esclaves
   configurés. Dans notre exemple, seuls les esclaves pour qui
   <literal>Slave_IO_Running=Yes</literal>,   <literal>Slave_SQL_Running=Yes</literal>
   et <literal>Seconds_Behind_Master &lt;= 4</literal> est vrai sont considérés
   dans le choix pour l'éxecution de <literal>SELECT item, price FROM daytrade</literal>.
  </para>
  <para>
   La vérification <literal>SHOW SLAVE STATUS</literal> est transparente coté application.
   Si des erreurs surviennent, elles seront reportées sous forme de Warning. Aucune erreur
   ne sera émise sur la connexion. Même si tous les <literal>SHOW SLAVE STATUS</literal>
   échouent, l'éxecution de la requête de l'utilisateur aura quand même lieu si la
   reprise sur incident du maitre est activée. Ainsi, aucun changement côté applicatif n'est
   nécessaire.
  </para>
  <note>
   <title>Opérations couteuses et lentes</title>
   <para>
    Vérifier <literal>SHOW SLAVE STATUS</literal> pour tous les esclaves ajoute de
    la charge. C'est une opération couteuse. Malheureusement, le cluster de réplication
    MySQL n'offre pas d'autre moyen de procéder pour vérifier le retard d'un esclave.
   </para>
   <para>
    Notez les limites et les propriétés de <literal>SHOW SLAVE STATUS</literal>
    en lisant le manuel de référence de MySQL.
   </para>
  </note>
  <para>
   Pour évoter que le plugin ne génère un Warning si aucun esclave satisfaisant le
   critère de retard ne peut être trouvé, il est nécessaire d'activer la reprise sur
   incident du maitre dans le fichier de configuration. Dans ce cas, le plugin sélectionnera
   un maitre.
  </para>
  <para>
   Si aucun esclave n'est trouvé et que la reprise sur incident est désactivée, le plugin
   génèrera un Warning, il n'exécutera pas la requête et placera la connexion en erreur.
  </para>
  <para>
   <example>
    <title>Reprise sur incident non activée</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Pas d'esclave avec le critère de retard</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Utilisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Lit depuis les esclaves dont le retard n'est pas supérieur à 4 secondes */
$ret = mysqlnd_ms_set_qos(
    $mysqli,
    MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
    MYSQLND_MS_QOS_OPTION_AGE,
    4
);

if (!$ret) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Le plugin choisit un esclave au hasard, il peut avoir une donnée non fraiche */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}


/* Cas par défaut: utilisation de tous les esclaves et maitres */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
PHP Warning:  mysqli::query(): (mysqlnd_ms) Couldn't find the appropriate slave connection. 0 slaves to choose from. Something is wrong in %s on line %d
PHP Warning:  mysqli::query(): (mysqlnd_ms) No connection selected by the last filter in %s on line %d
[2000] (mysqlnd_ms) No connection selected by the last filter
]]>
    </screen>
   </example>
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.gtid">
  <title>ID de transaction globale</title>
  <note>
   <title>Version requise</title>
   <para>
    L'injection d'identifiant de transaction globale côté client a été ajoutée avec
    mysqlnd_ms version 1.2.0-alpha. Ce n'est pas requis pour les clusters synchrones,
    comme MySQL Cluster. Utilisez le avec des clusters asynchrones, comme la réplication
    MySQL.
   </para>
   <para>
    Depuis la version admissible MySQL 5.6.5-m8, le serveur MySQL fournit des 
    identifiants de transaction globale. Cette fonctionnalité est supportée par 
    <literal>PECL/mysqlnd_ms</literal> 1.3.0-alpha ou supérieure. Toutefois, le jeu de 
    fonctionnalités inclus dans la version finale de MySQL 5.6 est insuffisant 
    pour supporter toutes les idées discutées ici. Veuillez vous référer à la 
    <link linkend="mysqlnd-ms.gtid">section sur les concepts</link> pour plus 
    de détails.
   </para>
  </note>
  <para>
   <literal>PECL/mysqlnd_ms</literal> peut soit utiliser sa propre émulation des identifiants
   de transaction globale, soit la fonctionnalité interne du serveur
   MySQL 5.6.5-m8 ou supérieure. D'un point de vue développeur, ces différentes
   approches offrent les mêmes fonctionnalités au niveau des niveaux de service
   fournis par PECL/mysqlnd_ms. Leurs différences sont abordées dans la
   <link linkend="mysqlnd-ms.gtid">section sur les concepts</link>.
  </para>
  <para>
   La section sur le démarrage rapide montre l'utilisation de l'émulation de l'identifiant
   de transaction globale côté client interne à <literal>PECL/mysqlnd_ms</literal> avant de montrer
   son homologue côté serveur. Cet ordre assure que l'idée originelle soit abordée
   en premier lieu.
  </para>
  <para>
   <emphasis role="bold">Idée et émulation côté client</emphasis>
  </para>
  <para>
   Dans sa forme de base, un identifiant de transaction globale (GTID) est un compteur dans
   une table sur le maitre. Le compteur est incrémenté chaque fois qu'une transaction est
   commitée sur le maitre. Les esclaves répliquent la table. Le compteur a deux rôles.
   Dans le cas d'un échec du maitre, il aide l'administrateur à identifier l'esclave le
   plus récent pour le promouvoir nouveau maitre. L'esclave le plus récent est celui qui
   possède la plus grande valeur de l'identifiant. L'application peut utiliser le GTID pour
   chercher les esclaves ayant répliqué une certaine écriture identifiée par le GTID.
  </para>
  <para>
   <literal>PECL/mysqlnd_ms</literal> peut injecter du SQL pour toute transaction comitée afin d'incrémenter le GTID.
   Le GTID est accessible par l'application pour identifier une opération d'écriture. Ceci permet
   au plugin d'assurer le niveau de service consistence de session en requêtant les esclaves qui
   ont répliqué la donnée. La charge de lecture est donc supprimée du maitre.
  </para>
  <para>
   l'émulation GTID coté client a quelques limites, lisez attentivement la
   <link linkend="mysqlnd-ms.gtid">section sur les concepts</link> pour bien comprendre les
   principes et les idées avant de l'utiliser en production.
  </para>
  <para>
   D'abord, créez une table compteur sur votre maitre et insérez-y un enregistrement. Le
   plugin ne créer pas la table. Les administrateurs doivent s'assurer qu'elle existe. En
   fonction du mode de rapport d'erreur, le plugin ignorera éventuellement silencieusement
   l'absence de table, ou s'arrêtera brusquement.
  </para>
  <para>
   <example>
    <title>Creation de la table de compteur sur le maitre</title>
    <programlisting role="sql">
<![CDATA[
CREATE TABLE `trx` (
  `trx_id` int(11) DEFAULT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO `trx`(`trx_id`) VALUES (1);
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Dans le fichier de configuration, utilisez <literal>on_commit</literal> pour insérer
   le SQL qui mettra à jour le GTID, section <literal>global_transaction_id_injection</literal>.
   Assurez vous que le nom de table pour la commande <literal>UPDATE</literal> est
   pleinement qualifié. Dans l'exemple, <literal>test.trx</literal> est utilisé pour
   faire référence à la table <literal>trx</literal> dans la base <literal>test</literal>.
   Le nom pleinement qualifié est important car la connexion sur laquelle la requête sera
   éxecutée peut changer et représenter une base différente. Assuez-vous aussi des droits de
   l'utilisateur qui ouvre la connexion pour l'éxecution de commandes <literal>UPDATE</literal>.
  </para>
  <para>
   Activez le rapport d'erreurs concernant l'injection de GTID.
  </para>
  <para>
   <example>
    <title>Plugin config: SQL pour l'injection GTID coté client</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Injection GTID transparente</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Utilisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* auto commit mode, transaction sur le maitre, GTID doit être incrémenté */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* auto commit mode, transaction sur le maitre, GTID doit être incrémenté */
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* auto commit mode, transaction sur le maitre, GTID doit être incrémenté */
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* auto commit mode, lecture sur esclave, pas d'incrémentation */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($res->fetch_assoc());
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
]]>
    </screen>
   </example>
  </para>
  <para>
   L'exemple lance 3 requêtes en mode autocommit sur le maitre, causant 3 transactions
   sur le maitre. Pour châque requête, le plugin injectera l'<literal>UPDATE</literal>
   configuré de manière transparente avant d'exécuter la requête utilisateur. Lorsque le
   script se termine, le GTID a été incrémenté de 3 sur le maitre.
  </para>
  <para>
   La 4ème requête exécutée dans l'exemple, un <literal>SELECT</literal>, ne déclenche pas
   l'incrémentation. Seules les écritures sur le maitre déclenchent l'incrémentation.
  </para>
  <note>
   <title>SQL pour GTID: Solution efficace demandée!</title>
   <para>
    Le SQL utilisé pour le GTID n'est pas efficace. Il est conçu pour être lisible, pas
    performant. Considérez une solution plus robuste et reportez-la, nous l'incluerons
    dans le manuel.
   </para>
  </note>
  <para>
   <example>
    <title>Plugin config: SQL pour récupérer le GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Obtenir le GTID après l'injection</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Utilisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* auto commit mode, transaction sur le maitre, GTID doit être incrémenté */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));

/* auto commit mode, transaction sur le maitre, GTID doit être incrémenté */
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

printf("GTID après transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
GTID après transaction 7
GTID après transaction 8
]]>
    </screen>
   </example>
  </para>
  <para>
   Les applications peuvent demander à mysqlnd_ms le GTID correspondant à la dernière
   écriture. La fonction <function>mysqlnd_ms_get_last_gtid</function> retourne le
   GTID obtenu lors de l'éxecution d'une requête SQL depuis l'entrée
   <literal>fetch_last_gtid</literal> de la section
   <literal>global_transaction_id_injection</literal> du fichier de configuration.
   La fonction doit être appelée après que le GTIF ait été incrémenté.
  </para>
  <para>
   Les applications ne doivent pas exécuter le SQL elles-mêmes car elles risquent alors
   de causer une incrémentation accidentelle du GTID. Aussi, si la fonction est utilisée,
   il est plus simple de migrer une application.
  </para>
  <para>
   Le guide de démarrage rapide montre une requête SQL qui retourne un GTID supérieur ou
   égal à celui crée pour la requête précédente. Il s'agit du GTID de la requête précédente
   si aucun client ne l'ont incrémenté entre temps jusqu'au <literal>SELECT</literal> le
   récupérant, sinon, il est plus élevé.
  </para>
  <para>
   <example>
    <title>Plugin config: Vérifier un certain GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "check_for_gtid" : "SELECT trx_id FROM test.trx WHERE trx_id >= #GTID",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Consistence de session et GTID combinés</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Utilisez ici votre propre gestion des erreurs... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* auto commit mode, transaction sur le maitre, GTID doit être incrémenté */
if (   !$mysqli->query("DROP TABLE IF EXISTS test")
    || !$mysqli->query("CREATE TABLE test(id INT)")
    || !$mysqli->query("INSERT INTO test(id) VALUES (1)")
) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* GTID comme identifiant pour la dernière écriture */
$gtid = mysqlnd_ms_get_last_gtid($mysqli);

/* Consistence de session ("lit tes écritures"): essaye de lire depuis les esclaves, pas seulement le maitre */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION, MYSQLND_MS_QOS_OPTION_GTID, $gtid)) {
    die(sprintf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Exécute sur le maitre ou un des esclaves ayant la donnée */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($res->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Un GTID retourné par <function>mysqlnd_ms_get_last_gtid</function>
   peut être utilisé comme option dans le niveau de service consistence de
   session, indiqué au moyen de <function>mysqlnd_ms_set_qos</function>.
   Dans l'exemple, le plugin exécute la requête <literal>SELECT</literal>
   soit sur le maitre, soit sur l'esclave qui possède la donnée répliquée.
  </para>
  <para>
   PECL mysqlnd_ms va vérifier de manière transparente chaque esclave configuré
   pour savoir s'il possède la donnée répliquée de l'<literal>INSERT</literal>
   au moyen de la table des GTID. La vérification utilise la requête SQL indiquée
   par l'option <literal>check_for_gtid</literal> de la section
   <literal>global_transaction_id_injection</literal> du fichier de configuration.
   Notez qu'il s'agit s'une opération lente et couteuse, les applications doivent
   l'utiliser à bon escient si la charge en lecture sur le maitre devient trop
   importante.
  </para>
  <para>
   <emphasis role="bold">Utilisation de la fonctionnalité d'identifiant de transaction globale côté serveur</emphasis>
  </para>
<note>
   <title>Support serveur insuffisant dans MySQL 5.6</title>
   <para>
    Le greffon a été développé sur la base d'une version de pre-production de 
    MySQL 5.6. Or il s'avère que les versions MySQL 5.6 publiées finalement ne 
    fournissent pas des clients avec assez d'informations pour imposer la 
    consistence des sessions basés sur les GTIDs. Veuillez vous référer à la 
    <link linkend="mysqlnd-ms.gtid">section sur les concepts</link> pour plus 
    de détails.
   </para>
  </note>
  <para>
   Depuis MySQL 5.6.5-m8, le système de réplication MySQL utilise des identifiants
   globaux de transaction côté serveur. Ces identifiants de transaction sont
   automatiquement générés et maintenus par le serveur. Les utilisateurs n'ont pas
   à s'inquiéter de les maintenir. Il n'y a besoin d'avoir des tables de disponible
   à l'avance, ou de configuration sur le <literal>on_commit</literal>. L'émulation
   côté client n'est plus nécessaire non plus.
  </para>
  <para>
   Les clients peuvent continuer d'utiliser l'identifiant de transaction globale
   dans un but de consistence des sessions lors des opérations de lecture sur
   les esclaves de réplication MySQL dans certains cas mais pas dans tous! 
   L'algorithme fonctionne tel que décrit ci-après.
   Des requêtes SQL différentes doivent être configurées pour
   <literal>fetch_last_gtid</literal> et <literal>check_for_gtid</literal>.
   Ces requêtes sont fournies ci-dessous. Notez que MySQL 5.6.5-m8 est une version
   de développement. Les détails sur l'implémentation serveur peuvent changer dans le
   futur et nécessite une adoption des requêtes SQL utilisées.
  </para>
  <para>
   En utilisant la configuration suivante, n'importe quelle fonctionnalité décrite ci-dessous
   peut être utilisée en plus de la fonctionnalité des identifiants de transaction globale
   côté serveur.
   <function>mysqlnd_ms_get_last_gtid</function> et <function>mysqlnd_ms_set_qos</function>
   continuent de fonctionner tel que décrit. La seule différente est que le serveur
   n'utilise plus qu'une simple séquence de numéro mais une chaîne contenant
   un identifiant de serveur et une séquence de numéro. Aussi, les utilisateurs ne peuvent
   plus déduire un ordre depuis les GTIDs retournés par la fonction
   <function>mysqlnd_ms_get_last_gtid</function>.
  </para>
  <para>
   <example>
    <title>Configuration du plugin : utilisation de la fonctionnalité GTID interne à MySQL 5.6.5-m8</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "fetch_last_gtid" : "SELECT @@GLOBAL.GTID_DONE AS trx_id FROM DUAL",
            "check_for_gtid" : "SELECT GTID_SUBSET('#GTID', @@GLOBAL.GTID_DONE) AS trx_id FROM DUAL",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  
 </section>
 <section xml:id="mysqlnd-ms.quickstart.cache">
  <title>Intégration du cache</title>
  <note>
   <title>Version requise, dépendances et statuts</title>
   <para>
    Vous trouverez plus d'informations quant aux versions requises, à l'ordre de chargement de
    l'extension, et aux statuts courants dans la
    <link linkend="mysqlnd-ms.concept_cache">section relatif aux concepts</link> !
   </para>
  </note>
  <para>
   Les clusters de base de données peuvent délivrer différents niveaux de consistences.
   Depuis <literal>PECL/mysqlnd_ms</literal> 1.2.0, il est possible de demander au plugin de considérer
   uniquement les noeuds de clusters qui peuvent délivrer le niveau de consistance
   requis. Par exemple, si vous utilisez un serveur de réplication MySQL asynchrone
   avec une échelle de cluster éventuellement consistent, il est possible de
   demander une session de consistence (lecture de vos écritures) à n'importe quel
   moment en utilisant la fonction <function>mysqlnd_ms_set_quos</function>.
   Veuillez également vous reportez à la section de la documentation sur
   <link linkend="mysqlnd-ms.quickstart.qos-consistency">les niveaux de service
    et de consistence</link>.
  </para>
  <para>
   <example>
    <title>Récapitulatif : qualité de service demandant de lire vos écritures</title>
    <programlisting role="php">
     /* Demande d'une session de consistence : lecture de vos écritures */
     if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
    </programlisting>
   </example>
  </para>
  <para>
   Supposons que PECL/mysqlnd a été explicitement configuré pour délivrer aucun
   niveau de consistence plus élevé que la consistence éventuelle, il est possible
   de remplacer un noeud de base de données accessible en lecture avec un cache
   côté client utilisant time-to-live (TTL), en invalidant ainsi la statégie.
   Ainsi, à la fois le noeud de base de données et le cache peuvent ou non servir
   les données courantes, sachant que c'est ce que définit la consistence éventuelle.
  </para>
  <para>
   Remplacer l'accès en lecture d'un noeud de base de données avec un accès au
   cache local peut améliorer les performances globales et baisser la charge
   de la base de données. Si l'entrée du cache est souvent réutilisée
   par d'autres clients que celui ayant créée l'entrée dans le cache, un
   accès base de données est sauvé et ainsi, la charge de la base de données
   baisse. De plus, les performances du système peuvent devenir meilleures
   sachant que le calcul et la délivrance d'une requête de base de données
   est plus lente que l'accès à un cache local.
  </para>
  <para>
   <example>
    <title>Configuration du plugin : aucune entrée spéciale pour la mise en cache</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Mise en cache d'une requête esclave</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Bien évidemment, votre gestionnaire d'erreur est meilleur... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

if (   !$mysqli->query("DROP TABLE IF EXISTS test")
    || !$mysqli->query("CREATE TABLE test(id INT)")
    || !$mysqli->query("INSERT INTO test(id) VALUES (1)")
) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Autorise explicitement la consistence éventuelle et la mise en cache (TTL <= 60 secondes) */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Pour que ceci fonctionne, nous devons juste attendre d'atteindre un esclave.
Forçons le. */

$attempts = 0;
do {
    /* Vérifie si l'esclave a la table */
    if ($res = $mysqli->query("SELECT id FROM test")) {
        break;
    } else if ($mysqli->errno) {
        die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
    }
    /* Attente d'un esclave */
    usleep(200000);
} while ($attempts++ < 10);

/* La requête va être exécutée sur un esclave, le résultat est dans le cache */
assert($res);
var_dump($res->fetch_assoc());

/* Servi depuis le cache */
$res = $mysqli->query("SELECT id FROM test");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Cet exemple montre la façon dont on doit utiliser la fonctionnalité du cache.
   Tout d'abord, vous devez définir la qualité de service à une consistence
   éventuelle et explicitement autoriser la mise en cache. Ceci est fait
   en appelant la fonction <function>mysqlnd_ms_set_qos</function>.
   Puis, le jeu de résultats de chaque requête en lecture seule est mis
   en cache pour plus de quelques secondes, tel qu'autorisé avec la fonction
   <function>mysqlnd_ms_set_qos</function>.
  </para>
  <para>
   Le TTL actuel est inférieur ou égal à la valeur définie avec la fonction
   <function>mysqlnd_ms_set_qos</function>. La valeur passée à la fonction
   définit l'âge maximal (en secondes) des données délivrées. Pour calculer
   la valeur actuelle du TTL, la latence du serveur de réplication est vérifiée
   et soustrait à la valeur fournie. Si, par exemple, l'âge maximal est défini
   à 60 secondes, et l'esclave rapporte une latence de 10 secondes, le TTL
   résultant sera de 50 secondes. Le TTL est calculé de façon individuelle
   pour chaque requête mise en cache.
  </para>
  <para>
   <example>
    <title>Lecture de vos écritures et mise en cache</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
  /* Bien évidemment, votre gestionnaire d'erreur est meilleur... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

if (   !$mysqli->query("DROP TABLE IF EXISTS test")
    || !$mysqli->query("CREATE TABLE test(id INT)")
    || !$mysqli->query("INSERT INTO test(id) VALUES (1)")
) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Autorise explicitement la consistence éventuelle et la mise en cache (TTL <= 60 secondes) */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Pour que ceci fonctionne, nous devons juste attendre d'atteindre un esclave.
Forçons le. */
$attempts = 0;
do {
    /* Vérifie si l'esclave a la table */
    if ($res = $mysqli->query("SELECT id FROM test")) {
        break;
    } else if ($mysqli->errno) {
        die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
    }
    /* Attente d'un esclave */
    usleep(200000);
} while ($attempts++ < 10);

assert($res);

/* La requête va être exécutée sur un esclave, le résultat est dans le cache */
var_dump($res->fetch_assoc());

/* Servi depuis le cache */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
var_dump($res->fetch_assoc());

/* Mise à jour sur le maître */
if (!$mysqli->query("UPDATE test SET id = 2")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Lecture de vos écritures */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Récupération des dernières données */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
var_dump($res->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La qualité de service peut être modifiée à n'importe quel moment
   pour supprimer l'utilisation du cache. Si nécessaire, vous pouvez
   le modifier pour lire vos écritures (session de consistence).
   Dans ce cas, le cache ne sera pas utilisé et les dernières données
   seront lues.
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.failover">
  <title>Failover</title>
  <para>
   Par défaut, le plugin ne tente pas de failover si la connexion vers un hôte
   échoue. Ce comportement évite des erreurs en relation avec
   <link linkend="mysqlnd-ms.quickstart.connectionpooling">le statut de la connexion</link>.
   Il est recommandé de gérer manuellement les erreurs de connexion d'une façon similaire
   à un échec d'une transaction. Vous devez capturer l'erreur, re-construire le
   statut de la connexion, et exécuter votre requête comme ci-dessous.
  </para>
  <para>
   Si le statut de connexion n'est pas important pour vous, vous pouvez
   activer le failover automatique et silencieux. Suivant la configuration,
   le failover automatique et silencieux va soit tenter, en cas d'échec de
   basculer vers le maître au lieu d'émettre une erreur, soit tenter une
   connexion avec un autre esclave, suivant si la requête l'autorise, avant
   de tenter une connexion vers le maître. En raison du fait que le
   <link linkend="mysqlnd-ms.failover">failover automatique</link> n'est pas
   encore totalement robuste, ce sujet n'est pas abordé dans le démarrage
   rapide. Au lieu de cela, les détails sont fournis dans la section
   de concepts ci-dessous.
   
   is
   not fool-proof, it is not discussed in the quickstart. Instead, details are given
   in the concepts section below.
  </para>
  <para>
   <example>
    <title>Failover manuel, optionnellement, automatique</title>
    <programlisting role="ini">
<![CDATA[
  {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
       "filters": { "roundrobin": [] }
    }
 }
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Failover manuel</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli) {
    /* Bien évidemment, votre gestionnaire d'erreur est meilleur... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

$sql = "SELECT 1 FROM DUAL";

/* Gestionnaire d'erreur tel qu'il doit être suivant le plugin */
if (!($res = $link->query($sql))) {
    /* spécifique au plugin : vérification d'une erreur de connexion */
    switch ($link->errno) {
    case 2002:
    case 2003:
    case 2005:
        printf("Erreur de connexion - Tentative sur le prochain esclave !\n");
        /* Le répartiteur de charge va prendre le prochain esclave */
        $res = $link->query($sql);
        break;
    default:
        /* Aucune erreur de connexion, failover ne va probablement pas être utile */
        die(sprintf("Erreur SQL : [%d] %s", $link->errno, $link->error));
        break;
  }
}
if ($res) {
    var_dump($res->fetch_assoc());
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.partitioning">
  <title>Partitionnement et fragmentation</title>
  <para>
   Les clusters de base de données sont mis en place pour plusieurs raisons.
   Les clusters peuvent améliorer la disponibilité, la tolérance aux pannes
   mais aussi améliorer les performances en suivant une approche du type
   "diviser pour mieux reigner", sachant que le travail est distribué sur plusieurs
   machines. Le clustering est quelques fois combiné avec le partitionnement
   et la fragmentation pour ensuite diviser une énorme tâche complexe en
   des tâches plus petites et donc plus gérables.
  </para>
  <para>
   Le plugin mysqlnd_ms a été conçu pour supporter une grande variété de clusters
   de base de données MySQL. Certaines sortes de clusters de bases de données
   ont des méthodes internes pour le partitionnement et la fragmentation,
   les rendant ainsi transparentes à l'utilisation : le filtrage sur les tables
   de réplication MySQL, et la fragmentation (application basée sur le partitionnement).
  </para>
  <para>
   La réplication MySQL supporte le partitionnement sous la forme de filtres
   qui vous permettent de créer des esclaves qui répliquent toutes les bases de
   données ou une seule base de données (ou des tables) du maîtres. Il est ensuite
   de la responsabilité de l'application de choisir un esclabe suivant les règles
   du filtre. Vous pouvez utiliser soit le filtre
   mysqlnd_ms <literal><link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-node-groups">node_groups</link></literal>
   pour supporter manuellement ce comportement, ou utiliser le filtre de table expérimental.
  </para>
  <para>
   Le partitionnement ou la fragmentation manuelle est supporté via le filtre de groupage
   des noeuds, ainsi qu'avec les astuces SQL depuis la version 1.5.0. Le filtre
   node_groups vous permet d'assigner un nom symbolique à un groupe de serveurs maîtres ou esclabes.
   Dans l'exemple, le maître <literal>master_0</literal> et <literal>slave_0</literal>
   forment un groupe dont le nom est <literal>Partition_A</literal>. Il est ensuite
   entièrement de votre responsabilité que de décider le contenu du groupe. Par exemple,
   vous pouvez utiliser des groupes de noeuds pour la fragmentation, et utiliser
   les noms des groupes pour adresse une fragmentation comme
   like <literal>Shard_A_Range_0_100</literal>.
  </para>
  <para>
   <example>
    <title>Cluster de groupes de noeuds</title>
    <programlisting role="ini">
<![CDATA[
 {
  "myapp": {
       "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
        "filters": {
            "node_groups": {
                "Partition_A" : {
                    "master": ["master_0"],
                    "slave": ["slave_0"]
                }
            },
           "roundrobin": []
        }
    }
}
]]>
    </programlisting>
  </example>
  </para>
  <para>
   <example>
    <title>Partitionnement manuelle en utilisant des astuces SQL</title>
    <programlisting role="php">
<![CDATA[
<?php
function select($mysqli, $msg, $hint = '')
{
    /* Note : test faible, deux connexions vers deux serveurs peuvent avoir le même identifiant de thread */
    $sql = sprintf("SELECT CONNECTION_ID() AS _thread, '%s' AS _hint FROM DUAL", $msg);
    if ($hint) {
        $sql = $hint . $sql;
    }
    if (!($res = $mysqli->query($sql))) {
        printf("[%d] %s", $mysqli->errno, $mysqli->error);
        return false;
    }
    $row =  $res->fetch_assoc();
    printf("%d - %s - %s\n", $row['_thread'], $row['_hint'], $sql);
    return true;
}

$mysqli = new mysqli("myapp", "user", "password", "database");
if (!$mysqli) {
  /* Bien évidemment, votre gestionnaire d'erreurs est meilleur... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Tous les esclaves sont autorisés */
select($mysqli, "slave_0");
select($mysqli, "slave_1");

/* seuls les serveurs du groupe de noeuds "Partition_A" sont autorisés */
select($mysqli, "slave_1", "/*Partition_A*/");
select($mysqli, "slave_1", "/*Partition_A*/");
?>
]]>
    </programlisting>
    <screen>
<![CDATA[
6804 - slave_0 - SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
2442 - slave_1 - SELECT CONNECTION_ID() AS _thread, 'slave2' AS _hint FROM DUAL
6804 - slave_0 - /*Partition_A*/SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
6804 - slave_0 - /*Partition_A*/SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
]]>
    </screen>
   </example>
  </para>
  <para>
   Par défaut, le plugin utilisera tous les serveurs maîtres et esclaves configurés
   pour l'exécution de la requête. Mais si une requête commence avec une astuce SQL
   comme <literal>/*node_group*/</literal>, le plugin ne va considérer que les serveurs
   listés dans le <literal>node_group</literal> lors de l'exécution de la requête.
   Aussi, les requêtes de type <literal>SELECT</literal> préfixées avec
   <literal>/*Partition_A*/</literal> seront exécutées uniquement sur
   <literal>slave_0</literal>.
  </para>
  
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.mysql_fabric">
  <title>MySQL Fabric</title>
  <note>
   <title>Version nécessaire et statut</title>
   <para>
    Le support de MySQL Fabric a commencé avec la version 1.6. Veuillez 
    considérer l'implémentation actuelle comme une pré-alpha. La documentation 
    est susceptible de ne pas lister toutes les fonctionnalités ou limitations. 
    Le travail est en cours.
   </para>
   <para>
    Le sharding est le seul cas actuelement supporté par le greffon.
   </para>
  </note>
   <note>
   <title>Les concepts de MySQL Fabric</title>
   <para>
    Veuillez vous référer au manuel de référence MySQL pour plus d'informations 
    sur MySQL Fabric et comment le mettre en place. La documentation PHP suppose 
    que vous êtes familier avec les concepts de bases et les idées derrière 
    MySQL Fabric.
   </para>
  </note>
  <para>
   MySQL Fabric est un système pour gérer des fermes de serveurs MySQL afin 
   d'obtenir de la haute disponibilité et optionnellement supporter le sharding. 
   Techniquement, c'est un intergiciel de gestion et de monitoring de serveurs 
   MySQL.
  </para>
  <para>
   Les clients interrogent MySQL Fabric afin d'obtenir des listes de serveurs 
   MySQL, leurs états et leurs rôles. Par exemple, les clients peuvent demander 
   une liste des esclaves d'un groupe de réplication MySQL et savoir s'ils sont 
   prêts pour gérer des requêtes. Un autre exemple est un cluster de serveurs 
   MySQL shardés ou le client désire savoir quel shard interroger pour une table 
   et une clé de shard donnée. Si configuré pour utiliser MySQL Fabric, le 
   greffon utilise XML RPC au dessus de HTTP pour obtenir la liste à l'exécution 
   depuis le hôte MySQL Fabric. L'appel de procédures à distance XML est fait en 
   arrière plan et est transparent du point de vue du développeur.  
  </para>
  <para>
   Au lieu de lister les serveurs MySQL directement dans les fichiers de 
   configuration des greffons, cela contient juste la liste d'un ou plusieurs 
   hôtes MySQL Fabric.
  </para>
    <para>
   <example>
    <title>Configuration du greffon: Des hôtes Fabric au lieu des serveurs MySQL</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "fabric": {
            "hosts": [
                {
                    "host" : "127.0.0.1",
                    "port" : 8080
                }
            ]
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Les utilisateurs utilisent les nouvelles fonctions 
   <function>mysqlnd_ms_fabric_select_shard</function> et
   <function>mysqlnd_ms_fabric_select_global</function> pour basculer 
   vers l'ensemble des serveurs responsables d'une clé de shard donné. Ensuite, 
   le greffon choisit le serveur approprié pour exécuter les requêtes. Ce 
   faisant, le greffon tient compte des règles de loadbalancing.
  </para>
  <para>
   L'exemple suivant suppose que MySQL Fabric a été configuré pour sharder la 
   table <literal>test.fabrictest</literal> en utilisant la colonne 
   <literal>id</literal> comme clé de shard.
  </para>
  <para>
   <example>
    <title>Partitionnement manuel en utilisant les SQL hints</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "user", "password", "database");
if (!$mysqli) {
    /* Bien sur, votre gestionnaire d'erreurs est meilleur... */
    die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
}

/* Créer une table globale (disponible sur tous les shards) */
mysqlnd_ms_fabric_select_global($mysqli, "test.fabrictest");
if (!$mysqli->query("CREATE TABLE test.fabrictest(id INT NOT NULL PRIMARY KEY)")) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Basculer la connexion sur le bon shard et insérer un enregistrement */
mysqlnd_ms_fabric_select_shard($mysqli, "test.fabrictest", 10);
if (!($res = $mysqli->query("INSERT INTO fabrictest(id) VALUES (10)"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Tenter de lire l'enregistrement nouvellement inséré */
mysqlnd_ms_fabric_select_shard($mysqli, "test.fabrictest", 10);
if (!($res = $mysqli->query("SELECT id FROM test WHERE id = 10"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   L'exemple précédent, une table shardé est créée, un enregistrement inséré et 
   récupérer par la suite. Toutes les opérations en langage de définition de 
   données SQL (DDL) sur une table shardé doivent être appliqués au groupe de 
   serveur global. Avant de créer ou modifier une table shardé, 
   <function>mysqlnd_ms_fabric_select_global</function> est appelé pour 
   basculer la connexion donnée vers les serveurs, du groupe global, 
   correspondant. Les requêtes SQL de manipulation de données (DML) doivent 
   être envoyés aux shards directement. La fonction 
   <link linkend="function.mysqlnd-ms-fabric-select-shard">
   <function>mysqlnd_ms_fabric_select_shard</function></link> permet de basculer 
   la connexion vers les shards gérant la clé donnée.
  </para>


 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
