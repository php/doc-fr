<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a714378ed87cdbdbde3b10ded183e8df7b243cb4 Maintainer: gui Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="mysqlnd.stats" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Statistiques</title>
 <para>
  <emphasis role="bold">Utilisation des donnés statistiques</emphasis>
 </para>
 <para>
  Le pilote natif MySQL peut collecter des statistiques sur la communication entre
  le client et le serveur. Ces statistiques sont de deux sortes :
 </para>
 <itemizedlist>
  <listitem>
   <para>
    Les statistiques client
   </para>
  </listitem>
  <listitem>
   <para>
    Les statistiques de connexion
   </para>
  </listitem>
 </itemizedlist>
 <para>
  Si vous utilisez l'extension <literal>mysqli</literal>,
  ces statistiques sont disponibles via deux appels d'API :
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <function>mysqli_get_client_stats</function>
   </para>
  </listitem>
  <listitem>
   <para>
    <function>mysqli_get_connection_stats</function>
   </para>
  </listitem>
 </itemizedlist>
 <note>
  <para>
   Les statistiques sont agrégées entre toutes les extensions qui utilisent
   le pilote natif MySQL. Par exemple, quand les extensions
   <literal>ext/mysql</literal> et <literal>ext/mysqli</literal>
   sont toutes deux compilées par rapport au pilote natif MySQL, les appels de 
   fonctions de <literal>ext/mysql</literal> et <literal>ext/mysqli</literal> 
   changeront tous les deux les statistiques. Il n'y a aucun moyen de savoir
   comment des appels à une certaine API compilée par rapport au pilote natif MySQL
   ont modifié une statistique donnée. Vous pouvez configurer le pilote PDO MySQL,
   <literal>ext/mysql</literal> et <literal>ext/mysqli</literal> pour éventuellement
   utiliser le pilote natif MySQL. Dans ce cas, les trois extensions modifieront les
   statistiques.
  </para>
 </note>
 <para>
  <emphasis role="bold">Accéder aux statistiques client</emphasis>
 </para>
 <para>
  Pour accéder aux statistiques client, vous devez appeler
  <function>mysqli_get_client_stats</function>. L'appel à la fonction ne requiert
  aucun paramètre.
 </para>
 <para>
  Cette fonction retourne un tableau associatif contenant le nom
  de la statistique comme clé et la donnée statistiques comme valeur.
 </para>
 <para>
  Les statistiques client peuvent aussi être accédées via la fonction
  <function>phpinfo</function>.
 </para>
 <para>
  <emphasis role="bold">Accéder aux statistiques de connexion</emphasis>
 </para>
 <para>
  Pour accéder aux statistiques client, vous devez appeler
  <function>mysqli_get_connection_stats</function>. Cette fonction prend en paramètre
  la ressource de connexion à la base de données.
 </para>
 <para>
  Cette fonction retourne un tableau associatif contenant le nom de la statistique comme clé
  et la donnée statistique comme valeur.
 </para>
 <para>
  <emphasis role="bold">Buffered and Unbuffered Result Sets</emphasis>
 </para>
 <para>
  Les jeux de résultats peuvent être mis ou non en tampon. Le paramétrage par défaut
  fait fonctionner <literal>ext/mysql</literal> et <literal>ext/mysqli</literal> avec
  des jeux de résultats en tampon pour des requêtes normales (non préparées).
  Les jeux de résultats sont stockés côté client. Après l'exécution de la requête, tous les 
  résultats sont récupérés du serveur MySQL et mis en cache côté client.
  Le grand avantage de jeux de résultat mis en tampon est qu'ils autorisent le serveur à 
  libérer les ressources allouées à un jeu de résultat, dès que ceux-ci ont été récupérés par
  le client.
 </para>
 <para>
  D'autre part, des jeux de résultats non mis en tampon sont gardés plus longtemps sur le serveur.
  Si vous voulez réduire la consommation de mémoire côté client, mais en contre-partie augmenter
  la charge sur le serveur, ne mettez pas les résultats en tampon. Si vous avez par contre une
  charge serveur importante et que vos soupçons se portent sur les résultats non mis en tampon, vous
  devriez considérer de déplacer la charge côté client. Les clients s'adaptent généralement plus 
  facilement que les serveurs. La charge (<quote>Load</quote>) ne concerne pas seulement les tampons
  mémoire. En effet, le serveur a aussi besoin de garder d'autres ressources ouvertes, par exemple 
  des threads ou des descripteurs de fichier, avant qu'un jeu de résultat ne soit libéré.
 </para>
 <para>
  Les requêtes préparées ne mettent pas par défaut les résultats en tampon. Vous pouvez 
  toujours utiliser <function>mysqli_stmt_store_result</function> pour activer la mise
  en tampon des résultats.
 </para>
 <para>
  <emphasis role="bold">Statistiques retournées par le pilote natif MySQL</emphasis>
 </para>
 <para>
  Le tableau suivant présente une liste des statistiques retournées par les fonctions
  <function>mysqli_get_client_stats</function> et
  <function>mysqli_get_connection_stats</function>.
 </para>
 <table>
  <title>Statistiques retournées par mysqlnd : Réseau</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistique</entry>
     <entry>Contexte</entry>
     <entry>Description</entry>
     <entry>Notes</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>bytes_sent</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre d'octets envoyés de PHP vers le serveur MySQL</entry>
     <entry>Peut être utilisé pour vérifier l'efficacité du protocole compressé</entry>
    </row>
    <row>
     <entry><literal>bytes_received</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombres d'octets reçus du serveur MySQL</entry>
     <entry>Peut être utilisé pour vérifier l'efficacité du protocole compressé</entry>
    </row>
    <row>
     <entry><literal>packets_sent</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets envoyés de type client-serveur MySQL</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur</entry>
    </row>
    <row>
     <entry><literal>packets_received</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets reçus de type client-serveur MySQL</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_in</literal></entry>
     <entry>Connexion</entry>
     <entry>Le surcoût en octets du protocole client-serveur MySQL pour le trafic entrant.
      Actuellement, seul l'en-tête de paquet (4 octets) est considéré comme du
      surcoût. protocol_overhead_in = packets_received * 4</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_out</literal></entry>
     <entry>Connexion</entry>
     <entry>Le surcoût en octets du protocole client-serveur MySQL pour le trafic sortant.
      Actuellement, seul l'en-tête de paquet (4 octets) est considéré comme du
      surcoût. protocol_overhead_in = packets_received * 4</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur</entry>
    </row>
    <row>
     <entry><literal>bytes_received_ok_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'octets des paquets du protocole client-serveur MySQL reçus avec un statut OK.
      Les paquets reçus avec un statut OK peuvent contenir un message de statut. La longueur de ce message de
      statut peut varier, entrainant de ce fait une taille non-fixe de paquet OK.</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_ok</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de paquets du protocole client-serveur MySQL reçus avec un statut OK.</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_eof_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Taille totale en octets des paquets EOF reçus avec le protocole client-serveur MySQL. 
      La taille de EOF peut varier selon la version du serveur.
      De plus, EOF peut contenir un message d'erreur.</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_eof</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de paquets EOF reçus avec le protocole client-serveur MySQL.
      Comme avec d'autres statistiques sur les paquets, le nombre de paquets augmentera même si
      PHP ne reçoit pas le paquet attendu, mais par exemple un message d'erreur.</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_header_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Taille totale en octets des paquets d'en-tête de jeux de résultats reçus avec le protocole client-serveur MySQL.
      La taille des paquets varie selon le type de données transportées
      (<literal>LOAD LOCAL INFILE</literal>, <literal>INSERT</literal>,
      <literal>UPDATE</literal>, <literal>SELECT</literal>, messages d'erreur).</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_header</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets d'en-tête de jeux de résultats reçus avec le protocole client-serveur MySQL.</entry>
     <entry>Utilisé pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_field_meta_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Taille totale en octets des paquets de méta-données (informations sur les champs) de jeux de résultats reçus avec
      le protocole client-serveur MySQL. Bien entendu, la taille varie selon les champs contenus dans le jeu de résultats.
      Le paquet peut aussi transporter une erreur ou un EOF dans le cas de COM_LIST_FIELDS.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_field_meta</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets de méta-données (informations sur les champs) de jeux de résultats reçus avec
      le protocole client-serveur MySQL.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_row_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Taille totale en octets des paquets de données pures de jeux de résultats reçus avec
      le protocole client-serveur MySQL. Le paquet peut aussi transporter une erreur ou un paquet EOF.
      Vous pouvez faire du rétro-engeneering sur le nombre de paquets d'erreurs ou de paquets EOF en
      soustrayant <literal>rows_fetched_from_server_normal</literal>
      et <literal>rows_fetched_from_server_ps</literal> de
      <literal>bytes_received_rset_row_packet</literal>.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_row</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets de données pures de jeux de résultats reçus avec
      le protocole client-serveur MySQL et leur taille totale en octets.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_prepare_response_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Taille totale en octets des paquets "OK for Prepared
      Statement Initialization packets (paquets d'initialisation des commandes préparées).
      Le paquet peut aussi traporter une erreur. La taille du paquet dépend de la version de MySQL :
      9 octets avec MySQL 4.1 et 12 octets à partir de MySQL 5.0. Il n'y a aucun moyen sûr de savoir
      combien d'erreurs sont survenues. Vous pouvez éventuellement deviner qu'une erreur est survenue
      si, par exemple, vous vous connectez toujours à MySQL 5.0 ou supérieur et que 
      <literal>bytes_received_prepare_response_packet</literal> !=
      <literal>packets_received_prepare_response</literal> * 12. Regardez
      aussi <literal>ps_prepared_never_executed</literal> et
      <literal>ps_prepared_once_executed</literal>.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_prepare_response</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets "OK for Prepared Statement Initialization packets (paquets d'initialisation des commandes
      préparées).</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_change_user_packet</literal></entry>
     <entry>Connexion</entry>
     <entry>Taille totale en octets des paquets COM_CHANGE_USER reçus avec le protocole client-serveur MySQL.
      Le paquet peut aussi transporter une erreur ou un EOF.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_received_change_user</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets COM_CHANGE_USER reçus avec le protocole client-serveur MySQL.</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur. Notez bien que la taille totale
      en octets inclut la taille du paquet d'en-tête (4 octets, comme indiqué dans le surcoût du protocole).</entry>
    </row>
    <row>
     <entry><literal>packets_sent_command</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de paquets envoyés de PHP vers MySQL avec le protocole client-serveur MySQL.
      Il n'y a aucun moyen de savoir quelle commande spécifique a été envoyée et en quel quantité.
      Au mieux, vous pouvez vous en servir pour savoir si PHP a envoyé des commandes à MySQL et ainsi
      savoir si vous pouvez supprimer le support de MySQL dans votre binaire PHP. Il n'y a de même aucun
      moyen de faire du rétro-engeneering sur le nombre d'erreurs qui ont pu survenir lors de l'envoi
      de données à MySQL. La seule erreur recodée est command_buffer_too_small (voir ci-après).</entry>
     <entry>Utile seulement pour déboguer l'implémentation du protocole client-serveur.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_normal</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre d'octets de charge récupérés par le client PHP depuis
      <literal>mysqlnd</literal> en utilisant le protocole de texte.</entry>
     <entry>C'est la taille des données actuellement contenues dans les jeux de résultats
      qui ne proviennent pas des commandes préparées et qui ont été récupérées par le client
      PHP. Notez que même si un jeu de résultat complet a pu être récupéré de MySQL par
      <literal>mysqlnd</literal>, cette statistique ne compte que les données actuellement
      récupérées depuis <literal>mysqlnd</literal> par le client PHP. Un exemple de code qui
      incrémentera cette valeur:
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->fetch_assoc();
$res->close();
]]>
      </programlisting>
      <para>
       Chaque opération de récupération (fetch) incrémentera cette valeur.
      </para>
      
      <para>
       Cette statistique ne sera pas incrémentée si le jeu de résultats est mis en tampon
       seulement sur le client, mais pas récupéré. Par exemple:
      </para>
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->close();
]]>
      </programlisting>
     </entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_ps</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre d'octets de charge récupérés par le client PHP depuis
      <literal>mysqlnd</literal> en utilisant le protocole de commande préparée.</entry>
     <entry>C'est la taille des données actuellement contenues dans un jeu de résultats
      provenant d'une commande préparée et qui a été récupérée par le client PHP. La valeur
      ne sera pas incrémentée si le jeu de résultat n'est pas lu par le client PHP. Notez
      que même si un jeu de résultats complet a pu être récupéré depuis MySQL par
      <literal>mysqlnd</literal>, cette statistique ne compte que les données récupérées
      par le client PHP depuis <literal>mysqlnd</literal>. Voyez aussi
      <literal>bytes_received_real_data_normal</literal>.
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Jeu de résultats</emphasis>
 </para>
 <table>
  <title>Statistiques retournées par mysqlnd : Jeu de résultats</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistique</entry>
     <entry>Contexte</entry>
     <entry>Description</entry>
     <entry>Notes</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>result_set_queries</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de requêtes qui ont généré un jeu de résultats. Des exemples de requêtes
      qui génèrent un jeu de résultats : <literal>SELECT</literal> et
      <literal>SHOW</literal>. Cette statistique ne sera pas incrémentée si une erreur survient lors
      de la lecture du paquet d'en-tête du jeu de résultats.</entry>
     <entry>Vous pouvez l'utiliser comme mesure indirecte du nombre de requêtes que PHP a envoyées
      à MySQL pour identifier, par exemple, un client qui provoque beaucoup de charge sur la base de données.</entry>
    </row>
    <row>
     <entry><literal>non_result_set_queries</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de requêtes qui n'ont pas généré de jeu de résultats. Des exemples de requêtes qui
      ne génèrent pas de jeu de résultats : <literal>INSERT</literal>, <literal>UPDATE</literal>,
      <literal>LOAD DATA</literal>. Cette statistique ne sera pas incrémentée 
      si une erreur survient lors de la lecture du paquet d'en-tête du jeu de résultats.</entry>
     <entry>Vous pouvez l'utiliser comme mesure indirecte du nombre de requêtes que PHP a envoyées
      à MySQL pour identifier, par exemple, un client qui provoque beaucoup de charge sur la base de données.</entry>
    </row>
    <row>
     <entry><literal>no_index_used</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de requêtes qui ont généré un jeu de résultats mais qui n'ont pas utilisé d'index
      (voir aussi l'option de démarrage de mysqld : 
      –log-queries-not-using-indexes). Si vous voulez que ces requêtes soient rapportées, vous pouvez
      utiliser mysqli_report(MYSQLI_REPORT_INDEX) pour que
      ext/mysqli jette une exception. Si vous préférez un avertissement plutôt qu'une exception, 
      utilisez mysqli_report(MYSQLI_REPORT_INDEX ^
      MYSQLI_REPORT_STRICT).</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>bad_index_used</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de requêtes qui ont généré un jeu de résultats mais qui n'ont pas utilisé un bon index
      (voir aussi l'option de démarrage de mysqld : –log-slow-queries).</entry>
     <entry>Si vous voulez que ces requêtes soient rapportées, vous pouvez
      utiliser mysqli_report(MYSQLI_REPORT_INDEX) pour que
      ext/mysqli jette une exception. Si vous préférez un avertissement plutôt qu'une exception, 
      utilisez mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT).</entry>
    </row>
    <row>
     <entry><literal>slow_queries</literal></entry>
     <entry>Connexion</entry>
     <entry>Les commandes SQL qui ont pris plus de <literal>long_query_time</literal>
      secondes à être exécutées et qui ont nécessité qu'au moins 
      <literal>min_examined_row_limit</literal> enregistrements soient examinés.</entry>
     <entry>Non reporté par <function>mysqli_report</function></entry>
    </row>
    <row>
     <entry><literal>buffered_sets</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de jeux de résultats retournés par des requêtes <quote>normales</quote> et qui
      ont été mis en tampon. <quote>normale</quote> signifie <quote>commande non préparée</quote> 
      dans les notes qui suivent.</entry>
     <entry>Des exemples d'appel à l'API, qui ne mettront pas les jeux de résultats en tampon côté client :
      <function>mysql_query</function>,
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function>,
      <function>mysqli_stmt_get_result</function>. Mettre les jeux de résultat en tampon
      côté client assure que les ressources allouées côté serveur sont libérées dès que possible
      et rend la navigation dans le jeu de résultat plus aisée. L'inconvénient, c'est une consommation
      mémoire plus importante côté client pour mettre les jeux de résultats en tampon. Notez que
      mysqlnd (contrairement à la bibliothèque cliente MySQL) respecte la limite de mémoire de PHP pour l'allocation,
      car mysqlnd utilise les fonctions de gestion de mémoire internes de PHP. C'est aussi pourquoi
      <function>memory_get_usage</function> rapporte une consommation mémoire plus importante quand on 
      utilise mysqlnd plutôt que la bibliothèque cliente MySQL. <function>memory_get_usage</function> ne mesure
      pas la consommation mémoire de la bibliothèque cliente MySQL car celle-ci n'utilise pas les fonctions
      de gestion de mémoire internes de PHP, mésurées par cette fonction!</entry>
    </row>
    <row>
     <entry><literal>unbuffered_sets</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de jeux de résultats non mis en tampon retournés par des requêtes normales
      (pas de commande préparée).</entry>
     <entry>Des exemples d'appels à l'API qui ne mettent pas les jeux de résultats en tampon côté client :
      <function>mysqli_use_result</function></entry>
    </row>
    <row>
     <entry><literal>ps_buffered_sets</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de jeux de résultats mis en tampon retournés par des commandes préparées. Par défaut, les commandes
      préparées ne sont pas mises en tampon.</entry>
     <entry>Des exemples d'appels à l'API qui mettent les jeux de résultats en tampon côté client :
      <literal>mysqli_stmt_store_result</literal></entry>
    </row>
    <row>
     <entry><literal>ps_unbuffered_sets</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de jeux de résultats non mis en tampon retournés par des commandes préparées.</entry>
     <entry>Par défaut, les commandes préparées ne sont pas mises en tampon.</entry>
    </row>
    <row>
     <entry><literal>flushed_normal_sets</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de jeux de résultats issus de requêtes normales (pas de commande préparée) avec des
      données non lues qui ont été évacuées implicitement. L'évacuation n'a lieu qu'avec les jeux de résultats non
      mis en tampon.</entry>
     <entry>Les jeux de résultats non mis en tampon doivent être récupérés en totalité avant qu'une nouvelle requête
      puisse être passée sur la connexion, sans quoi MySQL renverra une erreur. Si l'application ne récupère pas
      tous les enregistrements d'un jeu de résultats non mis en tampon, mysqlnd récupère implicitement tout le jeu
      afin de laisser place nette. Voir aussi <literal>rows_skipped_normal</literal> et 
      <literal>rows_skipped_ps</literal>. Quelques causes possibles d'une évacuation implicite :
      <itemizedlist>
       <listitem>
        <para>
         Une application cliente défectueuse
        </para>
       </listitem>
       <listitem>
        <para>
         Le client a arrêté de lire après qu'il a trouvé ce qu'il cherchait met a fait considérer à
         MySQL davantage d'enregistrements que nécessaire
        </para>
       </listitem>
       <listitem>
        <para>
         L'application cliente s'est arrêtée de façon inattendue
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>flushed_ps_sets</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de jeux de résultats issus de commandes préparées avec des
      données non lues qui ont été évacuées implicitement. L'évacuation n'a lieu qu'avec les jeux de résultats non
      mis en tampon.</entry>
     <entry>Les jeux de résultats non mis en tampon doivent être récupérés en totalité avant qu'une nouvelle requête
      puisse être passée sur la connexion, sans quoi MySQL renverra une erreur. Si l'application ne récupère pas
      tous les enregistrements d'un jeu de résultats non mis en tampon, mysqlnd récupère implicitement tout le jeu
      afin de laisser place nette. Voir aussi <literal>rows_skipped_normal</literal> et 
      <literal>rows_skipped_ps</literal>. Quelques causes possibles d'une évacuation implicite :
      <itemizedlist>
       <listitem>
        <para>
         Une application cliente défectueuse
        </para>
       </listitem>
       <listitem>
        <para>
         Le client a arrêté de lire après qu'il a trouvé ce qu'il cherchait met a fait considérer à
         MySQL davantage d'enregistrements que nécessaire
        </para>
       </listitem>
       <listitem>
        <para>
         L'application cliente s'est arrêtée de façon inattendue
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>ps_prepared_never_executed</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de commandes préparées mais jamais exécutées.</entry>
     <entry>Les commandes préparées monopolisent des ressources serveur. Vous ne devriez pas préparer une
      commande si vous n'envisagez pas de l'exécuter.</entry>
    </row>
    <row>
     <entry><literal>ps_prepared_once_executed</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre de commandes préparées exécutées une seule fois.</entry>
     <entry>Un des principes des commandes préparées est que la même requête est
      exécutée encore et encore (avec des paramètres différents) de telle façon que
      des opérations d'analyse syntaxique et de préparation puissent être économisées si
      l'exécution de la commande est séparée en deux phases distinctes de préparation et
      d'exécution. L'idée est de préparer une fois et de mettre en <quote>cache</quote> les
      résultats pour que, par exemple, l'arbre d'analyse syntaxique puisse être réutilisé pour
      l'exécution de plusieurs commandes. Si vous exécutez une commande préparée uen seule fois,
      vous perdez tous le bénéfice des deux phases distinctes par rapport à des requêtes 
      <quote>normales</quote> parce que la mise en cache représente du travail supplémentaire et 
      monopolise des ressources (limitées) côté serveur. Par conséquent, les commandes préparées
      exécutées une seule fois peuvent provoquer des baisses de performance.</entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_server_normal</literal>,
      <literal>rows_fetched_from_server_ps</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de jeux de résultats récupérés avec succès du serveur MySQL sans se soucier
      si l'application cliente les a utilisés ou pas.
      Certains des enregistrements peuvent ne pas avoir été récupérés par l'application cliente mais
      avoir été évacués de façon implicite.</entry>
     <entry>Voir aussi <literal>packets_received_rset_row</literal></entry>
    </row>
    <row>
     <entry><literal>rows_buffered_from_client_normal</literal>,
      <literal>rows_buffered_from_client_ps</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'enregistrements mis en tampon avec succès suite à une requête
      <quote>normale</quote> ou une commande préparée. C'est le nombre d'enregistrements
      qui ont été récupérés du serveur MySQL et mis en tampon par le client. Notez qu'il y
      a deux statistiques différentes : une sur les enregistrements ont été mis en tampon
      (de MySQL au tampon interne de mysqlnd) et l'autre sur les enregistrements mis en tampon
      qui ont été récupérés par l'application cliente (du tampon interne de mysqlnd vers l'application
      cliente). Si le nombre d'enregistrements mis en tampon est supérieur au nombre d'enregistrements
      récupérés, cela peut signifier que l'application cliente exécute des requêtes dont les
      enregistrements résultants sont plus grands que nécessaire, menant à des enregistrements non
      lus par le client.</entry>
     <entry>Des exemples de requêtes qui mettent les résultats en tampon :
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_buffered</literal>,
      <literal>rows_fetched_from_client_ps_buffered</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'enregistrements récupérés par le client à partir d'un jeu de résultat
      mis en tampon et créé à partir d'une requête <quote>normale</quote> ou d'une commande préparée.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_unbuffered</literal>,
      <literal>rows_fetched_from_client_ps_unbuffered</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'enregistrements récupérés par le client à partir d'un jeu de résultat
      non mis en tampon et créé à partir d'une requête <quote>normale</quote> ou d'une commande préparée.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_ps_cursor</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'enregistrements récupérés par le client à partir d'un curseur créé
      par une commande préparée.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal></entry>
     <entry>Connexion</entry>
     <entry>Reservé pour une utilisation future (actuellement non supporté)</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>copy_on_write_saved</literal>,
      <literal>copy_on_write_performed</literal></entry>
     <entry>Processus</entry>
     <entry>Avec mysqlnd, les variables retournées par l'extension pointent vers les tampons
      de résultats réseau internes à mysqlnd. Si vous en changez pas ces variables, les données
      récupérées seront gardées une seule fois en mémoire. Si vous changez les variables,
      mysqlnd doit faire une copie-avant-écriture (copy-on-write) pour protéger ces tampons de
      résultats réseau internes. Avec la bibliothèque cliente MySQL, vous gardez toujours les données
      récupérées en mémoire en deux exemplaires : un pour les tampons internes à la bibliothèque cliente
      MySQL et un pour les extensions. En théorie, mysqlnd peut vous faire économiser jusqu'à 40% de mémoire.
      Notez cependant que l'économie de mémoire ne peut pas être mésurée par
      <function>memory_get_usage</function>.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>explicit_free_result</literal>,
      <literal>implicit_free_result</literal></entry>
     <entry>Connexion, Process (seulement pendant le ménage des commandes préparées)</entry>
     <entry>Nombre total de jeux de résultats libérés.</entry>
     <entry>La libération est toujours considérée comme explicite, sauf pour les jeux de résultats créés
      par des commandes d'initialisation, par exemple 
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal></entry>
    </row>
    <row>
     <entry><literal>proto_text_fetched_null</literal>,
      <literal>proto_text_fetched_bit</literal>,
      <literal>proto_text_fetched_tinyint</literal>
      <literal>proto_text_fetched_short</literal>,
      <literal>proto_text_fetched_int24</literal>,
      <literal>proto_text_fetched_int</literal>
      <literal>proto_text_fetched_bigint</literal>,
      <literal>proto_text_fetched_decimal</literal>,
      <literal>proto_text_fetched_float</literal>
      <literal>proto_text_fetched_double</literal>,
      <literal>proto_text_fetched_date</literal>,
      <literal>proto_text_fetched_year</literal>
      <literal>proto_text_fetched_time</literal>,
      <literal>proto_text_fetched_datetime</literal>,
      <literal>proto_text_fetched_timestamp</literal>
      <literal>proto_text_fetched_string</literal>,
      <literal>proto_text_fetched_blob</literal>,
      <literal>proto_text_fetched_enum</literal>
      <literal>proto_text_fetched_set</literal>,
      <literal>proto_text_fetched_geometry</literal>,
      <literal>proto_text_fetched_other</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de colonnes d'un certain type retournées à partir d'une requête normale 
      (protocole texte MySQL).</entry>
     <entry>Correspondance entre l'API C / les types de méta-données MySQL et le nom des statistiques :
      <itemizedlist>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_NULL</literal> - proto_text_fetched_null
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_BIT</literal> - proto_text_fetched_bit
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY</literal> - proto_text_fetched_tinyint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SHORT</literal> - proto_text_fetched_short
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_INT24</literal> - proto_text_fetched_int24
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONG</literal> - proto_text_fetched_int
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONGLONG</literal> -
         proto_text_fetched_bigint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DECIMAL</literal>,
         <literal>MYSQL_TYPE_NEWDECIMAL</literal> -
         proto_text_fetched_decimal
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_FLOAT</literal> - proto_text_fetched_float
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DOUBLE</literal> -
         proto_text_fetched_double
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATE</literal>,
         <literal>MYSQL_TYPE_NEWDATE</literal> - proto_text_fetched_date
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_YEAR</literal> - proto_text_fetched_year
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIME</literal> - proto_text_fetched_time
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATETIME</literal> -
         proto_text_fetched_datetime
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIMESTAMP</literal> -
         proto_text_fetched_timestamp
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_STRING</literal>,
         <literal>MYSQL_TYPE_VARSTRING</literal>,
         <literal>MYSQL_TYPE_VARCHAR</literal> -
         proto_text_fetched_string
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY_BLOB</literal>,
         <literal>MYSQL_TYPE_MEDIUM_BLOB</literal>,
         <literal>MYSQL_TYPE_LONG_BLOB</literal>,
         <literal>MYSQL_TYPE_BLOB</literal> - proto_text_fetched_blob
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_ENUM</literal> - proto_text_fetched_enum
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SET</literal> - proto_text_fetched_set
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_GEOMETRY</literal> -
         proto_text_fetched_geometry
        </para>
       </listitem>
       <listitem>
        <para>
         N'importe quel <literal>MYSQL_TYPE_*</literal> non encore listé (il ne doit y en avoir
         aucun) - proto_text_fetched_other
        </para>
       </listitem>
      </itemizedlist>
      <para>
       A noter que les constantes de type MYSQL_* peuvent ne pas être associées avec le même type
       de colonne SQL dans toutes les versions de MySQL.
      </para></entry>
    </row>
    <row>
     <entry><literal>proto_binary_fetched_null</literal>,
      <literal>proto_binary_fetched_bit</literal>,
      <literal>proto_binary_fetched_tinyint</literal>
      <literal>proto_binary_fetched_short</literal>,
      <literal>proto_binary_fetched_int24</literal>,
      <literal>proto_binary_fetched_int</literal>,
      <literal>proto_binary_fetched_bigint</literal>,
      <literal>proto_binary_fetched_decimal</literal>,
      <literal>proto_binary_fetched_float</literal>,
      <literal>proto_binary_fetched_double</literal>,
      <literal>proto_binary_fetched_date</literal>,
      <literal>proto_binary_fetched_year</literal>,
      <literal>proto_binary_fetched_time</literal>,
      <literal>proto_binary_fetched_datetime</literal>,
      <literal>proto_binary_fetched_timestamp</literal>,
      <literal>proto_binary_fetched_string</literal>,
      <literal>proto_binary_fetched_blob</literal>,
      <literal>proto_binary_fetched_enum</literal>,
      <literal>proto_binary_fetched_set</literal>,
      <literal>proto_binary_fetched_geometry</literal>,
      <literal>proto_binary_fetched_other</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de colonnes d'un certain type retournées à partir d'une commande préparée 
      (protocole binaire MySQL).</entry>
     <entry>Pour la correspondance des types, regardez <literal>proto_text_*</literal> décrit ci-dessus.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table>
  <title>Statistiques retournées par mysqlnd : Connexion</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistique</entry>
     <entry>Contexte</entry>
     <entry>Description</entry>
     <entry>Notes</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>connect_success</literal>, <literal>connect_failure</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de tentatives de connexions réussies / échouées.</entry>
     <entry>Les connexions réutilisées et tous les autres types de connexions sont incluses.</entry>
    </row>
    <row>
     <entry><literal>reconnect</literal></entry>
     <entry>Processus</entry>
     <entry>Nombre total de tentatives de (real_)connect faites sur un descripteur de connexion déjà 
      ouvert.</entry>
     <entry>Le code <literal>$link = new mysqli(...);
      $link-&gt;real_connect(...)</literal> provoquera une reconnexion. Ce qui n'est pas le cas de 
      <literal>$link = new mysqli(...); $link-&gt;connect(...)</literal>
      car <literal>$link-&gt;connect(...)</literal> fermera explicitement la connexion existante 
      avant qu'une nouvelle connexion soit établie.</entry>
    </row>
    <row>
     <entry><literal>pconnect_success</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de tentatives de connexions persistantes réussies.</entry>
     <entry>Notez que <literal>connect_success</literal> contient la somme des tentatives de 
      connexions persistantes et non-persistantes réussies. Ainsi, le nombre de tentatives de 
      connexions non-persistantes réussies est
      <literal>connect_success</literal> -
      <literal>pconnect_success</literal>.</entry>
    </row>
    <row>
     <entry><literal>active_connections</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de connexions persistantes et non-persistantes actives.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>active_persistent_connections</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de connexions persistantes actives.</entry>
     <entry>Le nombre total de connexions non-persistantes actives est
      <literal>active_connections</literal> -
      <literal>active_persistent_connections</literal>.</entry>
    </row>
    <row>
     <entry><literal>explicit_close</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de connexions fermées explicitement (seulement valable avec ext/mysqli).</entry>
     <entry>Des exemples de code qui ferment explicitement une connexion :
      <programlisting>
<![CDATA[
$link = new mysqli(...); $link->close(...)
$link = new mysqli(...); $link->connect(...)
]]>
      </programlisting></entry>
    </row>
    <row>
     <entry><literal>implicit_close</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total de connexions fermées implicitement (seulement valable avec ext/mysqli).</entry>
     <entry>Des exemples de code qui ferment implicitement une connexion :
      <itemizedlist>
       <listitem>
        <para>
         <literal>$link = new mysqli(...);
          $link-&gt;real_connect(...)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>unset($link)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Connexions persistantes : le groupe de connexions qui ont été créées avec
         real_connect et où il peut y avoir des jeu d'options inconnues - ferme implicitement
         la connexion pour éviter de retourner une connexion avec des options inconnues
        </para>
       </listitem>
       <listitem>
        <para>
         Connexions persistantes : ping/change_user échoue et ext/mysqli
         ferme la connexion
        </para>
       </listitem>
       <listitem>
        <para>
         Fin de l'exécution d'un script : ferme la connexion qui ne l'a pas été par 
         l'utilisateur
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>disconnect_close</literal></entry>
     <entry>Connexion</entry>
     <entry>Echecs de connexions indiqués par l'appel à l'API C
      <function>mysql_real_connect</function> pendant la tentative de connexion.</entry>
     <entry>Elle est appelée <literal>disconnect_close</literal> parce que le descripteur de connexion
      passé lors de l'appel à l'API C sera fermé.</entry>
    </row>
    <row>
     <entry><literal>in_middle_of_command_close</literal></entry>
     <entry>Processus</entry>
     <entry>Une connexion a été fermée en plein milieu de l'exécution d'une commande
      (excluant les jeux de résultats non récupérés, après avoir envoyé une requête et
      avant d'avoir la réponse, en envoyant des données, en transférant des données
      avec LOAD DATA).</entry>
     <entry>A moins que vous n'utilisiez les requêtes asynchrones, ceci ne devrait arriver que si votre script
      s'arrête de façon inopinée et que PHP ferme la connexion pour vous.</entry>
    </row>
    <row>
     <entry><literal>init_command_executed_count</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'exécution de commandes d'initialisation, par exemple,
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal>.</entry>
     <entry>Le nombre de connexions avec succès est
      <literal>init_command_executed_count</literal> -
      <literal>init_command_failed_count</literal>.</entry>
    </row>
    <row>
     <entry><literal>init_command_failed_count</literal></entry>
     <entry>Connexion</entry>
     <entry>Nombre total d'exécution échouées de commandes d'initialisation.</entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table>
  <title>Statistiques retournées par mysqlnd : Commande COM_*</title>
   <tgroup cols="4">
    <colspec colwidth="10*"/>
    <colspec colwidth="10*"/>
    <colspec colwidth="40*"/>
    <colspec colwidth="40*"/>
    <thead>
     <row>
      <entry>Statistique</entry>
      <entry>Contexte</entry>
      <entry>Description</entry>
      <entry>Notes</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>com_quit</literal>, <literal>com_init_db</literal>,
       <literal>com_query</literal>, <literal>com_field_list</literal>,
       <literal>com_create_db</literal>, <literal>com_drop_db</literal>,
       <literal>com_refresh</literal>, <literal>com_shutdown</literal>,
       <literal>com_statistics</literal>,
       <literal>com_process_info</literal>,
       <literal>com_connect</literal>,
       <literal>com_process_kill</literal>, <literal>com_debug</literal>,
       <literal>com_ping</literal>, <literal>com_time</literal>,
       <literal>com_delayed_insert</literal>,
       <literal>com_change_user</literal>,
       <literal>com_binlog_dump</literal>,
       <literal>com_table_dump</literal>,
       <literal>com_connect_out</literal>,
       <literal>com_register_slave</literal>,
       <literal>com_stmt_prepare</literal>,
       <literal>com_stmt_execute</literal>,
       <literal>com_stmt_send_long_data</literal>,
       <literal>com_stmt_close</literal>,
       <literal>com_stmt_reset</literal>,
       <literal>com_stmt_set_option</literal>,
       <literal>com_stmt_fetch</literal>, <literal>com_daemon</literal></entry>
      <entry>Connexion</entry>
      <entry>Nombre total de tentatives d'envoi d'une certaine commande COM_* command de PHP vers
       MySQL.</entry>
      <entry><para>
       Les statistiques sont incrémentées après avoir vérifié la connexion et immédiatement
       avant d'envoyer le paquet correspondant du protocole client-serveur MySQL. Si mysqlnd
       échoue lors de l'envoi du paquet via la connexion, la statistique ne sera pas décrémentée.
       En cas d'échec, mysqlnd émet un avertissement PHP <quote>Error while sending %s packet.
       PID=%d.</quote>
       </para>
       
       <para>
        Exemples d'utilisation :
       </para>
       <itemizedlist>
        <listitem>
         <para>
          Vérifie si PHP envoie certaines commandes à MySQL, vérifie par exemple si un client
          envoie <literal>COM_PROCESS_KILL</literal>
         </para>
        </listitem>
        <listitem>
         <para>
          Calcule le nombre moyen d'exécution de commandes préparées en
          comparant <literal>COM_EXECUTE</literal> et <literal>COM_PREPARE</literal>
         </para>
        </listitem>
        <listitem>
         <para>
          Vérifie si PHP a envoyé des commandes SQL non préparées en vérifiant si
          <literal>COM_QUERY</literal> vaut zéro
         </para>
        </listitem>
        <listitem>
         <para>
          Identifie si des scripts PHP utilisent un nombre excessif de requêtes SQL en
          vérifiant <literal>COM_QUERY</literal> et
          <literal>COM_EXECUTE</literal>
         </para>
        </listitem>
       </itemizedlist></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   <emphasis role="bold">Divers</emphasis>
  </para>
  <table>
  <title>Statistiques retournées par mysqlnd : Divers</title>
   <tgroup cols="4">
    <colspec colwidth="10*"/>
    <colspec colwidth="10*"/>
    <colspec colwidth="40*"/>
    <colspec colwidth="40*"/>
    <thead>
     <row>
      <entry>Statistique</entry>
      <entry>Contexte</entry>
      <entry>Description</entry>
      <entry>Notes</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>explicit_stmt_close</literal>,
       <literal>implicit_stmt_close</literal></entry>
      <entry>Processus</entry>
      <entry>Nombre total de fermetures de commandes préparées.</entry>
      <entry>Une fermeture est toujours considérée comme explicite sauf dans le cas d'une préparation échouée.</entry>
     </row>
     <row>
      <entry><literal>mem_emalloc_count</literal>,
       <literal>mem_emalloc_ammount</literal>,
       <literal>mem_ecalloc_count</literal>,
       <literal>mem_ecalloc_ammount</literal>,
       <literal>mem_erealloc_count</literal>,
       <literal>mem_erealloc_ammount</literal>,
       <literal>mem_efree_count</literal>,
       <literal>mem_malloc_count</literal>,
       <literal>mem_malloc_ammount</literal>,
       <literal>mem_calloc_count</literal>,
       <literal>mem_calloc_ammount</literal>,
       <literal>mem_realloc_count</literal>,
       <literal>mem_realloc_ammount</literal>,
       <literal>mem_free_count</literal></entry>
      <entry>Processus</entry>
      <entry>Appels à la gestion de la mémoire.</entry>
      <entry>Seulement pour du développement.</entry>
     </row>
     <row>
      <entry><literal>command_buffer_too_small</literal></entry>
      <entry>Connexion</entry>
      <entry>Nombre d'extension de tampon de commandes réseau lors de l'envoi des commandes de
       PHP vers MySQL.</entry>
      <entry><para>
       mysqlnd alloue un tampon interne de commande/réseau de
       <literal>mysqlnd.net_cmd_buffer_size</literal>
       (<filename>php.ini</filename>) octets pour chaque connexion. Si une commande du
       protocole client-serveur MySQL, para exemple,
       <literal>COM_QUERY</literal> (requête normales), ne rentre pas dans 
       le tampon, mysqlnd étendra le tampon de jusqu'à ce qui est nécessaire pour
       envoyer la commande. Quand le tampon est étendu pour une connexion,
       <literal>command_buffer_too_small</literal> sera incrémenté d'une unité.
       </para>
       
       <para>
        Si mysqlnd doit étendre le tampon au délà de sa taille initiale de
        <literal>mysqlnd.net_cmd_buffer_size</literal>
        (<filename>php.ini</filename>) octets pour la plupart des connexions,
        vous devriez considérer l'augmentation de la taille par défaut pour éviter les 
        you should consider to increase the default size to avoid
        re-allocations.
       </para>
       
       <para>
        La taille par défaut du tampon est de 4096 octets, qui est la valeur la plus petite possible.
        Cette valeur peut être changée soit via 
        <filename>php.ini</filename> en ajustant le paramètre
        <literal>mysqlnd.net_cmd_buffer_size</literal> ou en utilisant
        <literal>mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int size)</literal>.
       </para>
      </entry>
     </row>
     <row>
      <entry><literal>connection_reused</literal></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
 