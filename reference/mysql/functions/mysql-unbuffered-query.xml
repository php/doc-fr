<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 2c69dc3c075ff95fc1fcf2801ed48d7f48e90412 Maintainer: dams Status: ready -->
<!-- Reviewed: no -->

<refentry xml:id="function.mysql-unbuffered-query" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>mysql_unbuffered_query</refname>
  <refpurpose>
   Exécute une requête SQL sans mobiliser les résultats MySQL
  </refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>resource</type><methodname>mysql_unbuffered_query</methodname>
   <methodparam><type>string</type><parameter>query</parameter></methodparam>
   <methodparam choice="opt"><type>resource</type><parameter>link_identifier</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>mysql_unbuffered_query</function> envoie la requête
   SQL <parameter>query</parameter> au serveur MySQL identifié par
   <parameter>link_identifier</parameter>, sans préparer les résultats
   pour la lecture, comme le fait <function>mysql_query</function>.
   D'une part, cela réduit considérablement la consommation de
   mémoire par MySQL, lorsque les requêtes génèrent
   des résultats de grande taille. D'autre part, vous pourrez utiliser les
   résultats dès que la première ligne aura été
   lue : pas besoin d'attendre que la requête ait complètement
   été exécutée. Lorsque vous utilisez de multiples connexions à MySQL,
   vous devez spécifier le paramètre optionnel
   <parameter>link_identifier</parameter>.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>query</parameter></term>
     <listitem>
      <para>
       Une requête SQL
      </para>
     </listitem>
    </varlistentry>
    &mysql.linkid.description;
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Pour les requêtes SELECT, SHOW, DESCRIBE ou EXPLAIN,
   <function>mysql_unbuffered_query</function>
   retourne une &resource; en cas de succès, ou &false; si une erreur
   survient.
  </para>
  <para>
   Pour les autres types de requêtes, UPDATE, DELETE, DROP, etc,
   <function>mysql_unbuffered_query</function> retourne &true; en cas de succès
   ou &false; si une erreur survient.
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    L'intérêt de <function>mysql_unbuffered_query</function>
    est tempéré par une limitation : <function>mysql_num_rows</function>
    et <function>mysql_data_seek</function> ne fonctionne pas sur une 
    ressource retournée par <function>mysql_unbuffered_query</function>. 
    Vous devez aussi lire tous les résultats d'une première requête exécutée
    avec <function>mysql_unbuffered_query</function>, avant de pouvoir en
    exécuter une autre.
   </para>
  </note>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>mysql_query</function></member>
   </simplelist>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
