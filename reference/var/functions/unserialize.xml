<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/var.xml, last change in rev 1.2 -->
<!-- last change to 'unserialize' in en/ tree in rev 1.2 -->
  <refentry id="function.unserialize">
   <refnamediv>
    <refname>unserialize</refname>
    <refpurpose>
     Crée une variable &php; à partir d'une valeur linéarisée
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <methodsynopsis>
     <type>mixed</type><methodname>unserialize</methodname>
     <methodparam><type>string</type><parameter>str</parameter></methodparam>
     <methodparam choice="opt"><type>string</type><parameter>callback</parameter></methodparam>
    </methodsynopsis>
    <simpara>
     <function>unserialize</function> prend une variable linéarisée
     (voir <function>serialize</function>) et la convertit en variable &php;.
     La valeur convertie est retournée par la fonction, et peut être de
     type <type>integer</type>, <type>double</type>,
     <type>string</type>, <type>array</type> ou <type>object</type>.
     Les objets linéarisés perdent leurs méthodes.
    </simpara>
    <note>
     <title>Directive unserialize_callback_func</title>
     <para>
      Il est possible de définir une fonction de callback qui sera
      appelée si une classe undéfinie est utilisée lors 
      de la délinéarisation
      (ce qui évitera de voir l'objet recevoir le type 
      d'objet incomplet <type>object</type> "__PHP_Incomplete_Class").
      Utilisez dans votre fichier &php.ini; ou le fichier &htaccess;, 
      ou encore avec la fonction <function>ini_set</function>, pour définir
      une fonction 'unserialize_callback_func'. Chaque fois qu'une classe non
      définie sera instantiée, cette fonction sera appelée. 
      Pour désactiver cette fonctionnalité, laissez la simplement 
      vide. Notez aussi que cette directive n'est disponible que depuis &php; 4.2.0. 
     </para>
    </note>
    <note>
     <para>
     Le paramètre <parameter>callback</parameter> est disponible depuis &php; 4.2.0.
     </para>
    </note>
    <para>
     Si la variable délinéarisée est un objet, après avoir réussi à le
     reconstruire, &php; appelera automatiquement la méthode
     __wakeup() si elle existe.
     <example>
      <title>Exemple avec la directive unserialize_callback_func</title>
      <programlisting role="php">
<![CDATA[
<?php
$serialized_object='O:1:"a":1:{s:5:"value";s:3:"100";}';

// directive unserialize_callback_func disponible depuis PHP 4.2.0
ini_set('unserialize_callback_func','moncallback'); 
// configure votre fonction de callback :  moncallbackfunction

function moncallback($classname)
{
    // Incluez simplement in fichier contenant votre définition de classe
    // vous saurez quelle classe grâce à $classname
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      En &php; 3, les méthodes ne sont pas préservées lors de la
      délinéarisation d'un bojet. &php; 4 lève cette limitation, et 
      stocke désormais les méthodes et les membres. Voyez le chapitre sur
      la <link linkend="language.oop.serialization">Linéarisation des objets</link>
      du chapitre <link linkend="language.oop">Classes et
      Objets</link>.
     </para>
    </note>
    <para>
     <example>
      <title>Exemple avec <function>unserialize</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// Ici, on utilise <function>unserialize</function> pour charger les données de sessions
// depuis la base de données, dans $session_data. Cet exemple complète
// celui fourni avec <function>serialize</function>.
$conn = odbc_connect("webdb", "php", "chicken");
$stmt = odbc_prepare($conn, "SELECT data FROM sessions WHERE id = ?");
$sqldata = array($PHP_AUTH_USER);
if (!odbc_execute($stmt, &$sqldata) || !odbc_fetch_into($stmt, &$tmp)) {
    // si la préparation ou la lecture échoue, on crée un tableau vide
    $session_data = array();
} else {
    // les données sauvées sont dans $tmp[0].
    $session_data = unserialize($tmp[0]);
    if (!is_array($session_data)) {
        // Erreur... initialisation à tableau vide
        $session_data = array();
    }
}
?>
]]>
      </programlisting>
     </example>
    </para>
   <para>
    Voir aussi
    <function>serialize</function>.
   </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
