<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 18046e022443b3e8a21088f7a2c850158d03f510 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-qc.quickstart" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Démarrage rapide et quelques exemples</title>
 <para>
  Le plugin de mise en cache de requêtes mysqlnd est très simple d'utilisation.
  Cette section de la documentation va vous montrer les cas typiques d'utilisation,
  et va vous fournir des conseils d'utilisation à prendre en compte lors du
  démarrage de son utilisation.
 </para>
 <para>
  Il est fortement recommandé de lire la section de référence en plus de cette section
  de la documentation. Il est plus sûr de commencer avec le guide
  de démarrage rapide. Cependant, avant d'utiliser ce plugin en environnement
  critique, nous vous recommandons vivement de lire les informations contenues
  dans les sections de référence.
 </para>
 <para>
  La plupart des exemples utilise l'extension <link linkend="ref.mysqli">mysqli</link>
  car c'est l'extension la plus complète PHP MySQL. Cependant, le plugin
  peut aussi être utilisé avec n'importe quelle extension PHP MySQL qui utilise
  la bibliothèque <link linkend="book.mysqlnd">mysqlnd</link>.
 </para>
 
 <section xml:id="mysqlnd-qc.quickstart.concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Architecture et conceptes</title>
  <para>
   Le plugin de mise en cache de requêtes est implémenté comme une extension PHP.
   Il est écrit en C et opère en dessous de PHP. Lors du démarrage
   de l'interpréteur PHP, il est enregistré comme un plugin
   <link linkend="book.mysqlnd">mysqlnd</link> pour remplacer les méthodes
   sélectionnées de mysqlnd C. Ainsi, il peut modifier le comportement
   de n'importe quelle extension PHP MySQL (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) compilée pour utiliser la bibliothèque
   mysqlnd sans modification de l'API de l'extension. Ceci rend le plugin
   compatible avec toutes les applications PHP MySQL. En raison du fait que
   l'API n'est pas modifiée, son utilisation est totalement transparente.
   Reportez-vous à la
   <link linkend="mysqlnd.plugin">description de l'API plugin de mysqlnd</link>
   pour plus de détails sur les avantages de l'architecture plugin et une
   comparaison avec les solutions basées sur les proxy.
  </para>
  <para>
   <emphasis role="bold">Utilisation transparente</emphasis>
  </para>
  <para>
   Lors de l'exécution de PHP, PECL/mysqlnd_qc peut réagir comme un proxy
   pour les requêtes émises depuis PHP
   (<link linkend="book.mysqlnd">mysqlnd</link>) vers le serveur MySQL.
   Il inspecte la chaîne de requête pour décider si les résultats doivent
   être mis en cache ou non. Si c'est le cas, le jeu de résultats est mis
   en cache en utilisant un gestionnaire de stockage et les futures
   exécutions de cette requête seront servies depuis le cache pour une période
   définie par l'utilisateur. La durée de vie, ou TTL de l'entrée du cache
   peut être soit déterminée de façon globale, soit pour chaque requête.
  </para>
  <para>
   Une requête est soit mise en cache si il est demandé au plugin de mettre
   en cache de façon globale toutes les requêtes, soit si la chaîne de requête
   comme avec une astuce SQL (<literal>/*qc=on*/</literal>). Le plugin est capable
   de mettre en cache n'importe quelle requête soumise par un appel approprié
   de l'API depuis n'importe quelle extension PHP MySQL.
  </para>
  <para>
   <emphasis role="bold">Stockage flexible : divers gestionnaires de stockage</emphasis>
  </para>
  <para>
   Divers gestionnaires de stockage sont supportés pour offrir différents scopes
   pour les entrées du cache. Les différents scopes autorisent différents degrés
   dans le partage des entrées du cache entre les clients.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>default</literal> (interne) :  processus mémoire, scope : une ou plusieurs requêtes
      suivant le modèle de déployement de PHP utilisé
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>APC</literal> : mémoire partagée, scope : un seul serveur, plusieurs requêtes web
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>SQLite</literal> : en mémoire ou dans un fichier, scope : un seul serveur, plusieurs
       requêtes web
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>MEMCACHE</literal> : mémoire principale, scope : un ou plusieurs serveurs, plusieurs
       requêtes web
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>user</literal> (interne) : défini par l'utilisateur, scope : défini par l'utilisateur
      </para>
     </listitem>
    </itemizedlist>
  </para>
  <para>
   Le support des gestionnaires de stockage <literal>APC</literal>, <literal>SQLite</literal>
   et <literal>MEMCACHE</literal> doit être activé lors de la compilation. Le gestionnaire
   <literal>default</literal> et <literal>user</literal> sont internes. Il est possible
   de passer d'un gestionnaire compilé de stockage à l'autre à chaque requête lors de l'exécution.
   Cependant, il est recommandé de prendre un gestionnaire de stockage et de l'utiliser
   pour toutes les entrées du cache.
  </para>
  <para>
   <emphasis role="bold">Défense de type slam interne afin de prévenir une surcharge</emphasis>
  </para>
  <para>
   Pour prévenir des situations de surcharge, le plugin de mise en cache a un mécanisme
   de défense de type slam en interne. Si une entrée populaire du cache expire,
   plusieurs clients utilisant les entrées du cache tenteront de mettre à jour l'entrée
   du cache. Pendant la durée de se rafraîchissement, plusieurs clients peuvent
   accéder au serveur de base de données de façon concurrente. Dans la plupart des cas,
   le serveur de base de données devient surchargé et il prendra de plus en plus de temps
   à mettre à jour l'entrée du cache, car il recevra de plus en plus de clients
   qui tenteront de mettre à jour l'entrée du cache. Pour prévenir ce comportement,
   le plugin a un mécanisme de défense de type slam. Si il est activé et que le plugin
   détecte l'expiration d'une entrée du cache, il va étendre la durée de vie de cette entrée
   avant de la mettre à jour. De cette façon, les autres accès concurrents à cette entrée
   du cache seront toujours servis depuis le cache pour un certain temps. Ainsi,
   les accès concurrents ne vont pas tous provoquer des mises à jour concurrentes.
   Idéalement, l'entrée du cache sera mise à jour par le client en étendant sa durée
   de vie avant que d'autres clients ne tentent de mettre à jour le cache, et potentiellement,
   éviter ainsi une situation de surcharge.
  </para>
  <para>
   <emphasis role="bold">Approche unique dans la mise en cache</emphasis>
  </para>
  <para>
   PECL/mysqlnd_qc a une approche unique dans la mise en cache des jeux de résultats
   qui est supérieure aux solutions de mise en cache des applications. Les solutions
   applicatives commencent par récupérer un jeu de résultats dans des variables
   PHP. Puis, les variables PHP sont linéarisées pour stockage dans un cache persistent
   et délinéarisées lors de la récupération. La mise en cache de requête mysqlnd
   stocke les données brutes du protocole envoyées depuis MySQl vers PHP dans son
   cache, et les retournent, si elles sont toujours valides, lors d'une demande d'accès.
   De cette façon, elle échappe à une étape de linéarisation pour une mise en cache
   que toutes les solutions applicatives doivent réaliser. Le plugin peut stocker les
   données brutes du protocole en cache sans avoir à les linéariser en variable PHP
   dans un premier temps, et de les délinéariser en variable PHP pour le
   stockage en cache une nouvelle fois.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.quickstart.configuration">
  <title>Configuration</title>
  <para>
   Le plugin est implémenté comme une extension PHP. Voir aussi les
   <link linkend="mysqlnd-qc.installation">instructions d'installation</link>
   pour installer l'extension
   <link xlink:href="&url.pecl.package;mysqlnd_qc">PECL/mysqlnd_qc</link>.
  </para>
  <para>
   Vous devez compiler ou configurer l'extension PHP MySQL (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) que vous prévoyez d'utiliser avec le support
   de la bibliothèque <link linkend="book.mysqlnd">mysqlnd</link>. PECL/mysqlnd_qc est
   un plugin pour la bibliothèque mysqlnd. Pour utiliser le plugin avec n'importe laquelle
   des extensions PHP MySQL (APIs), l'extension doit utiliser la bibliothèque mysqlnd.
  </para>
  <para>
   Puis, vous devez charger l'extension dans PHP, et activer le plugin dans le fichier
   de configuration de PHP en utilisant la directive de configuration PHP nommée
   <link linkend="ini.mysqlnd-qc.enable-qc">mysqlnd_qc.enable_qc</link>.
  </para>
  <para>
   <example>
    <title>Activation du plugin (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
]]>
    </programlisting>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.quickstart.caching">
  <title>Mise en cache des requêtes</title>
  <para>
   Il y a 4 façons de mettre en cache une requête.
   <itemizedlist>
    <listitem>
     <simpara>Utiliser une astuce SQL pour chaque requête</simpara>
    </listitem>
    <listitem>
     <simpara>
      L'utilisation fourni une fonction de rappel pour prise de décision pour chaque requête,
      par exemple, en utilisant la fonction <function>mysqlnd_qc_is_select</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Utilisation de la fonction <function>mysqlnd_set_cache_condition</function>
      pour des règles automatiques pour chaque requête
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Utilisation de la directive 
      <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>
      pour mettre en cache toutes les requêtes aveuglément
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   L'utilisation d'astuce SQL et de la directive de configuration
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>
   sont expliquées ci-dessous. Reportez-vous à la documentation sur la fonction
   <function>mysqlnd_qc_is_select</function> pour une description de l'utilisation d'une
   fonction de rappel et à la documentation sur la fonction
   <function>mysqlnd_qc_set_cache_condition</function> sur la façon pour
   définir des règles automatiques pour la mise en cache.
  </para>
  <para>
   Une astuce SQL est un commentaire standart SQL. Comme tout commentaire SQL, il sera
   ignoré par la base de données. Une requête est considérée éligible à la mise en cache
   si elle commence par une astuce SQL activant la mise en cache, ou si c'est une
   requête de type <literal>SELECT</literal>.
  </para>
  <para>
   Une requête individuelle qui doit être mise en cache doit commencer avec l'astuce SQL
   <literal>/*qc=on*/</literal>. Il est recommandé d'utiliser la constante PHP
   <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_ENABLE_SWITCH</link></literal>
   au lieu d'utiliser la chaîne ci-dessus.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      non éligible pour la mise en cache, et non mise en cache : <literal>INSERT INTO test(id) VALUES (1)</literal>
    </para>
    </listitem>
    <listitem>
     <para>
      non éligible à la mise en cache et non mise en cache : <literal>SHOW ENGINES</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      éligible à la mise en cache, mais non mise en cache : <literal>SELECT id FROM test</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      éligible à la mise en cache et mise en cache : <literal>/*qc=on*/SELECT id FROM test</literal>
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   L'exemple avec la chaîne de requête <literal>SELECT</literal> est préfixé
   avec l'astuce SQL <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_ENABLE_SWITCH</link></literal>
   pour active la mise en cache de la requête. L'astuce SQL doit être fournie
   au tout début de la chaîne de requête pour activer la mise en cache.
  </para>
  <para>
   <example>
    <title>Utilisation de l'astuce SQL <literal>MYSQLND_QC_ENABLE_SWITCH</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* Sera mis en cache en raison de la présence de l'astuce SQL */
$start = microtime(true);
$res = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
printf("Durée de la requête non mise en cache : %.6fs\n", microtime(true) - $start);

/* Récupération depuis le cache */
$start = microtime(true);
$res = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
printf("Durée de la requête mise en cache : %.6fs\n", microtime(true) - $start);
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
Durée de la requête non mise en cache : 0.000740s
array(1) {
  ["id"]=>
  string(1) "1"
}
Durée de la requête mise en cache : 0.000098s
]]>
    </screen>
   </example>
  </para>
  <para>
   Si rien de plus n'est configuré, comme c'est le cas dans l'exemple de démarrage rapide,
   le plugin utilisera le gestionnaire de stockage interne <literal>default</literal>.
   Le gestionnaire de stockage <literal>default</literal> utilise un processus
   mémoire pour stocker une entrée du cache. Suivant le modèle de déployement PHP,
   un processus PHP peut servir une ou plusieurs requêtes web. Veuillez consulter
   le manuel de votre serveur web pour plus de détails. Ces détails ne feront
   aucune différence dans les exemples de cette section.
  </para>
  <para>
   Le plugin de mise en cache de requêtes va mettre en cache toutes les requêtes
   si la chaîne commence par une astuce SQL qui active ou non la mise en cache,
   si la directive de configuration PHP
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default</link></literal>
   vaut <literal>1</literal>. La configuration
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default</link></literal>
   est évaluée par le coeur du plugin de mise en cache de requêtes. Aussi,
   ni le coeur du plugin, ni un gestionnaire de stockage défini par l'utilisateur ne
   peuvent écraser cette configuration.
  </para>
  <para>
   L'astuce SQL <literal>/*qc=off*/</literal> peut être utilisée pour désactiver
   la mise en cache d'une requête si
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>.
   Il est recommandé d'utiliser la constante PHP
   <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_DISABLE_SWITCH</link></literal>
   au lieu de la valeur litérale.
  </para>
  <para>
   <example>
    <title>Utilisation de l'astuce SQL <literal>MYSQLND_QC_DISABLE_SWITCH</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* Sera mise en cache malgré le fait qu'aucune astuce SQL ne soit présente,
car mysqlnd_qc.cache_by_default = 1*/
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

$mysqli->query("DELETE FROM test WHERE id = 1");

/* Récupération depuis le cache - aucune invalidation automatique, et donc, toujours valide ! */
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* Non présente dans le cache - la requête ne doit pas être mise en cache en raison de
la présence de l'astuce SQL */
$res = $mysqli->query("/*" . MYSQLND_QC_DISABLE_SWITCH . "*/SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "1"
}
NULL
]]>
    </screen>
   </example>
  </para>
  <para>
   PECL/mysqlnd_qc ne mettra pas en cache les requêtes pour lesquelles au moins
   une colonne du jeu de résultats ne contient pas le nom de la table dans ses
   méta-données par défaut. C'est habituellement le cas pour les colonnes
   provenant de fonctions SQL comme
   <literal>NOW()</literal> ou <literal>LAST_INSERT_ID()</literal>. La politique
   vise à éviter les pièges, si la mise en cache est utilisée par défaut.
  </para>
  <para>
   <example>
    <title>Exemple montrant les types de requêtes non mis en cache</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1)");

for ($i = 0; $i < 3; $i++) {

  $start = microtime(true);

  /* Note : la requête ne sera pas mise en cache car NOW() est utilisé */
  $res = $mysqli->query("SELECT id, NOW() AS _time FROM test");
  $row = $res->fetch_assoc();

  /* Affichage des résultats */
  var_dump($row);

  printf("Durée d'exécution : %.6fs\n", microtime(true) - $start);

  /* On attend une seconde */
  sleep(1);
}
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:10"
}
Durée d'exécution : 0.000540s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:11"
}
Durée d'exécution : 0.000555s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:12"
}
Durée d'exécution : 0.000549s
]]>
    </screen>
   </example>
  </para>
  <para>
   Il est possible d'activer la mise en cache pour toutes les requêtes,
   y compris celles qui contiennent des colonnes dans leur jeu de résultats
   pour lesquelles MySQL rapporte aucune table, comme la requête de l'exemple
   ci-dessus. Définissez la directive de configuration comme ceci
   <link linkend="ini.mysqlnd-qc.cache-no-table"><literal>mysqlnd_qc.cache_no_table = 1</literal></link>
   pour activer la mise en cache de telle requête. Notez la différence dans les
   durées mesurées de l'exemple ci-dessus et de l'exemple ci-dessous.
  </para>
  <para>
   <example>
    <title>Activation du cache pour toutes les requêtes
     en utilisant l'option de configuration ini
     <literal>mysqlnd_qc.cache_no_table</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
mysqlnd_qc.cache_no_table=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1)");

for ($i = 0; $i < 3; $i++) {

  $start = microtime(true);

  /* Note : la requête ne sera pas mise en cache car NOW() est utilisé */
  $res = $mysqli->query("SELECT id, NOW() AS _time FROM test");
  $row = $res->fetch_assoc();

  /* Affichage des résultats */
  var_dump($row);

  printf("Durée d'exécution : %.6fs\n", microtime(true) - $start);

  /* On attend une seconde */
  sleep(1);
}
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Total time: 0.000546s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Durée d'exécution : 0.000187s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Durée d'exécution : 0.000167s
]]>
    </screen>
   </example>
  </para>
  <note>
   <para>
    Bien que <link linkend="ini.mysqlnd-qc.cache-no-table"><literal>mysqlnd_qc.cache_no_table = 1</literal></link>
    a été créé pour une utilisation avec
    <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>,
    il y est lié. Le plugin va évaluer la directive
    <link linkend="ini.mysqlnd-qc.cache-no-table"><literal>mysqlnd_qc.cache_no_table</literal></link>
    à chaque fois qu'une requête est prête à être mise en cache, sans tenir compte de
    l'activation du cache en utilisant une astuce SQL ou toute autre mesure.
   </para>
  </note>
 </section>
 
 <section xml:id="mysqlnd-qc.per-query-ttl" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Définission du TTL</title>
  <para>
   La stratégie d'invalidation par défaut du plugin d'une requête du cache est
   Time to Live (<literal>TTL</literal>). Le gestionnaire de stockage interne
   utilisera le <literal>TTL</literal> par défaut, défini par la valeur de
   la directive de configuration
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.ttl</link></literal>
   à moins qu'une chaîne de requête ne contienne une astuce pour configurer
   un <literal>TTL</literal> différent. Le <literal>TTL</literal> est spécifié
   en seconde. Par défaut, une entrée du cache expire après
   <literal>30</literal> secondes.
  </para>
  <para>
   L'exemple définit <literal>mysqlnd_qc.ttl=3</literal> pour mettre en cache les requêtes
   pour 3 secondes par défaut. Chaque seconde, il met à jour un enregistrement
   d'une table de la base de données pour enregistrer l'heure courant et exécute
   une requête de type <literal>SELECT</literal> pour récupérer l'enregistrement
   depuis la base de données. La requête <literal>SELECT</literal> est mise en cache pour
   3 secondes, car elle est préfixée d'une astuce SQL activant la mise en cache.
   La sortie vérifie que les résultats de la requête sont prises depuis le cache
   pour la durée de ces 3 secondes avant d'être mis à jour.
  </para>
  <para>
   <example>
    <title>Définir un TTL avec l'option de configuration ini
     <literal>mysqlnd_qc.ttl</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.ttl=3
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id VARCHAR(255))");

for ($i = 0; $i < 7; $i++) {

  /* Mise à jour de la ligne de la base de données  */
  if (!$mysqli->query("DELETE FROM test") ||
      !$mysqli->query("INSERT INTO test(id) VALUES (NOW())"))

    /* Bien sûr, un vrai script devrait avoir un gestionnaire d'erreurs meileur */
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

  /* Sélection de la dernière ligne mais met en cache les résultats */
  $query  = "/*" . MYSQLND_QC_ENABLE_SWITCH . "*/";
  $query .= "SELECT id AS _time FROM test";
  if (!($res = $mysqli->query($query)) ||
      !($row = $res->fetch_assoc()))
  {
    printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
  }
  $res->free();
  printf("Heure : %s - Heure de la ligne dans la base de données : %s\n", date("H:i:s"), $row['_time']);

  /* Pause d'une seconde */
  sleep(1);
}
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
Heure : 14:55:59 - Heure de la ligne dans la base de données : 2012-01-11 14:55:59
Heure : 14:56:00 - Heure de la ligne dans la base de données : 2012-01-11 14:55:59
Heure : 14:56:01 - Heure de la ligne dans la base de données : 2012-01-11 14:55:59
Heure : 14:56:02 - Heure de la ligne dans la base de données : 2012-01-11 14:56:02
Heure : 14:56:03 - Heure de la ligne dans la base de données : 2012-01-11 14:56:02
Heure : 14:56:04 - Heure de la ligne dans la base de données : 2012-01-11 14:56:02
Heure : 14:56:05 - Heure de la ligne dans la base de données : 2012-01-11 14:56:05
]]>
    </screen>
   </example>
  </para>
  <para>
   Comme vous pouvez le voir dans cet exemple, n'importe quelle entrée du cache
   basée sur un <literal>TTL</literal> peut servir des données non mises à jour.
   Les entrées du cache ne sont pas automatiquement invalidées si les données
   ont été modifiées. Les applications utilisant la stratégie <literal>TTL</literal>
   par défaut d'invalidation doivent être capables de fonctionner correctement
   avec des données non mises à jour.
  </para>
  <para>
   Un gestionnaire de stockage défini par l'utilisateur peut implémenter n'importe
   quelle stratégie d'invalidation pour permettre de s'affranchir de cette limitation.
  </para>
  <para>
   Le <literal>TTL</literal> par défaut peut être écrasé en utilisant l'astuce SQL
   <literal>/*qc_tt=seconds*/</literal>. L'astuce SQL doit apparaître immédiatement
   après l'astuce SQL qui active la mise en cache. Il est recommandé d'utiliser la constante
   PHP <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_TTL_SWITCH</link></literal>
   au lieu d'utiliser la valeur litérale.
  </para>
  <para>
   <example>
    <title>Définir un TTL avec des astuces SQL</title>
    <programlisting role="php">
<![CDATA[
<?php
$start = microtime(true);

/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

printf("TTL par défaut \t: %d seconds\n", ini_get("mysqlnd_qc.ttl"));

/* Sera mise en cache pendant 2 secondes */
$sql = sprintf("/*%s*//*%s%d*/SELECT id FROM test WHERE id = 1",
 MYSQLND_QC_ENABLE_SWITCH,
 MYSQLND_QC_TTL_SWITCH,
 2);
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

$mysqli->query("DELETE FROM test WHERE id = 1");
sleep(1);

/* Récupération depuis le cache - aucune invalidation automatique et donc, toujours valide ! */
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

sleep(2);

/* Non présente en cache - l'entrée du cache a expiré */
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

printf("Temps d'exécution du script\t: %d seconds\n", microtime(true) - $start);
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
TTL par défaut     : 30 seconds
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "1"
}
NULL
Temps d'exécution du script  : 3 seconds
]]>
    </screen>
    
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.pattern-based-caching" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Mise en cache basée sur un masque</title>
  <para>
   Une application a 3 options pour demander à PECL/mysqlnd_qc si une requête doit être
   mise en cache ou non. L'approche la plus basique est de mettre en cache toutes les
   requêtes en définissant
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>.
   Cette approche est souvent peu pratique. Mais elle permet aux utilisateurs de
   prendre conscience rapidement des gains de performance de la mise en cache.
   Une application prévue pour utiliser un cache doit être capable de préfixer
   les requêtes sélectionnées avec l'astuce SQL appropriée. Cependant, le fait
   de modifier le code source d'une application peut ne pas toujours être possible
   ou désiré, par exemple, pour éviter des problèmes lors des mises à jour logicielles.
   Aussi, PECL/mysqlnd_qc autorise la définition d'une fonction de rappel qui décide
   si une requête doit être mise en cache ou non.
  </para>
  <para>
   La fonction de rappel est installée avec la fonction
   <function>mysqlnd_qc_set_is_select</function>. La fonction de rappel fournit
   la chaîne de requête pour chaque requête inspectée par le plugin. Alors, la
   fonction de rappel décide de la mise en cache ou non. La fonction de rappel
   est supposée retourner &false; si la requête ne doit pas être mise en cache.
   Si la valeur &true; est retournée, le plugin tentera d'ajouter la requête au cache.
   L'entrée du cache prendra le TTL par défaut (<literal><link linkend="mysqlnd-qc.configuration">
   mysqlnd_qc.ttl</link></literal>). Si la fonction de rappel retourne une valeur
   numérique, elle sera utilisée comme TTL au lieu de la valeur par défaut.
  </para>
  <para>
   <example>
    <title>Définir une fonction de rappel avec
     <function>mysqlnd_qc_set_is_select</function></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_statistics=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* fonction de rappel qui va décider si la requête doit être mise en cache ou non */
function is_select($query) {
  static $patterns = array(
   /* true - utilisation du TTL par défaut depuis mysqlnd_qc.ttl */
   "@SELECT\s+.*\s+FROM\s+test@ismU" => true,
   /* 3 - utilisation d'un TTL = 3 secondes */
   "@SELECT\s+.*\s+FROM\s+news@ismU" => 3
  );

  /* vérifie si la requête correspond au masque */
  foreach ($patterns as $pattern => $ttl) {
    if (preg_match($pattern, $query)) {
      printf("is_select(%45s): mise en cache\n", $query);
      return $ttl;
    }
  }
  printf("is_select(%45s): pas de mise en cache\n", $query);
  return false;
}
/* Installation de la fonction de rappel */
mysqlnd_qc_set_is_select("is_select");

/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* Mise en cache */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* Récupération depuis le cache */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* Mise en cache */
$mysqli->query("SELECT * FROM test");

$stats = mysqlnd_qc_get_core_stats();
printf("Mise en cache : %d\n", $stats['cache_put']);
printf("Récupération depuis le cache : %d\n", $stats['cache_hit']);
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
is_select(                    DROP TABLE IF EXISTS test): pas de mise en cache
is_select(                    CREATE TABLE test(id INT)): pas de mise en cache
is_select(    INSERT INTO test(id) VALUES (1), (2), (3)): pas de mise en cache
is_select(             SELECT id FROM test WHERE id = 1): mise en cache
is_select(             SELECT id FROM test WHERE id = 1): mise en cache
is_select(                           SELECT * FROM test): mise en cache
Mise en cache : 2
Récupération depuis le cache : 1
]]>
    </screen>
   </example>
  </para>
  <para>
   La fonction de rappel de cet exemple teste si une chaîne de requête
   correspond au masque. Si c'est le cas, elle retournera soit &true;
   pour mettre en cache la requête en utilisant le TTL par défaut,
   soit un TTL alternatif.
  </para>
  <para>
   Pour minimiser les modifications de l'application, la fonction
   de rappel peut être mise dans un fichier qui sera par la suite inclut
   dans le script.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.slam-defense" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Défense de type slam</title>
  <para>
   Un cache mal structuré peut faire plus de mal que de bien. Dans le pire
   des cas, un cache peut accroître la charge du serveur de base de données au
   lieu de la diminuer. Une situation de surcharge peut survenir si un grand
   nombre d'entrées partagées du cache expirent (débandade du cache).
  </para>
  <para>
   Les entrées du cache sont partagées et réutilisées à différents degrés suivant
   le mode de stockage utilisé. Le gestionnaire de stockage par défaut stocke
   les entrées en mémoire. Ainsi, une entrée du cache peut être réutilisée pendant
   la durée de vie du processus. Les autres processus PHP ne peuvent pas y accéder.
   Si Memcache est utilisé, une entrée du cache peut être partagée pour plusieurs
   processus PHP, sur différentes machaines, suivant la configuration utilisée.
  </para>
  <para>
   Si un grand nombre d'entrées partagées du cache stockées par exemple dans Memcache
   expirent, plusieurs clients se verront informés de l'absence de l'entrée
   dans le cache. A ce moment, vu que ces clients ne peuvent récupérer les données
   depuis le cache, ils tentent de les récupérer depuis le serveur de base de données.
   Tant que l'entrée du cache n'est pas mise à jour, de plus en plus de clients
   contacteront le serveur de base de données. Dans le pire des cas, cela peut conduire
   à une perte totale du service.
  </para>
  <para>
   La surcharge peut être évitée en utilisant un gestionnaire de stockage qui limite
   la réutilisation d'une entrée du cache à un nombre limité de clients. Alors, si
   le cas extrême est rencontré, ce ne sera qu'un nombre limité de clients
   qui tenteront de mettre à jour l'entrée du cache en même temps.
  </para>
  <para>
   De plus, le mécanisme de défense interne de type slam peut et doit être utilisé.
   Si cette défense est activée, une entrée du cache expirée reçoit une extension
   de durée de vie. Le premier client qui récupère une entrée manquante car expirée
   tentera de la mettre à jour pendant la durée de cette extension. Tous les autres
   clients demandant cette entrée sont temporairement servis depuis le cache malgré
   le fait que le <literal>TTL</literal> original de cette entrée a expiré. Les autres
   clients ne recevront pas comme réponse le fait que l'entrée n'est pas présente
   dans le cache tant que cette extension de vie ne sera pas atteinte.
  </para>
  <para>
   <example>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.slam_defense=1
mysqlnd_qc.slam_defense_ttl=1
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Le mécanisme de défense de type slam est activé avec la direction de configuration PHP
   <link linkend="ini.mysqlnd-qc.slam-defense"><literal>mysqlnd_qc.slam_defense</literal></link>.
   L'extension de durée de vie d'une entrée du cache est définie avec la directive
   <link linkend="ini.mysqlnd-qc.slam-defense-ttl"><literal>mysqlnd_qc.slam_defense_ttl</literal></link>.
  </para>
  <para>
   La fonction <function>mysqlnd_qc_get_core_stats</function> retourne un tableau de statistiques.
   Les statistiques <literal>slam_stale_refresh</literal> et <literal>slam_stale_hit</literal>
   sont incrémentées si une défense de type slam est mise en place.
  </para>
  <para>
   Il n'est pas possible de fournir une recommandation générale concernant la configuration
   de la défense de type slam. Les utilisateurs sont encouragés à surveiller
   et tester leur configuration et d'ajuster leur configuration en conséquent.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.cache-candidates" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Trouver des candidats à la mise en cache</title>
  <para>
   Une requête doit être considérée comme pouvant être mise en cache si elle est
   souvent exécutée et qu'elle a un temps d'exécution élevé. Les candidats sont trouvés
   en créant une liste de requêtes triées par le produit du nombre d'exécutions,
   multiplié par le temps d'exécution de la requête. La fonction
   <function>mysqlnd_qc_get_query_trace_log</function> retourne une trace permettant
   d'aider dans cette tâche.
  </para>
  <para>
   La collecte d'une trace de requête est une opération lente. Aussi, cette opération
   est désactivée par défaut. La directive de configuration PHP
   <link linkend="ini.mysqlnd-qc.collect-query-trace"><literal>mysqlnd_qc.collect_query_trace</literal></link>
   est utilisée pour l'activer. Les traces des fonctions contiennent une entrée pour
   chaque requête émise avant l'appel à la fonction.
  </para>
  <para>
   <example>
    <title>Collecte d'une requête de traçage</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_query_trace=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* connexion à MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");

/* quelques requêtes pour remplir les traces de requêtes */
for ($i = 0; $i < 2; $i++) {
  $res = $mysqli->query("SELECT 1 AS _one FROM DUAL");
  $res->free();
}

/* Affichage des traces */
var_dump(mysqlnd_qc_get_query_trace_log());
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(2) {
  [0]=>
  array(8) {
    ["query"]=>
    string(26) "SELECT 1 AS _one FROM DUAL"
    ["origin"]=>
    string(102) "#0 qc.php(7): mysqli->query('SELECT 1 AS _on...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(25)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [1]=>
  array(8) {
    ["query"]=>
    string(26) "SELECT 1 AS _one FROM DUAL"
    ["origin"]=>
    string(102) "#0 qc.php(7): mysqli->query('SELECT 1 AS _on...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(8)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
}
]]>
    </screen>
   </example>
  </para>
  <para>
   D'autres informations sont fournies dans les trâces. Parmi elles,
   les horaires et l'origine de l'appel à la requête. La propriété origin
   contient une trace du code pour identifier la source de la requête.
   La profondeur de la trace du code peut être limitée avec la directive
   de configuration PHP
   <link linkend="ini.mysqlnd-qc.query-trace-bt-depth"><literal>mysqlnd_qc.query_trace_bt_depth</literal></link>.
   La profondeur par défaut est <literal>3</literal>.
  </para>
  <para>
   <example>
    <title>Définir la profondeur des traces avec l'option
     de configuration ini <literal>mysqlnd_qc.query_trace_bt_depth</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_query_trace=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* connexion à MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* quelques requêtes pour remplir les traces */
for ($i = 0; $i < 3; $i++) {
  $res = $mysqli->query("SELECT id FROM test WHERE id = " . $mysqli->real_escape_string($i));
  $res->free();
}

$trace = mysqlnd_qc_get_query_trace_log();
$summary = array();
foreach ($trace as $entry) {
  if (!isset($summary[$entry['query']])) {
    $summary[$entry['query']] = array(
      "executions" => 1,
      "time"       => $entry['run_time'] + $entry['store_time'],
    );
  } else {
    $summary[$entry['query']]['executions']++;
    $summary[$entry['query']]['time'] += $entry['run_time'] + $entry['store_time'];
 }
}
foreach ($summary as $query => $details) {
  printf("%45s: %5dms (%dx)\n",
   $query, $details['time'], $details['executions']);
}
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
                    DROP TABLE IF EXISTS test:     0ms (1x)
                    CREATE TABLE test(id INT):     0ms (1x)
    INSERT INTO test(id) VALUES (1), (2), (3):     0ms (1x)
             SELECT id FROM test WHERE id = 0:    25ms (1x)
             SELECT id FROM test WHERE id = 1:    10ms (1x)
             SELECT id FROM test WHERE id = 2:     9ms (1x)
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.cache-efficiency" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Mesure de l'efficacité du cache</title>
  <para>
   PECL/mysqlnd_qc fournit 3 façons de mesurer l'efficacité du
   cache. La fonction
   <function>mysqlnd_qc_get_normalized_query_trace_log</function>
   retourne des statistiques aggrégées par la normalisation
   d'une chaîne de requête, la fonction
   <function>mysqlnd_qc_get_cache_info</function> fournit des informations
   spécifiques au gestionnaire de stockage qui incluent une liste de
   tous les éléments mis en cache, suivant le gestionnaire de stockage.
   De plus, le cooeur de PECL/mysqlnd_qc collecte un résumé haut niveau
   des statistiques aggrégées par processus PHP. Les statistiques
   haut niveau sont retournées par la fonction
   <function>mysqlnd_qc_get_core_stats</function>.
  </para>
  <para>
   Les fonctions <function>mysqlnd_qc_get_normalized_query_trace_log</function>
   et <function>mysqlnd_qc_get_core_stats</function> ne collecteront pas
   de données tant que leurs directives de configuration PHP correspondantes
   ne sont pas activées. Veuillez vous reporter aux différents exemples
   pour récupérer les noms de ces directives de configuration. La collecte
   de données est désactivée par défaut et ce, en raison des impacts
   sur la performances. Elle est configurable via la directive de
   configuration <link linkend="ini.mysqlnd-qc.time-statistics">
   <literal>mysqlnd_qc.time_statistics</literal></link>. La collecte
   de statistiques quant au durée est activée par défaut mais uniquement
   effectuée si la collecte de données a été activée.
   Le fait d'enregistrer des statistiques quant au durée cause
   beaucoup d'appels système. Dans la plupart des cas, le bénéfice
   d'une surveillance l'emporte sur la perte de performance dûe
   aux appels système additionnelles.
  </para>
  <para>
   <example>
    <title>Collecte de données statistiques avec 
     la configuration ini <literal>mysqlnd_qc.time_statistics</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_statistics=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* connexion à MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* quelques requêtes */
for ($i = 1; $i <= 4; $i++) {
  $query = sprintf("/*%s*/SELECT id FROM test WHERE id = %d",
     MYSQLND_QC_ENABLE_SWITCH,
     $i % 2);
  $res = $mysqli->query($query);
  $res->free();
}

var_dump(mysqlnd_qc_get_core_stats());
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(26) {
  ["cache_hit"]=>
  string(1) "2"
  ["cache_miss"]=>
  string(1) "2"
  ["cache_put"]=>
  string(1) "2"
  ["query_should_cache"]=>
  string(1) "4"
  ["query_should_not_cache"]=>
  string(1) "3"
  ["query_not_cached"]=>
  string(1) "3"
  ["query_could_cache"]=>
  string(1) "4"
  ["query_found_in_cache"]=>
  string(1) "2"
  ["query_uncached_other"]=>
  string(1) "0"
  ["query_uncached_no_table"]=>
  string(1) "0"
  ["query_uncached_no_result"]=>
  string(1) "0"
  ["query_uncached_use_result"]=>
  string(1) "0"
  ["query_aggr_run_time_cache_hit"]=>
  string(2) "28"
  ["query_aggr_run_time_cache_put"]=>
  string(3) "900"
  ["query_aggr_run_time_total"]=>
  string(3) "928"
  ["query_aggr_store_time_cache_hit"]=>
  string(2) "14"
  ["query_aggr_store_time_cache_put"]=>
  string(2) "40"
  ["query_aggr_store_time_total"]=>
  string(2) "54"
  ["receive_bytes_recorded"]=>
  string(3) "136"
  ["receive_bytes_replayed"]=>
  string(3) "136"
  ["send_bytes_recorded"]=>
  string(2) "84"
  ["send_bytes_replayed"]=>
  string(2) "84"
  ["slam_stale_refresh"]=>
  string(1) "0"
  ["slam_stale_hit"]=>
  string(1) "0"
  ["request_counter"]=>
  int(1)
  ["process_hash"]=>
  int(1929695233)
}
]]>
    </screen>
   </example>
  </para>
  <para>
   Pour une vue rapide, appelez la fonction
   <function>mysqlnd_qc_get_core_stats</function>. Elle délivre l'utilisation
   du cache, les durées du cache, ainsi que les statistiques relatives au trafic.
   Les valeurs sont aggrégées pour chaque processus pour toutes les requêtes
   émises par n'importe quel appel API à PHP MySQL.
  </para>
  <para>
   Quelques gestionnaires de stockage, comme le gestionnaire par défaut, peuvent
   signaler les entrées du cache, les statistiques relatives aux entrées et aux méta-données
   pour la requête sous-jacente via la fonction
   <function>mysqlnd_qc_get_cache_info</function>. Notez que les informations
   retournées dépendant du gestionnaire de stockage. Les valeurs sont aggrégées pour
   chaque processus.
  </para>
  <para>
   <example>
    <title>Exemple avec <function>mysqlnd_qc_get_cache_info</function></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* connexion à MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* quelques requêtes pour remplir les traces */
for ($i = 1; $i <= 4; $i++) {
  $query = sprintf("/*%s*/SELECT id FROM test WHERE id = %d",
     MYSQLND_QC_ENABLE_SWITCH,
     $i % 2);
  $res = $mysqli->query($query);
  $res->free();
}
var_dump(mysqlnd_qc_get_cache_info());
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(4) {
  ["num_entries"]=>
  int(2)
  ["handler"]=>
  string(7) "default"
  ["handler_version"]=>
  string(5) "1.0.0"
  ["data"]=>
  array(2) {
    ["Localhost via UNIX socket
3306
root
test|/*qc=on*/SELECT id FROM test WHERE id = 1"]=>
    array(2) {
      ["statistics"]=>
      array(11) {
        ["rows"]=>
        int(1)
        ["stored_size"]=>
        int(71)
        ["cache_hits"]=>
        int(1)
        ["run_time"]=>
        int(391)
        ["store_time"]=>
        int(27)
        ["min_run_time"]=>
        int(16)
        ["max_run_time"]=>
        int(16)
        ["min_store_time"]=>
        int(8)
        ["max_store_time"]=>
        int(8)
        ["avg_run_time"]=>
        int(8)
        ["avg_store_time"]=>
        int(4)
      }
      ["metadata"]=>
      array(1) {
        [0]=>
        array(8) {
          ["name"]=>
          string(2) "id"
          ["orig_name"]=>
          string(2) "id"
          ["table"]=>
          string(4) "test"
          ["orig_table"]=>
          string(4) "test"
          ["db"]=>
          string(4) "test"
          ["max_length"]=>
          int(1)
          ["length"]=>
          int(11)
          ["type"]=>
          int(3)
        }
      }
    }
    ["Localhost via UNIX socket
3306
root
test|/*qc=on*/SELECT id FROM test WHERE id = 0"]=>
    array(2) {
      ["statistics"]=>
      array(11) {
        ["rows"]=>
        int(0)
        ["stored_size"]=>
        int(65)
        ["cache_hits"]=>
        int(1)
        ["run_time"]=>
        int(299)
        ["store_time"]=>
        int(13)
        ["min_run_time"]=>
        int(11)
        ["max_run_time"]=>
        int(11)
        ["min_store_time"]=>
        int(6)
        ["max_store_time"]=>
        int(6)
        ["avg_run_time"]=>
        int(5)
        ["avg_store_time"]=>
        int(3)
      }
      ["metadata"]=>
      array(1) {
        [0]=>
        array(8) {
          ["name"]=>
          string(2) "id"
          ["orig_name"]=>
          string(2) "id"
          ["table"]=>
          string(4) "test"
          ["orig_table"]=>
          string(4) "test"
          ["db"]=>
          string(4) "test"
          ["max_length"]=>
          int(0)
          ["length"]=>
          int(11)
          ["type"]=>
          int(3)
        }
      }
    }
  }
}
]]>
    </screen>
   </example>
  </para>
  <para>
   Il est possible de décomposer davantage le niveau de granularité des statistiques
   au niveau de la chaîne de requête normalisée. La chaîne de requête
   normalisée correspond à la chaîne de requête avec tous les paramètres
   remplacés avec les marqueurs. Par exemple, les deux requêtes
   <literal>SELECT id FROM test WHERE id = 0</literal> et
   <literal>SELECT id FROM test WHERE id = 1</literal> sont normalisées
   en <literal>SELECT id FROM test WHERE id = ?</literal>. Les statistiques
   pour ces deux requêtes sont aggrégées en une seule entrée pour
   <literal>SELECT id FROM test WHERE id = ?</literal>.
  </para>
  <para>
    <title>Exemple avec <function>mysqlnd_qc_get_normalized_query_trace_log</function></title>
   <example>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_normalized_query_trace=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* connexion à MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* quelques requêtes pour remplir les traces */
for ($i = 1; $i <= 4; $i++) {
  $query = sprintf("/*%s*/SELECT id FROM test WHERE id = %d",
     MYSQLND_QC_ENABLE_SWITCH,
     $i % 2);
  $res = $mysqli->query($query);
  $res->free();
}
var_dump(mysqlnd_qc_get_normalized_query_trace_log());
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  array(9) {
    ["query"]=>
    string(25) "DROP TABLE IF EXISTS test"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [1]=>
  array(9) {
    ["query"]=>
    string(27) "CREATE TABLE test (id INT )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [2]=>
  array(9) {
    ["query"]=>
    string(46) "INSERT INTO test (id ) VALUES (? ), (? ), (? )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [3]=>
  array(9) {
    ["query"]=>
    string(31) "SELECT id FROM test WHERE id =?"
    ["occurences"]=>
    int(4)
    ["eligible_for_caching"]=>
    bool(true)
    ["avg_run_time"]=>
    int(179)
    ["min_run_time"]=>
    int(11)
    ["max_run_time"]=>
    int(393)
    ["avg_store_time"]=>
    int(12)
    ["min_store_time"]=>
    int(7)
    ["max_store_time"]=>
    int(25)
  }
}
]]>
    </screen>
   </example>
  </para>
  <para>
   Les sources de la distribution de PECL/mysqlnd_qc contiennent un
   dossier <literal>web/</literal> dans lequel se trouve un script
   fournissant un exemple de surveillance du cache. Veuillez suivre les
   instructions se trouvant dans cette source.
  </para>
  <para>
   Depuis PECL/mysqlnd_qc 1.1.0, il est possible d'écrire les statistiques
   dans un fichier de log. Voir la directive de configuration
   log file. Please, see <literal><link linkend="ini.mysqlnd-qc.collect-statistics-log-file">
   mysqlnd_qc.collect_statistics_log_file</link></literal> pour plus d'informations.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.set-user-handlers" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Au-dela du TTL : gestionnaire de stockage défini par l'utilisateur</title>
  <para>
   Le plugin de mise en cache de requête supporte l'utilisation d'un gestionnaire
   de stockage défini par l'utilisateur. Ce type de gestionnaire peut utilisé
   arbitrairement un algorithme complexe d'invalidation, et supporte le stockage
   sur divers médias.
  </para>
  <para>
   Tous les gestionnaires de stockage définis par l'utilisateur doivent fournie
   une certaine interface. Les fonctions du gestionnaire de stocké défini
   par l'utilisateur seront appelées par le coeur du plugin de mise en cache.
   L'interface nécessaire consiste en 7 fonctions publiques. Le gestionnaire
   de stockage défini par l'utilisateur peut être écrit de façon procédurale
   ou orientée objet.
  </para>
  <para>
   <title>Utilisation d'un gestionnaire de stockage défini par l'utilisateur</title>
   <example>
    <programlisting role="php">
<![CDATA[
<?php
/* Activation de la mise en cache de toutes les requêtes par défaut */
ini_set("mysqlnd_qc.cache_by_default", 1);

/* Fonctions composant le gestionnaire de stockage défini par l'utilisateur, de façon procédurale */

$__cache = array();

function get_hash($host_info, $port, $user, $db, $query) {
  global $__cache;
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

  return md5(sprintf("%s%s%s%s%s", $host_info, $port, $user, $db, $query));
}

function find_query_in_cache($key) {
  global $__cache;
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

  if (isset($__cache[$key])) {
    $tmp = $__cache[$key];
    if ($tmp["valid_until"] < time()) {
      unset($__cache[$key]);
      $ret = NULL;
    } else {
      $ret = $__cache[$key]["data"];
    }
  } else {
    $ret = NULL;
  }

  return $ret;
}

function return_to_cache($key) {
  /*
     Appelé lors de la récupération d'une entrée du cache après que les données mises en
     cache ne soient traitées ; peut être utilisé pour le comptage des références
  */
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());
}

function add_query_to_cache_if_not_exists($key, $data, $ttl, $run_time, $store_time, $row_count) {
  global $__cache;
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

  $__cache[$key] = array(
    "data"               => $data,
    "row_count"          => $row_count,
    "valid_until"        => time() + $ttl,
    "hits"               => 0,
    "run_time"           => $run_time,
    "store_time"         => $store_time,
    "cached_run_times"   => array(),
    "cached_store_times" => array(),
  );

  return TRUE;
}

function query_is_select($query) {
  printf("\t%s('%s'): ", __FUNCTION__, $query);

  $ret = FALSE;
  if (stristr($query, "SELECT") !== FALSE) {
    /* Mise en cache pour 5 secondes */
    $ret = 5;
  }

  printf("%s\n", (FALSE === $ret) ? "FALSE" : $ret);
  return $ret;
}

function update_query_run_time_stats($key, $run_time, $store_time) {
  global $__cache;
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

  if (isset($__cache[$key])) {
    $__cache[$key]['hits']++;
    $__cache[$key]["cached_run_times"][] = $run_time;
    $__cache[$key]["cached_store_times"][] = $store_time;
  }
}

function get_stats($key = NULL) {
  global $__cache;
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

  if ($key && isset($__cache[$key])) {
    $stats = $__cache[$key];
  } else {
    $stats = array();
    foreach ($__cache as $key => $details) {
      $stats[$key] = array(
        'hits'              => $details['hits'],
        'bytes'             => strlen($details['data']),
        'uncached_run_time' => $details['run_time'],
        'cached_run_time'   => (count($details['cached_run_times']))
                                  ? array_sum($details['cached_run_times']) / count($details['cached_run_times'])
                                  : 0,
      );
    }
  }

  return $stats;
}

function clear_cache() {
  global $__cache;
  printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

  $__cache = array();
  return TRUE;
}

/* Installation du gestionnaire procédural de stockage défini par l'utilisateur */
if (!mysqlnd_qc_set_user_handlers("get_hash", "find_query_in_cache",
      "return_to_cache", "add_query_to_cache_if_not_exists",
      "query_is_select", "update_query_run_time_stats",
       "get_stats", "clear_cache")) {
  printf("Echec lors de l'installation du gestionnaire de stockage défini par l'utilisateur\n");
}


/* Connexion, création et peuplement de la table test */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

printf("\nMise en cache/Absence du cache\n");

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* Suppression de l'enregistrement pour vérifier que nous récupérons bien nos
données depuis le cache */
$mysqli->query("DELETE FROM test WHERE id = 1");

printf("\nRécupération depuis le cache\n");

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

printf("\nAffichage des statistiques relatives au cache\n");
var_dump(mysqlnd_qc_get_cache_info());

printf("\nRé-initialisation du cache, mise en cache/absence du cache");
var_dump(mysqlnd_qc_clear_cache());

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
        query_is_select('DROP TABLE IF EXISTS test'): FALSE
        query_is_select('CREATE TABLE test(id INT)'): FALSE
        query_is_select('INSERT INTO test(id) VALUES (1), (2)'): FALSE

Mise en cache/Absence du cache
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        add_query_to_cache_if_not_exists(6)
array(1) {
  ["id"]=>
  string(1) "1"
}
        query_is_select('DELETE FROM test WHERE id = 1'): FALSE

Récupération depuis le cache
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        return_to_cache(1)
        update_query_run_time_stats(3)
array(1) {
  ["id"]=>
  string(1) "1"
}

Affichage des statistiques relatives au cache
        get_stats(0)
array(4) {
  ["num_entries"]=>
  int(1)
  ["handler"]=>
  string(4) "user"
  ["handler_version"]=>
  string(5) "1.0.0"
  ["data"]=>
  array(1) {
    ["18683c177dc89bb352b29965d112fdaa"]=>
    array(4) {
      ["hits"]=>
      int(1)
      ["bytes"]=>
      int(71)
      ["uncached_run_time"]=>
      int(398)
      ["cached_run_time"]=>
      int(4)
    }
  }
}

Ré-initialisation du cache, mise en cache/absence du cache    clear_cache(0)
bool(true)
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        add_query_to_cache_if_not_exists(6)
NULL

]]>
    </screen>
    
   </example>
  </para>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
