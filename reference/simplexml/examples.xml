<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: f77812a49215c5c305d16800cb98147ad5019bc5 Maintainer: dams Status: ready -->
<!-- Reviewed: yes -->

<chapter xml:id="simplexml.examples" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 &reftitle.examples;
 <section xml:id="simplexml.examples-basic">
  <title>Utilisation de base</title>
  <para>
   Plusieurs exemples de ce chapitre requièrent une chaîne XML. Plutôt que
   de la répéter à chaque exemple, nous allons la placer dans un fichier que
   nous inclurons dans chacun d'entre eux. Le contenu de ce fichier est
   illustré par l'exemple qui suit. Autrement, vous pouvez créer
   un document XML et le lire avec <function>simplexml_load_file</function>.
  </para>
  <para>
   <example>
    <title>Fichier avec une chaîne XML qui sera inclus partout</title>
    <programlisting role="php" xml:id="simplexml.examples.movie">
<![CDATA[
<?php
$xmlstr = <<<XML
<?xml version='1.0' standalone='yes'?>
<movies>
 <movie>
  <title>PHP: Behind the Parser</title>
  <characters>
   <character>
    <name>Ms. Coder</name>
    <actor>Onlivia Actora</actor>
   </character>
   <character>
    <name>Mr. Coder</name>
    <actor>El Act&#211;r</actor>
   </character>
  </characters>
  <plot>
   So, this language. It's like, a programming language. Or is it a
   scripting language? All is revealed in this thrilling horror spoof
   of a documentary.
  </plot>
  <great-lines>
   <line>PHP solves all my web problems</line>
  </great-lines>
  <rating type="thumbs">7</rating>
  <rating type="stars">5</rating>
 </movie>
</movies>
XML;
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La simplicité de SimpleXML apparaît plus clairement lorsqu'on essaye
   d'extraire une chaîne ou un nombre d'un document XML basique.
   <example>
    <title>Lecture de <literal>&lt;plot&gt;</literal></title>
    <programlisting role="php"><![CDATA[
<?php
include 'example.php';

$xml = new SimpleXMLElement($xmlstr);

echo $xml->movie[0]->plot; // "So this language. It's like..."
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   L'accès aux éléments d'un document XML qui contient des caractères non permis par
   rapport à la convention de nommage de PHP (e.g. les mots clés) est possible
   en encapsulant le nom de l'élément entre crochets et apostrophes.
   <example>
    <title>Récupération de <literal>&lt;line&gt;</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
include 'example.php';

$xml = new SimpleXMLElement($xmlstr);

echo $xml->movie->{'great-lines'}->line; // "PHP solves all my web problems"
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Accéder à un élément non-unique avec SimpleXML</title>
    <simpara>
     Lorsque plusieurs instances d'un élément existent en tant que fils d'un
     élément père unique, les techniques normales d'itération peuvent être
     appliquées.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
include 'example.php';

$xml = new SimpleXMLElement($xmlstr);

/* Pour chaque <movie>, nous affichons un <plot>. */
foreach ($xml->movie as $movie) {
   echo $movie->plot, '<br />';
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <note>
   <para>
    Les propriétés (<literal>$xml->movie</literal> dans notre précédent exemple)
    ne sont pas des tableaux. Ceux sont des objets 
    <link linkend="class.iterator">itérables</link> et
    <link linkend="class.arrayaccess">accessibles</link>.
   </para>
  </note>
  <para>
   <example>
    <title>Utilisation des attributs</title>
    <simpara>
     Jusque là, nous n'avons couvert que la lecture des noms d'éléments et
     leurs valeurs. SimpleXML peut aussi atteindre leurs attributs.
     L'accès aux attributs d'un élément se fait de la même façon que l'accès
     aux éléments d'un tableau.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
include 'example.php';

$xml = new SimpleXMLElement($xmlstr);

/* Accès au node <rating> du premier <movie>.
 * Affichage des attributs de <rating> également. */
foreach ($xml->movie[0]->rating as $rating) {
    switch((string) $rating['type']) { // Récupération des attributs comme indices d'éléments
    case 'thumbs':
        echo $rating, ' thumbs up';
        break;
    case 'stars':
        echo $rating, ' stars';
        break;
    }
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Comparaison des éléments et des attributs avec du texte</title>
    <simpara>
     Pour comparer un élément ou un attribut avec une chaîne de caractères
     ou pour le passer à une fonction qui nécessite une chaîne de caractères,
     vous devez le transtyper en une chaîne en utilisant
     <literal>(string)</literal>.
     Sinon, PHP traitera l'élément comme un objet.
    </simpara>
    <programlisting role="php"><![CDATA[
<?php
include 'example.php';

$xml = new SimpleXMLElement($xmlstr);

if ((string) $xml->movie->title == 'PHP: Behind the Parser') {
    print 'My favorite movie.';
}

htmlentities((string) $xml->movie->title);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Comparaison de 2 éléments</title>
    <simpara>
     Deux objets <classname>SimpleXMLElement</classname> 
     sont considérés comme différents même s'ils
     pointent vers le même élément, depuis PHP 5.2.0.
    </simpara>
    <programlisting role="php"><![CDATA[
<?php
$el1 = new SimpleXMLElement($xmlstr);
$el2 = new SimpleXMLElement($xmlstr);
var_dump($el1 == $el2); // retourne false depuis PHP 5.2.0
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Utilisation de XPath</title>
    <simpara>
     SimpleXML inclut le support embarqué de <acronym>XPath</acronym>.
     Pour trouver tous les éléments <literal>&lt;character&gt;</literal> :
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
include 'example.php';
$xml = new SimpleXMLElement($xmlstr);

foreach ($xml->xpath('//character') as $character) {
    echo $character->name, 'played by ', $character->actor, '<br />';
}
?>
]]>
    </programlisting>
    <simpara>
     '<literal>//</literal>' sert de joker. Pour spécifier un chemin absolu,
     enlevez un slash.
    </simpara>
   </example>
  </para>
  <para>
   <example>
    <title>Attribuer des valeurs</title>
    <simpara>
     Les données dans SimpleXML n'ont pas à être constantes. L'objet permet
     la manipulation de tous ces éléments.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
include 'example.php';
$xml = new SimpleXMLElement($xmlstr);

$xml->movie[0]->characters->character[0]->name = 'Miss Coder';

echo $xml->asXML();
?>
]]>
    </programlisting>
    <simpara>
     L'exemple précédent affichera un nouveau document XML, tout comme
     l'original mise à part que le nouveau document XML définit
     <literal>Ms. Coder</literal> à <literal>Miss Coder</literal>.
    </simpara>
   </example>
  </para>
  <para>
   <example>
    <title>Ajout d'éléments et d'attributs</title>
    <simpara>
     Depuis PHP 5.1.3, SimpleXML est capable d'ajouter facilement des
     enfants et des attributs.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
include 'example.php';
$xml = new SimpleXMLElement($xmlstr);

$character = $xml->movie[0]->characters->addChild('character');
$character->addChild('name', 'Mr. Parser');
$character->addChild('actor', 'John Doe');

$rating = $xml->movie[0]->addChild('rating', 'PG');
$rating->addAttribute('type', 'mpaa');

echo $xml->asXML();
?>
]]>
    </programlisting>
    <simpara>
     Le code ci-dessus sortira un document XML basé sur l'original mais
     ayant un nouveau personnage et résultat.
    </simpara>
   </example>
  </para>
  <para>
   <example>
    <title>Interopérabilité DOM</title>
    <simpara>
     PHP possède un mécanisme pour convertir les noeuds XML entre les formats
     SimpleXML et DOM. Cet exemple montre comment changer un élément DOM en
     SimpleXML.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php
$dom = new domDocument;
$dom->loadXML('<books><book><title>blah</title></book></books>');
if (!$dom) {
     echo 'Erreur lors de l'analyse du document';
     exit;
}

$s = simplexml_import_dom($dom);

echo $s->book[0]->title;
?>
]]>
    </programlisting>
   </example>
  </para>
 </section>
 
 <section xml:id="simplexml.examples-errors">
  <title>Traitement des erreurs XML</title>
  <para>
   Le traitement des erreurs XML lors du chargement d'un document est
   une tâche simple. En utilisant les fonctionnalités
   <link linkend="book.libxml">libxml</link>, il est possible de supprimer
   toutes les erreurs XML lors du chargement d'un document, puis, de les parcourir.
  </para>
  <para>
   L'objet <classname>libXMLError</classname>, retourné par la fonction
   <function>libxml_get_errors</function>, contient plusieurs propriétés
   dont le <link linkend="libxmlerror.props.message">message</link>,
   la <link linkend="libxmlerror.props.line">ligne</link> et la
   <link linkend="libxmlerror.props.column">colonne</link> (position) de l'erreur.
  </para>
  <para>
   <example>
    <title>Chargement de chaînes XML cassées</title>
    <programlisting role="php" xml:id="simplexml.examples.error">
<![CDATA[
<?php
libxml_use_internal_errors(true);
$sxe = simplexml_load_string("<?xml version='1.0'><broken><xml></broken>");
if (!$sxe) {
    echo "Erreur lors du chargement du XML\n";
    foreach(libxml_get_errors() as $error) {
        echo "\t", $error->message;
    }
}
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Erreur lors du chargement du XML
    Blank needed here
    parsing XML declaration: '?>' expected
    Opening and ending tag mismatch: xml line 1 and broken
    Premature end of data in tag broken line 1
]]>
    </screen>
   </example>
  </para>
  <section role="seealso"><!-- {{{ -->
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>libxml_use_internal_errors</function></member>
     <member><function>libxml_get_errors</function></member>
     <member><xref linkend="class.libxmlerror" /></member>
    </simplelist>
   </para>
  </section>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

