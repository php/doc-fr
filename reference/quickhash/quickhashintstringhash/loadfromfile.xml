<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: bfe06c36ec1c0a37909704b292a204195b0bc14f Maintainer: Fan2Shrek Status: ready -->
<!-- Reviewed: yes -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="quickhashintstringhash.loadfromfile">
 <refnamediv>
  <refname>QuickHashIntStringHash::loadFromFile</refname>
  <refpurpose>Cette méthode d'usine crée un hachage à partir d'un fichier</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <modifier>public</modifier> <modifier>static</modifier> <type>QuickHashIntStringHash</type><methodname>QuickHashIntStringHash::loadFromFile</methodname>
   <methodparam><type>string</type><parameter>filename</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>size</parameter><initializer>0</initializer></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>options</parameter><initializer>0</initializer></methodparam>
  </methodsynopsis>
  <simpara>
   Cette méthode d'usine crée un nouveau hachage à partir d'un fichier de définition sur le disque. Le
   format du fichier consiste en une signature <literal>'QH\0x12\0'</literal>, le nombre d'éléments en tant
   qu'entier signé 32 bits en Endianness du système, un entier non signé 32 bits
   contenant le nombre de données d'éléments à suivre en caractères. Ces données
   d'éléments contiennent toutes les chaînes. Après l'en-tête et les chaînes, les
   éléments suivent par paires de deux entiers non signés 32 bits où le premier
   est la clé, et le second l'index dans la chaîne de données d'éléments.
   Un exemple pourrait être :
  </simpara>
  <example>
   <title>Format de fichier QuickHash IntString</title>
   <screen><![CDATA[00000000  51 48 12 00 02 00 00 00  09 00 00 00 4f 4e 45 00  |QH..........ONE.|
00000010  4e 49 4e 45 00 01 00 00  00 00 00 00 00 03 00 00  |NINE............|
00000020  00 04 00 00 00                                    |.....|
00000025
]]></screen>
  </example>
  <example>
   <title>Format de fichier QuickHash IntString</title>
   <screen><![CDATA[
header signature ('QH'; key type: 1; value type: 2; filler: \0x00)
00000000  51 48 12 00

number of elements:
00000004  02 00 00 00

length of string values (9 characters):
00000008  09 00 00 00

string values:
0000000C  4f 4e 45 00 4e 49 4e 45  00

data string:
00000015  01 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00

key/value 1 (key = 1, string index = 0 ("ONE")):
01 00 00 00  00 00 00 00

key/value 2 (key = 3, string index = 4 ("NINE")):
03 00 00 00  04 00 00 00
]]></screen>
  </example>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <variablelist>
   <varlistentry>
    <term><parameter>filename</parameter></term>
    <listitem>
     <simpara>
      Le nom du fichier à partir duquel lire le hachage.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>size</parameter></term>
    <listitem>
     <simpara>
      La quantité de listes de seaux à configurer. Le nombre que l'on passe sera
      automatiquement arrondi à la puissance de deux suivante. Il est également
      automatiquement limité de <literal>4</literal> à <literal>4194304</literal>.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>options</parameter></term>
    <listitem>
     <simpara>
      Les mêmes options que le constructeur de la classe ; sauf que l'option
      size est ignorée. Elle est automatiquement calculée pour être la même que
      le nombre d'entrées dans le hachage, arrondie à la puissance de deux la plus proche
      avec une limite maximale de <literal>4194304</literal>.
     </simpara>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <simpara>
   Renvoie un nouveau <classname>QuickHashIntStringHash</classname>.
  </simpara>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Exemple de <function>QuickHashIntStringHash::loadFromFile</function></title>
   <programlisting role="php">
<![CDATA[
<?php
$file = dirname( __FILE__ ) . "/simple.string.hash";
$hash = QuickHashIntStringHash::loadFromFile(
    $file,
    QuickHashIntStringHash::DO_NOT_USE_ZEND_ALLOC
);
foreach( range( 0, 0x0f ) as $key )
{
    printf( "Key %3d (%2x) is %s\n",
        $key, $key,
        $hash->exists( $key ) ? 'set' : 'unset'
    );
}
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Key   0 ( 0) is unset
Key   1 ( 1) is set
Key   2 ( 2) is set
Key   3 ( 3) is set
Key   4 ( 4) is unset
Key   5 ( 5) is set
Key   6 ( 6) is unset
Key   7 ( 7) is set
Key   8 ( 8) is unset
Key   9 ( 9) is unset
Key  10 ( a) is unset
Key  11 ( b) is set
Key  12 ( c) is unset
Key  13 ( d) is set
Key  14 ( e) is unset
Key  15 ( f) is unset
]]>
   </screen>
  </example>
 </refsect1>


</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
