<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 9c40251a81d8f369c184e83fd142c4cc656a7261 Maintainer: Fan2Shrek Status: ready -->
<!-- Reviewed: yes -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="luasandbox.pauseusagetimer">
 <refnamediv>
  <refname>LuaSandbox::pauseUsageTimer</refname>
  <refpurpose>Pause le minuteur d'utilisation du CPU</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <modifier>public</modifier> <type>bool</type><methodname>LuaSandbox::pauseUsageTimer</methodname>
   <void/>
  </methodsynopsis>
  <simpara>
   Pause le minuteur d'utilisation du CPU.
  </simpara>
  <simpara>
   Ceci n'a d'effet que lorsqu'il est appelé depuis un rappel de Lua. Lorsque
   l'exécution revient à Lua, le minuteur sera automatiquement relancé.
   Si un nouvel appel est fait à Lua, le minuteur sera relancé
   pour la durée de cet appel.
  </simpara>
  <simpara>
   Si un rappel PHP appelle à nouveau Lua avec le minuteur non mis en pause, et
   que cette fonction Lua appelle à nouveau PHP, le second appel PHP ne pourra pas
   mettre en pause le minuteur. La logique est que même si le second appel PHP
   éviterait de compter l'utilisation du CPU contre la limite, le premier
   appel le compte toujours.
  </simpara>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  &no.function.parameters;
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <simpara>
   Renvoie un <type>bool</type> indiquant si le minuteur est maintenant en pause.
  </simpara>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Manipulation du minuteur d'utilisation</title>
   <programlisting role="php">
<![CDATA[
<?php

// créer un nouveau LuaSandbox et définir une limite CPU
$sandbox = new LuaSandbox();
$sandbox->setCPULimit( 1 );

function doWait( $t ) {
    $end = microtime( true ) + $t;
    while ( microtime( true ) < $end ) {
        // waste CPU cycles
    }
}

// Enregistrer une fonction de rappel PHP
$sandbox->registerLibrary( 'php', [
    'test' => function () use ( $sandbox ) {
        $sandbox->pauseUsageTimer();
        doWait( 5 );

        $sandbox->unpauseUsageTimer();
        doWait( 0.1 );
    },
    'test2' => function () use ( $sandbox ) {
        $sandbox->pauseUsageTimer();
        $sandbox->unpauseUsageTimer();
        doWait( 1.1 );
    }
] );

echo "This should not time out...\n";
$sandbox->loadString( 'php.test()' )->call();

echo "This should time out.\n";
try {
    $sandbox->loadString( 'php.test2()' )->call();
    echo "It did not?\n";
} catch ( LuaSandboxTimeoutError $ex ) {
    echo "It did! " . $ex->getMessage() . "\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
This should not time out...
This should time out.
It did! The maximum execution time for this script was exceeded
]]>
   </screen>
  </example>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <simplelist>
   <member><methodname>LuaSandbox::setCPULimit</methodname></member>
   <member><methodname>LuaSandbox::unpauseUsageTimer</methodname></member>
  </simplelist>
 </refsect1>

</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
