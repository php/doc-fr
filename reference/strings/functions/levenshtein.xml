<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.5 $ -->
<!-- splitted from ./en/functions/strings.xml, last change in rev 1.12 -->
  <refentry id="function.levenshtein">
   <refnamediv>
    <refname>levenshtein</refname> 
    <refpurpose>
     Calcule la distance Levenshtein entre deux cha&icirc;nes
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>levenshtein</methodname>
      <methodparam><type>string</type><parameter>str1</parameter></methodparam>
      <methodparam><type>string</type><parameter>str2</parameter></methodparam>
     </methodsynopsis>
     <methodsynopsis>
      <type>int</type><methodname>levenshtein</methodname>
      <methodparam><type>string</type><parameter>str1</parameter></methodparam>
      <methodparam><type>string</type><parameter>str2</parameter></methodparam>
      <methodparam><type>int</type><parameter>cost_ins</parameter></methodparam>
      <methodparam><type>int</type><parameter>cost_rep</parameter></methodparam>
      <methodparam><type>int</type><parameter>cost_del</parameter></methodparam>
     </methodsynopsis>
     <methodsynopsis>
      <type>int</type><methodname>levenshtein</methodname>
      <methodparam><type>string</type><parameter>str1</parameter></methodparam>
      <methodparam><type>string</type><parameter>str2</parameter></methodparam>
      <methodparam><type>function</type><parameter>cost</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>levenshtein</function> calcule la distance Levenshtein
     entre deux cha&icirc;nes de caract&egrave;res. Elle retournera -1 si l'un
     des deux arguments contient plus de 255 caract&egrave;res 
     (cela devrait &ecirc;tre plus que suffisant pour faire des comparaisons
     dans un dictionnaire ou annuaire, et personne de s&eacute;rieux ne fera
     de comparaison g&eacute;n&eacute;tique en PHP).
    </para>
    <para>
     La distance Levenshtein distance est d&eacute;finie comme le nombre
     minimal de caract&egrave;res qu'il faut remplacer, ins&eacute;rer ou modifier
     pour transformer la cha&icirc;ne <parameter>str1</parameter> en
     <parameter>str2</parameter>. La complexit&eacute; de l'algorithme
     est en <literal>O(m*n)</literal>,
     o&ugrave; <literal>n</literal> et <literal>m</literal> sont les tailles
     respectives de <parameter>str1</parameter> et
     <parameter>str2</parameter> : c'est plut&ocirc;t bien, en comparaison
     de <function>similar_text</function>, qui est en
     <literal>O(max(n,m)**3)</literal>, mais cela reste tr&egrave;s co&ucirc;teux.
    </para>
    <para>
     Dans sa forme la plus simple, <function>levenshtein</function>
     va prendre uniquement deux cha&icirc;nes de caract&egrave;res
     comme param&egrave;ters, et calculer simplement le nombre d'insertions,
     de remplacements et d'effacements n&eacute;cessaires pour tranformer
     <parameter>str1</parameter> en <parameter>str2</parameter>.
    </para>
    <para> 
     La deuxi&egrave;me variante de la fonction prend trois param&egrave;tres 
     suppl&eacute;mentaires qui repr&eacute;sentent les co&ucirc;ts d'insertions,
     de remplacements et d'effacements. C'est une version plus
     g&eacute;n&eacute;rale de la premi&egrave;re fonction, mais qui est un peu moins
     efficace.
    </para>
    <para> 
     La troisi&egrave;me variante (qui n'est pas impl&eacute;ment&eacute;e actuellement),
     est la version la plus g&eacute;n&eacute;rale, mais la plus lente. Elle appelera
     une fonction utilisateur qui d&eacute;terminera le co&ucirc;t de chaque op&eacute;ration.
    </para>
    <para>
     La fonction utilisateur qui sera appel&eacute;e re&ccedil;oit les arguments suivants :
     <itemizedlist>
      <listitem>
       <simpara>
        Op&eacute;ration &agrave; r&eacute;aliser : 'I', 'R' ou 'D'
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Caract&egrave;re dans <parameter>str1</parameter>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Caract&egrave;re dans <parameter>str2</parameter>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Position dans <parameter>str1</parameter>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Position dans <parameter>str2</parameter>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Caract&egrave;res restants dans <parameter>str1</parameter>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Caract&egrave;res restants dans <parameter>str2</parameter>
       </simpara>
      </listitem>
     </itemizedlist>
     Cette fonction doit retourner un entier positif, qui repr&eacute;sente
     le co&ucirc;t de cette op&eacute;ration particuli&egrave;re. Il peut ne prendre en
     compte que certains des param&egrave;tres fournis.
    </para>
    <para> 
     Gr&acirc;ce &agrave; cette fonction utilisateur, il est possible de prendr
     en compte la pertinence ou la valeur des caract&egrave;res eux-m&ecirc;mes,
     ou encore le contexte, pour d&eacute;finir le co&ucirc;ts d'une insertion,
     d'un effacement ou d'un remplacement. Cela se fait en perdant
     toutes les optimisations fa&icirc;tes en terme d'exploitation du CPU
     et des buffers.
    </para>
    <para>
     Voir aussi
     <function>soundex</function>,
     <function>similar_text</function> et
     <function>metaphone</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
