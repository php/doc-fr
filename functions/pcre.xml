<reference id="ref.pcre">
  <title>Expressions r&eacute;guli&egrave;res compatibles Perl</title>
  <titleabbrev>PCRE</titleabbrev>
  <partintro>
   <para>
     La syntaxe des masques utilis&eacute;s dans ces fonctions ressemble
     fort &agrave; celle de Perl. Les expressions seront entour&eacute;es
     de d&eacute;limiteurs, slash (/), par exemple. N'importe quel
     caract&egrave;re peut servir de d&eacute;limiteur, tant qu'il
     n'est pas alpha-num&eacute;rique ou n'est pas un antislash (\).
     Si un d&eacute;limiteur doit &ecirc;tre utilis&eacute; dans
     l'expression, il faudra l'&eacute;chapper avec un antislash.
     Depuis PHP 4.0.4, vous pouvez utiliser les d&eacute;limiteurs
     (), {}, [], et &lt;&gt;, comme en Perl.
   </para>
   <para>
     Le d&eacute;limiteur final peut &ecirc;tre suivi d'options qui
     affecteront la recherche. Voir aussi
     <link linkend="pcre.pattern.modifiers">options de recherche</link>.
   </para>
   <para>
    <example>
     <title>Exemples de masques valides</title>
     <itemizedlist>
      <listitem><simpara><literal>/&lt;\/\w+>/</literal></simpara></listitem>
      <listitem><simpara><literal>|(\d{3})-\d+|Sm</literal></simpara></listitem>
      <listitem><simpara><literal>/^(?i)php[34]/</literal></simpara></listitem>
      <listitem><simpara><literal>{^\s+(\s+)?$}</literal></simpara></listitem>
     </itemizedlist>
    </example>
   </para>
   <para>
    <example>
     <title>Exemples de masques invalides</title>
     <itemizedlist>
      <listitem>
       <simpara>
        /href='(.*)' - d&eacute;limiteur final manquant
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        /\w+\s*\w+/J - option 'J' inconnue
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        1-\d3-\d3-\d4| - d&eacute;limiteur initial manquant
       </simpara>
      </listitem>
     </itemizedlist>
    </example>
   </para>
   <note>
    <simpara>
      Les expressions r&eacute;guli&egrave;res Perl sont disponibles
      depuis la PHP 4 et PHP 3.0.9.
    </simpara>
	<simpara>
	 Le support des expressions r&eacute;guli&egrave;res est assur&eacute; 
	 par la librairie PCRE, qui est open source, et &eacute;crite par Philip
	 Hazel. Elle est soumise au copyright de l'University of Cambridge, 
	 Angleterre. Elle est disponible &agrave; <ulink url="&url.pcre;">&url.pcre;</ulink>.
	</simpara>
   </note>
  </partintro>
  <refentry id="function.preg-match">
   <refnamediv>
    <refname>preg_match</refname>
    <refpurpose>Expression r&eacute;guli&egrave;re standard.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>preg_match</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>subject</parameter></paramdef>
      <paramdef>array
       <parameter><optional>matches</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_match</function> analyse <parameter>subject</parameter>
     pour trouver l'expression <parameter>pattern</parameter>.
    </para>
    <para>
     Si <parameter>matches</parameter> est fourni, il sera rempli par
     les r&eacute;sultats de la recherche. $matches[0] contiendra le
     texte qui satisfait le masque complet, $matches[1] contiendra
     le texte qui satisfait la premi&egrave;re parenth&egrave;se capturante,
     etc..
    </para>
    <para>
      <function>preg_match</function> retourne <literal>TRUE</literal> si la
      recherche r&eacute;ussit, et <literal>FALSE</literal> sinon (notamment
      en cas d'erreur).
    </para>
    <para>
     <example>
      <title>Extraction d'un num&eacute;ro de page d'une cha&icirc;ne.</title>
      <programlisting role="php">
&lt;?php
if (preg_match("/page\s+#(\d+)/i", "Aller &agrave; la page num&eacute;ro 9.", $parts))
    print "La page suivante est $parts[1]";
else
    print "Page introuvable.";
?&gt;
      </programlisting>
     </example>
     <example>
      <title>Trouve le mot "web"</title>
      <programlisting role="php">
&lt;?php
// \b, dans le masque, indique une limite de mot, de fa&ccedil;on &agrave; ce que le mot
// "web" uniquement soit rep&eacute;r&eacute;, et pas seulement des parties de mots comme
// dans "webbing" ou "cobweb"
if (preg_match ("/\bweb\b/i", "PHP est le meilleur langage de script du web.")) {
    print "Un mot a &eacute;t&eacute; trouv&eacute;.";
} else {
    print "Un mot n'a pas &eacute;t&eacute; trouv&eacute;.";
}
if (preg_match ("/\bweb\b/i", "PHP est le meilleur langage de script pour les webagency.")) {
     print "Un mot a &eacute;t&eacute; trouv&eacute;.";
} else {
    print "Un mot n'a pas &eacute;t&eacute; trouv&eacute;.";
}
?&gt;
      </programlisting>
     </example>
     <example>
      <title>Lire un nom de domaine dans une URL</title>
      <programlisting role="php">
&lt;?php
// rep&eacute;rer le nom de l'h&ocirc;te dans l'URL
preg_match("/^(http:\/\/)?([^\/]+)/i",
"http://www.php.net/index.html", $matches);
$host = $matches[2];
// rep&eacute;rer les deux derniers segments du nom de l'h&ocirc;te
preg_match("/[^\.\/]+\.[^\.\/]+$/",$host,$matches);
echo "Le nom de domaine est : ".$matches[0]."\n";
?&gt;
      </programlisting>
     </example>
     Cet exemple va afficher :
     <computeroutput>
Le nom de domaine est : php.net
     </computeroutput>
     Voir aussi <function>preg_match_all</function>,
     <function>preg_replace</function> et
     <function>preg_split</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>Expression r&eacute;guli&egrave;re globale.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>preg_match_all</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>subject</parameter></paramdef>
      <paramdef>array <parameter>matches</parameter></paramdef>
      <paramdef>int
       <parameter><optional>order</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_match_all</function> analyse <parameter>subject</parameter>
     pour trouver l'expression <parameter>pattern</parameter>
     et met les r&eacute;sultats dans <parameter>matches</parameter>,
     dans l'ordre sp&eacute;cifi&eacute; par <parameter>order</parameter>.
    </para>
    <para>
     Apr&egrave;s avoir trouv&eacute; un premier r&eacute;sultat,
     la recherche continue jusqu'&agrave; la fin de la cha&icirc;ne.
    </para>
    <para>
     <parameter>order</parameter> peut prendre une des deux valeurs suivantes :
     <variablelist>
      <varlistentry>
       <term>PREG_PATTERN_ORDER</term>
       <listitem>
        <para>
          L'ordre est tel que $matches[0] est un tableau qui
          contient les r&eacute;sultats qui satisfont le masque
          complet, $matches[1] est un tableau qui contient les
          r&eacute;sultats qui satisfont la premi&egrave;re
          parenth&egrave;se capturante, etc..
	 <informalexample>
	  <programlisting role="php">
&lt;?php
preg_match_all("|&lt;[^&gt;]+&gt;(.*)&lt;/[^&gt;]+&gt;|U", "&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;a test&lt;/div&gt;", $out, PREG_PATTERN_ORDER);
print $out[0][0].", ".$out[0][1]."\n";
print $out[1][0].", ".$out[1][1]."\n";
?&gt;
	  </programlisting>
	 </informalexample>
	 Cet exemple va afficher :
	 <informalexample>
          <literallayout>
	   <computeroutput>
&lt;b&gt;exemple: &lt/b&gt;, &lt;div align=left&gt;ceci est un test&lt;/div&gt;
exemple: , ceci est un test
	   </computeroutput>
          </literallayout>
	 </informalexample>
      Ainsi, $out[0] est un tableau qui contient les r&eacute;sultats qui
      satisfont le masque complet, et $out[1] est un tableau qui contient
      les balises entre &gt; et &lt;.
 	 </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PREG_SET_ORDER</term>
     <listitem>
	  <para>
        Les r&eacute;sultats sont class&eacute;s de telle
        fa&ccedil;on que $matches[0] contient la premi&egrave;re
        s&eacute;rie de r&eacute;sultat, $matches[1] contient la
        deuxi&egrave;me s&eacute;rie de r&eacute;sultat, etc...
	    <informalexample>
   	     <programlisting role="php">
&lt;?php
preg_match_all("|&lt;[^&gt;]+&gt;(.*)&lt;/[^&gt;]+&gt;|U", "&lt;b&gt;exemple: &lt;/b&gt;&lt;div align=left&gt;un test&lt;/div&gt;", $out, PREG_SET_ORDER);
print $out[0][0].", ".$out[0][1]."\n";
print $out[1][0].", ".$out[1][1]."\n";
?&gt;
	     </programlisting>
	    </informalexample>
	    Cet exemple va afficher :
	    <informalexample>
             <literallayout>
	      <computeroutput>
&lt;b&gt;exemple: &lt;/b&gt;, exemple:
&lt;div align=left&gt;un test&lt;/div&gt;, un test
	      </computeroutput>
             </literallayout>
	    </informalexample>
 	    Dans ce cas, $matches[0] est la premi&egrave;re s&eacute;rie de
 	    r&eacute;sultat, et $matches[0][0] contient le texte qui satisfait
 	    le masque complet, $matches[0][1] contient le texte de la
 	    premi&egrave;re parenth&egrave;se capturante, etc... De m&ecirc;me,
 	    $matches[1] contient le texte qui satisfait le masque complet, etc...
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
      Si <parameter>order</parameter> est omis, PREG_PATTERN_ORDER est
      utilis&eacute; par d&eacute;faut.
    </para>
    <para>
       Retourne le nombre de r&eacute;sultat qui satisfont le masque
       complet, ou <literal>FALSE</literal> en cas d'&eacute;chec ou d'erreur.
    </para>
    <para>
     <example>
      <title>
        Extraction de tous les num&eacute;ros de t&eacute;l&eacute;phone d'un texte.
      </title>
      <programlisting role="php">
&lt;?php
preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
               "Appelez 555-1212 ou 1-800-555-1212", $phones);
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Recherche les couples de balises HTML (gourmand)</title>
      <programlisting role="php">
&lt;?php
// Cet exemple utilise les r&eacute;f&eacute;rences arri&egrave;res (\\2).
// Elles indiquent &agrave; l'analyseur qu'il doit trouver quelquechose qu'il
// a d&eacute;j&agrave; rep&eacute;r&eacute; un peu plus t&ocirc;t 
// le nombre 2 indique que c'est le deuxième jeu de parenthèses
// capturante qui doit être utilisé (ici, ([\w]+)).
//  L'antislash est nécessaire ici, car la chaîne est entre guillemets doubles
$html = "&lt;B&gt;Texte en gras&lt;/B&gt;&lt;a href=salut.html&gt;clique moi&lt;/?&gt;
preg_match_all ("/(&lt;([\w]+)[?&gt;]?&gt;)(.*)(&lt;\/\\?&gt;)/", $html, $matches);
for ($i=0; $i&lt; count($matches[0]); $i++) {
  echo "trouv&eacute;: ".$matches[0][$i]."\n";
  echo "partie 1: ".$matches[1][$i]."\n";
  echo "partie 2: ".$matches[3][$i]."\n";
  echo "partie 3: ".$matches[4][$i]."\n\n";
}
?&gt;
      </programlisting>
     </example>
     Cet exemple va produire :
     <computeroutput>
trouv&eacute;: &lt;B&gt;bold text&lt;/?&gt;
partie 1: &lt;B&gt;
partie 2: Test en gras
partie 3: &lt;/B&gt;
trouv&eacute;: &lt;a href=salut.html&gt;clique moi&lt;/?&gt;
partie 1: &lt;a href=salut.html&gt;
partie 2: clique moi
partie 3: &lt;/?&gt;
     </computeroutput>
    </para>
    <simpara>
     Voir aussi <function>preg_match</function>,
     <function>preg_replace</function>
     et <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.preg-replace">
   <refnamediv>
    <refname>preg_replace</refname>
    <refpurpose>
      Rechercher et remplacer par expression r&eacute;guli&egrave;re standard.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>preg_replace</function></funcdef>
      <paramdef>mixed <parameter>pattern</parameter></paramdef>
      <paramdef>mixed <parameter>replacement</parameter></paramdef>
      <paramdef>mixed <parameter>subject</parameter></paramdef>
      <paramdef>int
       <parameter><optional>limit</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
      <function>preg_replace</function> analyse <parameter>subject</parameter>
      pour trouver l'expression <parameter>pattern</parameter> et remplace les
      r&eacute;sultats par <parameter>replacement</parameter>.
    </para>
    <para>
     <parameter>replacement</parameter> peut contenir des r&eacute;f&eacute;rences
     de la forme <literal>\\<replaceable>n</replaceable></literal> ou,
     depuis PHP 4.0.4) <literal><replaceable>$n</replaceable></literal>.
     Cette derni&egrave;re forme est recommand&eacute;e. Ces
     r&eacute;f&eacute;rences seront remplac&eacute;es par le texte captur&eacute;
     par la <replaceable>n</replaceable>'-i&egrave;me parenth&egrave;se capturante
     du masque. <replaceable>n</replaceable> peut prendre des valeurs de 0 &agrave;
     99, et <literal>\\0</literal> ou <literal>$0</literal>, correspondent
     au texte de qui satisfait le masque complet. Les parenth&egrave;ses
     ouvrantes sont compt&eacute;es de gauche &agrave; droite (en commencant
     &agrave; 1) pour d&eacute;terminer le num&eacute;ro de parenth&egrave;se
     capturante.
    </para>
    <para>
      Si la recherche n'aboutit &agrave; aucun r&eacute;sultat,
      <parameter>subject</parameter> sera inchang&eacute;.
    </para>
    <para>
      Tous les param&egrave;tres de <function>preg_replace</function>
      peuvent &ecirc;tre des tableaux.
    </para>
    <para>
      Si <parameter>subject</parameter> est un tableau, alors l'op&eacute;ration
      sera appliqu&eacute;e &agrave; chacun des &eacute;l&eacute;ments du
      tableau, et le tableau sera retourn&eacute;.
    </para>
    <para>
      Si <parameter>pattern</parameter> et <parameter>replacement</parameter>
      sont des tableaux, alors <function>preg_replace</function> prend une valeur
      de chaque tableau, et l'utilise pour faire la recherche et le remplacement.
      Si <parameter>replacement</parameter> &agrave; moins d'&eacute;l&eacute;ments
      que <parameter>pattern</parameter>, alors la cha&icirc;ne vide est
      utilis&eacute; pour le reste des valeurs. Si <parameter>pattern</parameter>
      est un tableau, et que <parameter>replacement</parameter> est une
      cha&icirc;ne, alors cette cha&icirc;ne sera utilis&eacute;e pour
      chaque valeur de <parameter>pattern</parameter>.
      Le contraire n'aurait pas de sens.
   </para>
    <para>
      <literal>/e</literal> force <function>preg_replace</function>
      &agrave; traiter <parameter>replacement</parameter> comme du
      code PHP une fois que les substitutions ad&eacute;quates ont
      &eacute;t&eacute; faites. Conseil :assurez vous que
      <parameter>replacement</parameter> est un code PHP valide, car sinon, PHP
      trouvera une erreur d'analyse (parse error) dans cette ligne.
    </para>
    <para>
     <literal>/F</literal> indique que le param&egrave;tre
     <parameter>replacement</parameter> doit &ecirc;tre consid&eacute;r&eacute;
     comme un nom de fonction. Cette fonction sera appel&eacute;e, avec un
     tableau contenant les &eacute;l&eacute;ments trouv&eacute;s comme
     arguments. La fonctoin doit retourner la chaine de remplacement. Cette option
     a &eacute;t&eacute; ajout&eacute;e en PHP 4.0.4.
    </para>
    <para>
     <example>
      <title>Remplacement de plusieurs valeurs</title>
      <programlisting role="php">
&lt;?php
$patterns = array ("/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/",
                   "/^\s*{(\w+)}\s*=/");
$replace = array ("\\3/\\4/\\1\\2", "$\\1 =");
print preg_replace ($patterns, $replace, "{startDate} = 1999-5-27");
?&gt;
      </programlisting>
     </example>
    Cet exemple va afficher :
     <computeroutput>
      $startDate = 5/27/1999
     </computeroutput>
     <example>
      <title>Utilisation de l'option /e </title>
      <programlisting role="php">
&lt;?php
preg_replace("/(<\/?)(\w+)([^>]*&gt;/e", "'\\1'.strtoupper('\\2').'\\3'", $html_body);
?&gt;
      </programlisting>
      <para>
       Cela va mettre en majuscule toutes les balises HTML du texte.
      </para>
     </example>
     <example>
      <title>Conversion HTML en texte</title>
      <programlisting role="php">
&lt;?php
// $document contient un document HTML
// Ce script va effacer les balises HTML, les javascript
// et les espaces. Il remplace aussi queqlues entit&eacute;es HTML
// courante en leur &eacute;quivalent texte.
$search = array ("'&lt;script[?&gt;]*?&gt;.*?&lt;/script&gt;'si",  // Supprime le javascript
                 "'&lt;[\/\!]*?[^&lt?&gt;]*?&gt;'si",  // Supprime les balises HTML
                 "'([\r\n])[\s]+'",  // Supprime les espaces
                 "'&amp;(quot|#34);'i",  // Supprime les entitees HTML
                 "'&amp;(amp|#38);'i",
                 "'&amp;(lt|#60);'i",
                 "'&amp;(gt|#62);'i",
                 "'&amp;(nbsp|#160);'i",
                 "'&amp;(iexcl|#161);'i",
                 "'&amp;(cent|#162);'i",
                 "'&amp;(pound|#163);'i",
                 "'&amp;(copy|#169);'i",
                 "'&amp;#(\d+);'e");  // Evaluation comme PHP
$replace = array ("",
                  "",
                  "\\1",
                  "\"",
                  "&amp;",
                  "&lt;",
                  ?&gt;",
                  " ",
                  chr(161),
                  chr(162),
                  chr(163),
                  chr(169),
                  "chr(\\1)");
$text = preg_replace ($search, $replace, $document);
?&gt;
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Le param&egrave;tre <parameter>limit</parameter> a &eacute;t&eacute; ajout&eacute;
      &agrave; partir de PHP 4.0.1pl2.
     </para>
    </note>
    <para>
     Voir aussi <function>preg_match</function>,
     <function>preg_match_all</function>
     et <function>preg_split</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.preg-split">
   <refnamediv>
    <refname>preg_split</refname>
    <refpurpose>
      Eclatement d'une cha&icirc;ne par expression r&eacute;guli&egrave;re.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>preg_split</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>subject</parameter></paramdef>
      <paramdef>int
       <parameter><optional>limit</optional></parameter>
      </paramdef>
      <paramdef>int
       <parameter><optional>flags</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_split</function> retourne un tableau contenant les
     sous-cha&icirc;nes de <parameter>subject</parameter>,
     s&eacute;par&eacute;es par les cha&icirc;nes qui v&eacute;rifient
     <parameter>pattern</parameter>.
    </para>
    <para>
	 Si <parameter>limit</parameter> est sp&eacute;cifi&eacute;, alors seules les
	 <parameter>limit</parameter> premi&egrave;res sous-cha&icirc;nes sont retourn&eacute;es
	 et si <parameter>limit</parameter> vaut -1, cela signifie en fait
	 "sans limite", ce qui est utile pour passer le param&egrave;tre
	 <parameter>flags</parameter>.
    </para>
    <para>
	 <parameter>flags</parameter> peut &ecirc;tre la combinaison des
	 options suivantes (combin&eacute;es avec l'op&eacute;rateur <literal>|</literal>):
      <variablelist>
       <varlistentry>
	    <term>PREG_SPLIT_NO_EMPTY</term>
	    <listitem>
	     <simpara>
		 Si cette option est activ&eacute;e, seules les sous-cha&icirc;nes non vides
		 seront retourn&eacute;es par <function>preg_split</function>.
	     </simpara>
	    </listitem>
       </varlistentry>
       <varlistentry>
	    <term>PREG_SPLIT_DELIM_CAPTURE</term>
	    <listitem>
	     <simpara>
		 Si cette option est activ&eacute;e, les expressions entre parenth&egrave;ses entre
		 les d&eacute;limiteurs de masques seront aussi captur&eacute;es et retourn&eacute;es.
		 Cette option a &eacute;t&eacute; ajout&eacute;e en PHP 4.0.5.
	     </simpara>
	    </listitem>
       </varlistentry>
	  </variablelist>
	 </para>
    <note>
     <para>
      Le param&egrave;tre <parameter>flags</parameter> a &eacute;t&eacute;
      ajout&eacute; dans PHP Beta 3.
      </para>
    </note>
    <para>
     <example>
      <title>Eclatement d'une cha&icirc;ne de recherche.</title>
      <programlisting role="php">
&lt;?php
// scinde la phrase gr&acirc;ce aux virgules et espacements
// ce qui inclus les " ", \r, \t, \n et \f
$keywords = preg_split ("/[\s,]+/", "langage hypertexte, programmation");
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     Scinder une cha&icirc;ne en caract&egrave;res
    </para>
    <programlisting role="php">
&lt;?php
$str = 'string';
$chars = preg_split('//', $str, -1, PREG_SPLIT_NO_EMPTY);
print_r($chars);
?&gt;
    </programlisting>
    <para>
     Voir aussi <function>preg_match</function>, <function>preg_match_all</function>
     et <function>preg_replace</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.preg-quote">
   <refnamediv>
    <refname>preg_quote</refname>
    <refpurpose>
      Echappement des caract&egrave;res sp&eacute;ciaux des expressions
      r&eacute;guli&egrave;res.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>preg_quote</function></funcdef>
      <paramdef>string <parameter>str</parameter></paramdef>
     <paramdef>string
       <parameter><optional>delimiter</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_quote</function> ajoute un antislash devant tous
     les caract&egrave;res de la cha&icirc;ne <parameter>str</parameter>.
     Cela est tr&egrave;s utile si vous avez une cha&icirc;ne qui va
     servir de masque, mais qui est g&eacute;n&eacute;r&eacute;e durant
     l'ex&eacute;cution.
    </para>
    <para>
     Si l'argument optionnel <parameter>delimiter</parameter> est fourni,
     il sera aussi &eacute;chapp&eacute;. Ceci est pratique pour &eacute;chapper
     le d&eacute;limiteur requis par les fonctions PCRE. Le slash / est le
     d&eacute;limiteur le plus r&eacute;pandu.
    </para>
    <para>
     Les caract&egrave;res sp&eacute;ciaux qui seront &eacute;chapp&eacute;s :
     <screen>. \\ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | :</screen>
    </para>
    <para>
     <example>
      <title>Prot&egrave;ge des caract&egrave;res sp&eacute;ciaux</title>
      <programlisting role="php">
&lt;?php
$keywords = "$40 pour un g3/400";
$keywords = preg_quote ($keywords, "/");
echo $keywords; // retourne \$40 pour un g3\/400
?&gt;
      </programlisting>
     </example>
     <example>
      <title>Mise en italique d'un mot dans un texte</title>
      <programlisting role="php">
&lt;?php
// Dans cet exemple, preg_quote($word) sert &agrave; &eacute;viter que les ast&eacute;risques
// prennent une valeur particuli&egrave;re dans l'exepression r&eacute;guli&egrave;re.
$textbody = "Ce livre est *tr&egrave;s* difficile &agrave; trouver.";
$word = "*tr&egrave;s*";
$textbody = preg_replace ("/".preg_quote($word)."/",
                          "&lt;B&gt;".$word."&lt;/B&gt;",
                          $textbody);
?&gt;
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.preg-grep">
   <refnamediv>
    <refname>preg_grep</refname>
    <refpurpose>Retourne un tableau avec les r&eacute;sultat de la recherche.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>preg_grep</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>array <parameter>input</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_grep</function> retourne un tableau qui
     contient les &eacute;l&eacute;ments de <parameter>input</parameter>
     qui satisfont le masque <parameter>pattern</parameter>.
    </para>
    <para>
     Depuis PHP 4.0.4, le tableau retourn&eacute; par <function>preg_grep</function>
     est index&eacute; en utilisant les cl&eacute;s issues du tableau
     <parameter>input</parameter>. Si ces cl&eacute;s sont inutiles, utilisez
     la fonction <function>array_values</function> sur le tableau retourn&eacute;
     par <function>preg_grep</function> pour obtenir le comportement traditionnel.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>preg_grep</function></title>
      <programlisting role="php">
&lt;?php
// recherche les nombres &agrave; virgule flottante
preg_grep("/^(\d+)?\.\d+$/", $array);
?&gt;
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>
  <refentry id="pcre.pattern.modifiers">
   <refnamediv>
    <refname>Options de recherche</refname>
    <refpurpose>
      Options disponibles pour les expressions r&eacute;guli&egrave;res.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <para>
     Les options de PCRE sont list&eacute;es ci dessous. Les noms entre
     parenth&egrave;ses sont les noms internes &agrave; PCRE.
    </para>
    <para>
     <blockquote>
      <variablelist>
       <varlistentry>
	    <term><emphasis>i</emphasis> (PCRE_CASELESS)</term>
   	    <listitem>
	     <simpara>
 	      Effectue une recherche insensible &agrave; la casse.
         </simpara>
	    </listitem>
       </varlistentry>
       <varlistentry>
	    <term><emphasis>m</emphasis> (PCRE_MULTILINE)</term>
	<listitem>
	 <simpara>
	   Par d&eacute;faut, PCRE traite la cha&icirc;ne sujet comme une seule
	   ligne (m&ecirc;me si cette cha&icirc;ne contient des retours chariot).
	   Le m&eacute;ta-caract&egrave;re "d&eacute;but de ligne" (^) ne sera
	   valable qu'une seule fois, au d&eacute;but de la ligne, et le
	   m&eacute;ta caract&egrave;re "fin de ligne " ($) ne sera valable
	   qu'&agrave; la fin de la cha&icirc;ne, ou avant le retour chariot
	   final (&agrave; moins que l'option E ne soit activ&eacute;e). C'est le
	   m&ecirc;me fonctionnement qu'en Perl.
     </simpara>
	 <simpara>
	   Lorsque cette option est activ&eacute;e, " d&eacute;but de ligne " et
	   " fin de ligne " correspondront alors aux caract&egrave;res
	   suivant et pr&eacute;c&eacute;dent imm&eacute;diatement un
	   caract&egrave;re de nouvelle ligne, en plus du d&eacute;but
	   et de la fin de la cha&icirc;ne. C'est le m&ecirc;me
	   fonctionnement que l'option Perl /m. Si il n'y a pas de
	   caract&egrave;re de nouvelle ligne "\n" dans la cha&icirc;ne sujet,
	   ou si il n'y a aucune occurrence de ^ ou $ dans le masque, cette option
	   ne sert &agrave; rien.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>s</emphasis> (PCRE_DOTALL)</term>
	<listitem>
	 <simpara>
	   Avec cette option, le m&eacute;ta caract&egrave;re point (.)
	   remplace n'importe quel caract&egrave;re, y compris les nouvelles
	   lignes. Sans cette option, le caract&egrave;re point ne remplace
	   pas les nouvelles lignes. Cette option est &eacute;quivalente
	   &agrave; l'option Perl /s. Une classe de caract&egrave;res
	   n&eacute;gative telle que [^a] acceptera toujours les
	   caract&egrave;res de nouvelles lignes, ind&eacute;pendamment
	   de cette option.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>x</emphasis> (PCRE_EXTENDED)</term>
	<listitem>
	 <simpara>
	   Avec cette option, les caract&egrave;res d'espacement sont
	   ignor&eacute;s, sauf lorsqu'ils sont &eacute;chapp&eacute;s,
	   ou &agrave; l'int&eacute;rieur d'une classe de caract&egrave;res,
	   et tous les caract&egrave;res entre # non &eacute;chapp&eacute;s
	   et en dehors d'une classe de caract&egrave;res, et le prochain
	   caract&egrave;re de nouvelle ligne sont ignor&eacute;s. C'est
	   l'&eacute;quivalent Perl de l'option /x : elle permet l'ajout
	   de commentaires dans les masques compliqu&eacute;s. Notez bien,
	   cependant, que cela ne s'appliquent qu'aux caract&egrave;res de
	   donn&eacute;es. Les caract&egrave;res d'espacement ne doivent
	   jamais appara&icirc;tre dans les s&eacute;quences sp&eacute;ciales
	   d'un masque, comme par exemple dans la s&eacute;quence (?( qui
	   introduit une parenth&egrave;se conditionnelle.
	 </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>e</emphasis></term>
	<listitem>
	 <simpara>
	   Avec cette option, <function>preg_replace</function> effectue la
	   substitution normale des r&eacute;f&eacute;rences arri&egrave;res dans la
	   cha&icirc;ne de remplacement, puis l'&eacute;value comme un code PHP, et
	   utilise le r&eacute;sultat pour remplacer la cha&icirc;ne de recherche.
	   Cette optoin ne peut pas &ecirc;tre utilis&eacute;e avec <literal>/F</literal>.
     </simpara>
	 <simpara>
	   Seule <function>preg_replace</function> utilise cette option. Elle est
	   ignor&eacute;e par les autres.
	 </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>F</emphasis></term>
	<listitem>
	 <simpara>
	  Avec cette option, <function>preg_replace</function> consid&egrave;re
	  le param&egrave;tre de remplacement comme un nom de fonction, qui doit
	  &ecirc;tre appel&eacute; pour fournir la cha&icirc;ne de remplacement.
	  La fonction recoit un tableau d'&eacute;l&eacute;ments trouv&eacute;s.
	  Cette option ne peut pas &ecirc;tre utilis&eacute;e avec l'option
	  <literal>/e</literal>.
	 </simpara>
	 <simpara>
	  <function>preg_replace</function> seuelement utilise cette option.
	  Elle est ignor&eacute;e par les autres fonctions PCRE. Cette option a
	  &eacute;t&eacute; ajout&eacute;e en PHP 4.0.4.
 	 </simpara>
 	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>A</emphasis> (PCRE_ANCHORED)</term>
	<listitem>
	 <simpara>
	   Avec cette option, le masque est ancr&eacute; de force, c'est
	   &agrave; dire que le masque doit s'appliquer entre le d&eacute;but
	   et la fin de la cha&icirc;ne sujet pour &ecirc;tre
	   consid&eacute;r&eacute; comme trouv&eacute;. Il est
	   possible de r&eacute;aliser le m&ecirc;me effet en
	   ajoutant les m&eacute;ta-caract&egrave;res ad&eacute;quats,
	   ce qui est la seule mani&egrave;re de le faire en Perl.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>E</emphasis> (PCRE_DOLLAR_ENDONLY)</term>
	<listitem>
	 <simpara>
	   Avec cette option, le m&eacute;ta-caract&egrave;re $ ne sera
	   valable qu'&agrave; la fin de la cha&icirc;ne sujet. Sans
	   cette option, $ est aussi valable avant une nouvelle ligne,
	   si cette derni&egrave;re est le dernier caract&egrave;re de
	   la cha&icirc;ne. Cette option est ignor&eacute;e si l'option
	   <emphasis>m</emphasis> est activ&eacute;e. Il n'y a pas
	   d'&eacute;quivalent en Perl.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>S</emphasis></term>
	<listitem>
	 <simpara>
	   Lorsqu'un masque est utilis&eacute; plusieurs fois, cela vaut
	   la peine de passer quelques instants de plus pour l'analyser
	   et optimiser le code pour acc&eacute;l&eacute;rer les
	   traitements ult&eacute;rieurs. Cette option force cette
	   analyse plus pouss&eacute;e. Actuellement, cette analyse
	   n'est utile que pour les masques non ancr&eacute;s, qui
	   ne commencent pas par un caract&egrave;re fixe.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>U</emphasis> (PCRE_UNGREEDY)</term>
	<listitem>
	 <simpara>
	   Cette option inverse la tendance &agrave; la gourmandise des
	   expressions r&eacute;guli&egrave;res. Vous pouvez aussi inverser
	   cette tendance au coup par coup avec un ?. De m&ecirc;me, si
	   cette option est activ&eacute;e, le <literal>?</literal> rendra
	   gourmand une s&eacute;quence. Cette option n'est pas compatible
	   avec Perl. Elle peut aussi &ecirc;tre mise dans le masque avec
	   l'option <literal>?U</literal>.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>X</emphasis> (PCRE_EXTRA)</term>
	<listitem>
	 <simpara>
	  Cette option ajoute d'autres fonctionnalit&eacute;s incompatible
	  avec le PCRE de Perl. Tous les antislash suivis d'une lettre qui
	  n'aurait pas de signification particuli&egrave;re cause une erreur,
	  permettant la r&eacute;servation de ces combinaisons pour des ajouts
	  fonctionnels ult&eacute;rieurs. Par d&eacute;faut, comme en Perl, les
	   antislash suivis d'une lettre sans signification particuli&egrave;re
	   sont trait&eacute;s comme des valeurs lit&eacute;rales. Actuellement,
	   cette option ne d&eacute;clenche pas d'autres fonctions.
     </simpara>
	</listitem>
   </varlistentry>
  </variablelist>
 </blockquote>
 </para>
 </refsect1>
  </refentry>
  <refentry id="pcre.pattern.syntax">
   <refnamediv>
    <refname>Syntaxe des masques</refname>
    <refpurpose>
      Fonctionnement des expressions r&eacute;guli&egrave;res.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <para>
      La biblioth&egrave;que PCRE est un ensemble de fonctions qui
      impl&eacute;mentent la recherche par expressions
      r&eacute;guli&egrave;res, en utilisant la m&ecirc;me syntaxe
      et la m&ecirc;me s&eacute;mantique que le Perl 5, avec quelques
      nuances (voir ci-dessous). L'impl&eacute;mentation actuelle
      est celle de Perl 5.005.
    </para>
   </refsect1>
   <refsect1>
    <title>Diff&eacute;rences avec Perl</title>
    <para>
     Les diff&eacute;rences avec le Perl 5.005 sont pr&eacute;sent&eacute;e ici :
    <orderedlist>
 	 <listitem>
	  <simpara>
       Par d&eacute;faut, un caract&egrave;re d'espacement correspond &agrave;
       n'importe quel caract&egrave;re que la fonction C isspace() reconna&icirc;t,
       bien qu'il soit possible de recompiler la biblioth&egrave;que PCRE avec
       d'autres tables de caract&egrave;res. Normalement, isspace() retourne
       <literal>TRUE</literal> pour les espaces, les retours chariot, les
       nouvelles lignes, les formfeed, les tabulations verticales et horizontales.
       Le Perl 5 n'accepte plus la tabulation verticale comme caract&egrave;re
       d'espacement. La s&eacute;quence \v qui &eacute;tait dans la documentation
       Perl depuis longtemps n'a jamais &eacute;t&eacute; reconnue. Cependant, la
       tabulation verticale elle-m&ecirc;me &eacute;tait reconnue comme un
       caract&egrave;re d'espacement jusqu'&agrave; la version 5.002. Avec les
       version 5.004 et 5.005, l'option \s l'ignore.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       PRCE ne tol&egrave;re pas la r&eacute;p&eacute;tition de quantificateurs
       dans les expressions. Perl le permet, mais cela ne signifie pas ce que vous
       pourriez penser. Par exemple, (?!a){3} ne s'interpr&egrave;te pas : les trois
       caract&egrave;res suivants ne sont pas des "a". En fait, cela
       s'interpr&egrave;te comme : le caract&egrave;re suivant n'est pas "a" trois fois.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
	   Les occurrences de sous-masques qui interviennent dans des assertions
       n&eacute;gatives sont compt&eacute;es, mais elles ne sont pas
       enregistr&eacute;es dans le vecteur d'occurrences. Perl modifie ses
       variables num&eacute;riques pour toutes les occurrences de sous-masque,
       avant que l'assertion ne v&eacute;rifie le masque entier, et uniquement si
       les sous-masques ne trouvent qu'une seule occurrence.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Bien que les caract&egrave;res nul soient tol&eacute;r&eacute;s dans la
       cha&icirc;ne de recherche, ils ne sont pas accept&eacute;s dans le masque,
       car le masque est utilis&eacute; comme une cha&icirc;ne C standard,
       termin&eacute;e par le caract&egrave;re nul. Il faut donc utiliser la
       s&eacute;quence d'&eacute;chappement "\0" dans le masque pour rechercher
       les caract&egrave;res nul.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Les s&eacute;quence d'&eacute;chappement suivantes ne sont pas support&eacute;es
       par le Perl: \l, \u, \L, \U, \E, \Q. En fait, elles sont impl&eacute;ment&eacute;es
       par la gestion intrins&egrave;que de cha&icirc;nes du Perl, et ne font pas partie
       de ses caract&egrave;res sp&eacute;ciaux.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       L'assertion \G du Perl n'est pas support&eacute;e car elle n'est pas pertinente
       pour faire des recherches avec des masques uniques.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       De mani&egrave;re assez &eacute;vidente, PCRE n'accepte pas la construction
       (?{code}).
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Au moment de l'&eacute;criture de PCRE, Perl 5.005_02 avait quelques
       comportements &eacute;tranges avec la capture des cha&icirc;nes
       lorsqu'une partie du masque est redoubl&eacute;e. Par exemple, "aba" avec
       le masque /^(a(b)?)+$/ va affecter &agrave; $2 la valeur "b", mais la
       m&ecirc;me manipulation avec "aabbaa" et /^(aa(bb)?)+$/ laissera $2 vide.
       Cependant, si le masque est remplac&eacute; par /^(aa(b(b))?)+$/ alors $2 (et
       d'ailleurs $3) seront correctement affect&eacute;s. Avec le Perl 5.004,
       $2 sera correctement affect&eacute; dans les deux cas, et c'est aussi
       vrai avec PCRE. Si Perl &eacute;volue vers un autre comportement
       coh&eacute;rent, PCRE s'adaptera probablement.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Une autre diff&eacute;rence encore non r&eacute;solue est le fait qu'en
       Perl 5.005_02 le masque /^(a)?(?(1)a|b)+$/ accepte la cha&icirc;ne "a",
       tandis que PCRE ne l'accepte pas. Cependant, que ce soit avec Perl ou
       PCRE /^(a)?a/ et "a" laisseront $1 vide.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <para>
       PCRE propose quelques extensions aux expressions r&eacute;guli&egrave;res du Perl.
 	   <orderedlist>
 	    <listitem>
 	     <simpara>
          (a) Bien que les assertions avec retour (lookbehind) soit oblig&eacute;e
          d'apparier une cha&icirc;ne de longueur fixe, toutes les assertions avec
          retour peuvent avoir une longueur diff&eacute;rente. Perl 5.005 leur
          impose d'avoir toutes la m&ecirc;me longueur.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (b) Si <link linkend="pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link> est
          activ&eacute;, et que <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link>
          n'est pas activ&eacute;, le m&eacute;ta caract&egrave;re
          <literal>$</literal> ne s'applique qu'&agrave; la fin
          physqiue de la cha&icirc;ne, et non pas avant les caract&egrave;res
          de nouvelle ligne.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (c) Si <link linkend="pcre.pattern.modifiers">PCRE_EXTRA</link> est
          activ&eacute;, un antislash suivi d'une lettre sans signification
	      sp&eacute;ciale est consid&eacute;r&eacute;e comme une erreur.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (d) SI <link linkend="pcre.pattern.modifiers">PCRE_UNGREEDY</link> est
          activ&eacute;, la "gourmandise" des quantificateurs de
          r&eacute;p&eacute;tition est invers&eacute;es, ce qui est rend non
          gourmand par d&eacute;faut, mais si ils sont suivis de ?, il seront
          gourmands.
         </simpara>
        </listitem>
       </orderedlist>
	  </para>
 	 </listitem>
 	</orderedlist>
    </para>
   </refsect1>
   <refsect1 id="regexp.reference">
    <title>D&eacute;tails sur les expressions r&eacute;guli&egrave;res</title>
     <refsect2 id="regexp.introduction">
     <title>Introduction</title>
      <simpara>
       La syntaxe et la s&eacute;mantique des expressions r&eacute;guli&egrave;re
       support&eacute;es par PCRE sont d&eacute;crites ci-dessous.  Les expressions
       r&eacute;guli&egrave;res sont aussi d&eacute;crites dans la documentation
       Perl, et dans un grand nombre d'autres livres, avec de nombreux exemples.
       Jeffrey Friedl's "Mastering Regular Expressions", &eacute;dit&eacute;
       chez O'Reilly (ISBN 1-56592-257-3), les d&eacute;crits en profondeur.
       Cette description est organis&eacute;e comme une documentation de
       r&eacute;f&eacute;rence.
	  </simpara>
      <simpara>
       Une expression r&eacute;guli&egrave;re est un masque, appliqu&eacute; &agrave;
       une cha&icirc;ne sujet, de gauche &agrave; droite. La plus part des
       caract&egrave;res se repr&eacute;sentent eux-m&ecirc;mes. Un exemple
       trivial : un masque qui serait "<literal>Le rapide renard gris</literal>",
       pourra correspondre &agrave; une partie de la cha&icirc;ne sujet qui sera
       identique au masque, comme par exemple
       "<literal>Le rapide renard gris court dans la for&ecirc;t</literal>",
	  </simpara>
	 </refsect2>
	 <refsect2 id="regexp.reference.meta">
	  <title>M&eacute;ta-caract&egrave;res</title>
	  <para>
       La puissance des expressions r&eacute;guli&egrave;res provient de
       leur capacit&eacute; &agrave; autoriser des alternatives et des quantificateurs
       de r&eacute;p&eacute;tition dans le masque. Ils sont encod&eacute;s
       dans le masque par des m&eacute;ta-caract&egrave;res, qui ne repr&eacute;sentent
       pas ce qu'ils sont, mais sont interpr&eacute;t&eacute;s d'une certaine
       mani&egrave;re.
      </para>
      <para>
       Il y a deux sortes de m&eacute;ta-caract&egrave;res : ceux qui sont
       reconnus n'importe o&uacute; dans un masque, hormis entre crochets,
       et ceux qui sont reconnus entre crochets.
      </para>
      <para>
       A l'ext&eacute;rieur des crochets, les m&eacute;ta caract&egrave;res sont :
       <variablelist>
        <varlistentry>
	     <term><emphasis>/</emphasis> antislash</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re d'&eacute;chappement, avec de multiples usages
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>^</emphasis> Accent circonflexe</term>
   	     <listitem>
	      <simpara>
	       Le d&eacute;but de la cha&icirc;ne sujet (ou de ligne, en mode multiligne)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>$</emphasis> Dollar</term>
   	     <listitem>
	      <simpara>
	       La fin de la cha&icirc;ne sujet (ou de ligne, en mode multiligne)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>.</emphasis> Point</term>
   	     <listitem>
	      <simpara>
	       Remplace n'importe quel caract&egrave;re, hormis le caract&egrave;re
	       de nouvelle ligne (par d&eacute;faut) ;
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>[</emphasis> Crochet ouvrant</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but de d&eacute;finition de classe
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>]</emphasis> Crochet fermant</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de fin de d&eacute;finition de classe
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>|</emphasis> Barre verticale</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but d'alternative
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>(</emphasis> Parenth&egrave;se ouvrante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but de sous-masque
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>)</emphasis> Parenth&egrave;se fermante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de fin de sous-masque
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>?</emphasis> Point d'interrogation</term>
   	     <listitem>
	      <simpara>
	       Etend le sens de (; quantificateur de 0 ou 1; quantificateur de minimisation
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>*</emphasis> Etoile</term>
   	     <listitem>
	      <simpara>
	       Quantificateur de 0 ou plus
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>+</emphasis> Plus</term>
   	     <listitem>
	      <simpara>
	       Quantificateur de 1 ou plus
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>{</emphasis> Accolade ouvrante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but de quantificateur minimum/maximum
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>}</emphasis> Accolade fermante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de fin de quantificateur minimum/maximum
          </simpara>
	     </listitem>
        </varlistentry>
      </variablelist>
     </para>
     <para>
      La partie du masque qui est entour&eacute;e de crochet et appel&eacute;
      une classe de caract&egrave;res. Dans les classes de caract&egrave;res,
      les seuls m&eacute;ta caract&egrave;res autoris&eacute;s sont :
       <variablelist>
        <varlistentry>
	     <term><emphasis>\</emphasis> Antislash</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re d'&eacute;chappement, avec de multiples usages
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>^</emphasis> Accent circonflexe</term>
   	     <listitem>
	      <simpara>
	       N&eacute;gation de la classe, mais uniquement si plac&eacute; tout
	       au d&eacute;but de la classe
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>-</emphasis> Moins</term>
   	     <listitem>
	      <simpara>
	       Indique un intervalle de caract&egrave;res
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>]</emphasis> Crochet fermant</term>
   	     <listitem>
	      <simpara>
	       Termine la classe de caract&egrave;res
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
       La section suivante d&eacute;crit l'utilisation de chaque
       m&eacute;ta-caract&egrave;res.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.antislash">
	  <title>Antislash</title>
	  <para>
       Le caract&egrave;re antislash a de nombreuses utilisations.
      </para>
      <para>
       En premier lieu, s'il est suivi d'un caract&egrave;re non
       alpha-num&eacute;rique, il ne prendra pas la signification
       sp&eacute;ciale qui y est rattach&eacute;e. Cette utilisation de
       l'antislash comme caract&egrave;re d'&eacute;chappement s'applique
       &agrave; l'int&eacute;rieur et &agrave; l'ext&eacute;rieur des
       classes de caract&egrave;res. Par exemple, pour recherche le
       caract&egrave;re &eacute;toile "<literal>*</literal>", il faut
       &eacute;crire dans le masque : "<literal>\*</literal>". Cela
       s'applique dans tous les cas, que le caract&egrave;re qui suive
       soit un m&eacute;ta-caract&egrave;re ou non. C'est un moyen s&ucirc;r
       pour s'assurer qu'un caract&egrave;re sera recherch&eacute;
       pour sa valeur lit&eacute;rale, plut&ocirc;t que pour sa valeur
       sp&eacute;ciale. En particulier, pour rechercher les antislash,
       il faut &eacute;crire : "<literal>\\</literal>".
      </para>
      <para>
       Si un masque est utilis&eacute; avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>,
       les espaces blancs du masque, mais qui ne sont pas dans une
       classe de caract&egrave;res, et les caract&egrave;res entre di&egrave;ses
       "<literal>#</literal>", ainsi que les nouvelles lignes sont ignor&eacute;es.
       L'antislash peut &ecirc;tre utilis&eacute; pour &eacute;chapper et ainsi
       rechercher un espace ou un di&egrave;se.
      </para>
      <para>
       La deuxi&egrave;me utilit&eacute; de l'antislash est de pouvoir
       coder des caract&egrave;res invisibles dans les masques. Il n'y
       a pas de restriction sur la place de ces caract&egrave;res
       invisibles, hormis pour le caract&egrave;re nul qui doit terminer
       le masque.
      </para>
      <para>
       Lors de la pr&eacute;paration du masque, il est souvent plus pratique
       d'utiliser les s&eacute;quences d'&eacute;chappement suivantes,
       plut&ocirc;t que le caract&egrave;re binaire qu'elle repr&eacute;sente :
       <variablelist>
        <varlistentry>
	     <term><emphasis>\a</emphasis></term>
   	     <listitem>
	      <simpara>
	       alarme, c'est &agrave; dire le caract&egrave;re BEL (hex 07)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\cx</emphasis></term>
   	     <listitem>
	      <simpara>
	       "control-x", avec x qui peut &ecirc;tre n'importe quel caract&egrave;re.
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\e</emphasis></term>
   	     <listitem>
	      <simpara>
	       escape (hex 1B)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\f</emphasis></term>
   	     <listitem>
	      <simpara>
	       formfeed (hex 0C)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\n</emphasis></term>
   	     <listitem>
	      <simpara>
	       nouvelle ligne (hex 0A)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\r</emphasis></term>
   	     <listitem>
	      <simpara>
	       retour chariot (hex 0D)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\t</emphasis></term>
   	     <listitem>
	      <simpara>
	       tabulation (hex 09)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\xhh</emphasis></term>
   	     <listitem>
	      <simpara>
	       caract&egrave;re en hexad&eacute;cimal, de code hh
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\ddd</emphasis></term>
   	     <listitem>
	      <simpara>
	       caract&egrave;re en octal, de code ddd, ou r&eacute;f&eacute;rence arri&egrave;re
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Dans la s&eacute;quence "<literal>\cx</literal>" si "<literal>x</literal>"
       est en minuscule, il est converti en majuscule. Puis, le bit 6 (hex 40)
       est invers&eacute;. Ainsi "<literal>\cz</literal>" devient <literal>1A</literal>,
       mais "<literal>\c{</literal>" devient hex 3B, tandis que "<literal>\c;</literal>"
       devient hex 7B.
      </para>
      <para>
       Apr&egrave;s "<literal>\x</literal>", deux caract&egrave;res
       hexad&eacute;cimaeux sont lus (les lettres peuvent &ecirc;tre en majuscule
       ou minuscule).
      </para>
      <para>
       Apr&egrave;s "<literal>\0</literal>", deux caract&egrave;res octal sont lus.
       Dans chacun des cas, le m&eacute;ta-caract&egrave;re tente de lire autant
       de caract&egrave;re que possible. Ainsi la s&eacute;quence
       "<literal>\0\x\07</literal>", sera comprise comme deux caract&egrave;res nuls,
       suivi d'un caract&egrave;re alarme (BEL). Assurez vous que vous fournissez
       suffisamment de chiffres apr&egrave;s le m&eacute;ta-caract&egrave;re.
      </para>
      <para>
       La gestion de la s&eacute;quence "<literal>\y</literal>", avec y &lt;&gt; 0
       est plut&ocirc;t compliqu&eacute;e. En dehors des caract&egrave;res de classes,
       PCRE va lire y et tous les caract&egrave;res qui suivent comme des chiffres
       d&eacute;cimaux. Si y est plus petit que 10, ou bien si il y a
       d&eacute;j&agrave; eu au moins autant de parenth&egrave;ses ouvrantes
       auparavant, la s&eacute;quence est prise pour une r&eacute;f&eacute;rence
       arri&egrave;re. Le d&eacute;tail sera vu ult&eacute;rieurement, apr&egrave;s la
       section sur les sous-masques.
      </para>
      <para>
       A l'int&eacute;rieur d'un caract&egrave;re de classe, ou si y est plus
       grand que 10, et qu'il n'y a pas eu assez de parenth&egrave;ses ouvrantes
       auparavant, PCRE lis jusqu'&agrave; 3 chiffres octals &agrave; la suite
       de l'antislash, et g&eacute;n&eacute;re un octet unique, &agrave; partir
       des 8 bits de poids faible de la s&eacute;quence. Tous les chiffres qui
       suivent ne sont pas interpr&eacute;t&eacute;s, et se representent
       eux-m&ecirc;mes. Par exemple:
       <variablelist>
        <varlistentry>
	     <term><emphasis>\040</emphasis></term>
   	     <listitem>
	      <simpara>
	       une autre mani&egrave;re d'&eacute;crire un espace
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\40</emphasis></term>
   	     <listitem>
	      <simpara>
	       identique, dans la mesure o&uacute; il n'y a pas 40 parenth&egrave;ses
	       ouvrantes auparavant
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\7</emphasis></term>
   	     <listitem>
	      <simpara>
	       est toujours une r&eacute;f&eacute;rence arri&egrave;re
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\11</emphasis></term>
   	     <listitem>
	      <simpara>
	       peut &ecirc;tre une r&eacute;f&eacute;rence de retour,
	       ou une tabulation
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\011</emphasis></term>
   	     <listitem>
	      <simpara>
	       toujours une tabulation
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\0113</emphasis></term>
   	     <listitem>
	      <simpara>
	       est une tabulation suivi du caract&egrave;re "3"
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\113</emphasis></term>
   	     <listitem>
	      <simpara>
	       est le caract&egrave;re 113 (&eacute;tant donn&eacute; qu'il ne
	       peut y avoir plus de 99 r&eacute;f&eacute;rences arri&egrave;res)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\377</emphasis></term>
   	     <listitem>
	      <simpara>
	       est un octet dont tous les bits sont &agrave; 1
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\0113</emphasis></term>
   	     <listitem>
	      <simpara>
	       peut &ecirc;tre soit une r&eacute;f&eacute;rence arri&egrave;re,
	       soit le caract&egrave;re NULL, suivi des caract&egrave;res "8" et "1"
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Les valeurs octales sup&eacute;rieures ou &eacute;gales &agrave; 100 ne
       doivent pas &ecirc;tre introduites par un 0, car seuls les trois premiers
       octets seront lus.
      </para>
      <para>
       Toutes les s&eacute;quences qui d&eacute;finissent une valeur d'un seul
       octet peuvent &ecirc;tre utilis&eacute; dans les classes de caract&egrave;res,
       et &agrave; l'ext&eacute;rieur. De plus, dans une classe de caract&egrave;res,
       la s&eacute;quence "<literal>\b</literal>" est interpr&eacute;t&eacute;e
       comme un caract&egrave;re effacer (backspace, hex 08). A l'ext&eacute;rieur
       d'une classe de caract&egrave;res, il peut avoir d'autres significations
       (voir ci-dessous).
      </para>
      <para>
       On peut encore se servir de l'antislash pour pr&eacute;ciser des types
       g&eacute;n&eacute;riques de valeurs :
       <variablelist>
        <varlistentry>
	     <term><emphasis>\d</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re d&eacute;cimal
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\D</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re qui n'est pas un caract&egrave;re d&eacute;cimal
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\S</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re blanc
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\s</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re qui n'est pas un caract&egrave;re blanc
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\W</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re de "mot"
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\w</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re qui n'est pas un caract&egrave;re de "mot"
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Chaque paire pr&eacute;c&eacute;dente d&eacute;finit une partition de
       la table des caract&egrave;res : les deux ensembles sont disjoints.
       Un caract&egrave;re satisfera soit un m&eacute;ta-caract&egrave;re,
       soit l'autre.
      </para>
      <para>
       Un caract&egrave;re de "mot" sera une lettre, un chiffre ou le
       caract&egrave;re soulign&eacute;, c'est &agrave; dire un
       caract&egrave;re qui pourra &ecirc;tre une partie d'un mot Perl. La
       d&eacute;finition des lettres et chiffres est d&eacute;finie par les
       tables de caract&egrave;res de PCRE, et peut varier suivant la table
       locale de caract&egrave;re (voir "Tables de caract&egrave;res locales ",
       ci-dessus. Par exemple, dans la configuration fran&ccedil;ais ("fr"),
       certains caract&egrave;res ont des codes sup&eacute;rieurs &agrave;
       128, pour les caract&egrave;res accentu&eacute;s, et ils seront compris
       par le m&eacute;ta caract&egrave;re <literal>\w</literal>.
      </para>
      <para>
       Ces s&eacute;quences de caract&egrave;res peuvent appara&icirc;tre &agrave;
       l'int&eacute;rieur ou &agrave; l'ext&eacute;rieur des classes de
       caract&egrave;res. Elles remplacent &agrave; chaque fois un
       caract&egrave;re du type correspondant. Si cette s&eacute;quence est
       plac&eacute;e en fin de masque, et qu'il n'y a plus de caract&egrave;re &agrave;
       comparer dans la cha&icirc;ne sujet, la recherche &eacute;choue.
      </para>
      <para>
       La quatri&egrave;me utilisation de l'antislash intervient lors d'assertions
       simples. Une assertion impose une condition &agrave; un certain point,
       sans remplacer de caract&egrave;re. L'utilisation de sous-masques pour
       r&eacute;aliser des assertions plus complexes est d&eacute;crites
       plus-bas. Les assertions avec antislash sont les suivantes :
       <variablelist>
        <varlistentry>
	     <term><emphasis>\b</emphasis></term>
   	     <listitem>
	      <simpara>
	       limite de mot
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\B</emphasis></term>
   	     <listitem>
	      <simpara>
	       pas limite de mot
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\A</emphasis></term>
   	     <listitem>
	      <simpara>
	       d&eacute;but de la cha&icirc;ne sujet
	       (ind&eacute;pendant du mode multi-lignes)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\Z</emphasis></term>
   	     <listitem>
	      <simpara>
	       fin de la cha&icirc;ne sujet ou nouvelle ligne &agrave;
	       la fin de la cha&icirc;ne sujet
	       (ind&eacute;pendant du mode multi-lignes)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\z</emphasis></term>
   	     <listitem>
	      <simpara>
	       fin de la cha&icirc;ne sujet
	       (ind&eacute;pendant du mode multi-lignes)
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Ces assertions ne peuvent pas appara&icirc;tre dans une classe de
       caract&egrave;res (mais "\b" a une autre signification &agrave;
       l'int&eacute;rieur d'une classe de caract&egrave;res).
      </para>
      <para>
       Une limite de mot est un emplacement dans la cha&icirc;ne sujet ou un
       caract&egrave;re et son suivant ne sont pas en m&ecirc;me temps des
       caract&egrave;res de mot, ou le contraire (on peut le voir comme
       <literal>\w\W</literal> ou <literal>\W\w</literal>), ou encore le
       premier ou le dernier caract&egrave;re est un caract&egrave;re mot.
      </para>
      <para>
       Les assertions <literal>\A</literal>, <literal>\Z</literal>, et
       <literal>\z</literal> diff&egrave;rent des m&eacute;ta caract&egrave;res
       <literal>^</literal> et <literal>$</literal> dans la mesure o&uacute;
       ils ne sont pas d&eacute;pendants des options, notamment
       <link linkend="pcre.pattern.modifiers">PCRE_NOTBOL</link>
       ou <link linkend="pcre.pattern.modifiers">PCRE_NOTEOL</link>.
       La diff&eacute;rence entre <literal>\Z</literal> et
       <literal>\z</literal> tient au fait que <literal>\Z</literal> recherche
       les positions avant les nouvelles lignes et &agrave; la fin de la
       cha&icirc;ne sujet, tandis que <literal>\z</literal> ne recherche
       que la fin de la cha&icirc;ne.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.circudollar">
	  <title>Accent circonflexe et Dollar</title>
	  <para>
       En dehors d'une classe de caract&egrave;res, avec les options par
       d&eacute;faut, <literal>^</literal> est une assertion qui n'est
       vraie que si elle est plac&eacute;e tout au d&eacute;but de la
       cha&icirc;ne. A l'int&eacute;rieur d'une classe de caract&egrave;res,
       <literal>^</literal> a un tout autre sens (voir ci-dessous).
      </para>
      <para>
       <literal>^</literal> n'a pas besoin d'&ecirc;tre le premier
       caract&egrave;re du masque, si plusieurs alternatives sont
       propos&eacute;es, mais il doit &ecirc;tre plac&eacute; en
       premier dans chaque alternative. Si toutes les alternatives
       commencent par <literal>^</literal>, alors le masque est dit ancr&eacute;
       (il y a une autre construction qui porte cette appellation).
      </para>
      <para>
       <literal>$</literal> est une assertion qui n'est vraie que si elle
       est plac&eacute;e tout en fin de cha&icirc;ne ou juste avant un
       caract&egrave;re de nouvelle ligne qui serait le dernier
       caract&egrave;re de la cha&icirc;ne. A l'int&eacute;rieur d'une
       classe de caract&egrave;res, <literal>$</literal> a un tout autre
       sens (voir ci-dessous).
      </para>
      <para>
       <literal>$</literal> n'a pas besoin d'&ecirc;tre le dernier
       caract&egrave;re du masque, si plusieurs alternatives sont
       propos&eacute;es, mais il doit &ecirc;tre plac&eacute; en dernier
       dans chaque alternative. Si toutes les alternatives finissent par
       <literal>$</literal>, alors le masque est dit ancr&eacute; (il y
       a une autre construction qui porte cette appellation). <literal>$</literal>
       n'a pas de valeur particuli&egrave;re dans une classe de
       caract&egrave;res.
      </para>
      <para>
       La signification de <literal>$</literal> peut changer, de mani&egrave;re
       &agrave; l'amener &agrave; ce qu'il ne puisse se trouver qu'en toute
       fin de la cha&icirc;ne sujet. Cela se fait en ajoutant l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
       au moment de la compilation, ou de l'ex&eacute;cution.
       Cette option est inop&eacute;rante sur <literal>\Z</literal>.
      </para>
      <para>
       La signification de <literal>^</literal> peut changer, de mani&egrave;re
       &agrave; l'amener &agrave; ce qu'il puisse se trouver imm&eacute;diatement
       avant et imm&eacute;diatement apr&egrave;s un caract&egrave;re de nouvelle
       ligne "<literal>\n</literal>". Cela se fait en ajoutant l'option
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> au moment de
       la compilation ou de l'ex&eacute;cution.
       Par exemple, le masque <literal>/^abc$/</literal> accepte la cha&icirc;ne
       "<literal>def\nabc</literal>" uniquement en mode multi-lignes. Par
       cons&eacute;quent, toutes les parties du masques qui commencent par
       "<literal>^</literal>" ne sont pas ancr&eacute;es, en mode multi-lignes.
       L'option <link linkend="pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
       est ignor&eacute;e si l'option
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> est choisie.
      </para>
      <para>
       Notez que les m&eacute;ta caract&egrave;res <literal>\A</literal>,
       <literal>\Z</literal>, et <literal>\z</literal> peuvent servir &agrave;
       r&eacute;p&eacute;rer le d&eacute;but et la fin du sujet, et toutes les
       parties du masque qui commenceront par <literal>\A</literal> seront toujours
       ancr&eacute;es, avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> ou non.
  	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.dot">
	  <title>Point</title>
	  <simpara>
       En dehors d'une classe de caract&egrave;res, un point remplace n'importe
       quel caract&egrave;re, m&ecirc;me invisible et &agrave; l'exception du
       caract&egrave;re de nouvelle ligne. Avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> le point
       remplace n'importe quel caract&egrave;re, m&ecirc;me le caract&egrave;re de
       nouvelle ligne. La gestion des points et compl&egrave;tement
       ind&eacute;pendante de <literal>^</literal> et <literal>$</literal>.
       Le seul point commun est que les deux ont un comportement particulier vis
       &agrave; vis des caract&egrave;re de nouvelle ligne.
      </simpara>
      <simpara>
       Le point n'a pas de comportement particulier dans une classe de
       caract&egrave;res.
	  </simpara>
	 </refsect2>
	 <refsect2 id="regexp.reference.squarebrackets">
	  <title>Crochets</title>
	  <para>
       Un crochet ouvrant <literal>[</literal> introduit une classe de
       caract&egrave;res, et le crochet fermant <literal>]</literal>la
       conclut. Le crochet fermant n'a pas de signification en lui-m&ecirc;me.
       Si le crochet fermant est n&eacute;cessaire &agrave; l'int&eacute;rieur
       d'une classe de caract&egrave;res, il faut qu'il soit le premier
       caract&egrave;re (apr&egrave;s un <literal>^</literal> &eacute;ventuel)
       ou &eacute;chapp&eacute; avec un antislash.
      </para>
	  <para>
       Une classe de caract&egrave;res remplace un seul caract&egrave;re
       dans la cha&icirc;ne sujet, &agrave; moins que le premier
       caract&egrave;re de la classe soit un accent circonflexe
       <literal>^</literal>, qui repr&eacute;sente une n&eacute;gation :
       le caract&egrave;re ne doit pas se trouver dans la classe. Si
       <literal>^</literal> est n&eacute;cessaire dans la classe, il
       suffit qu'il ne soit pas le premier caract&egrave;re, ou bien
       qu'il soit &eacute;chapp&eacute; avec un antislash.
      </para>
      <para>
       Par exemple, le caract&egrave;re <literal>[aeiou]</literal> remplace
       n'importe quelle voyelle minuscule, tandis que <literal>[^aeiou]</literal>
       remplace n'importe quelle caract&egrave;re qui n'est pas une voyelle
       minuscule. <literal>^</literal> est une notation pratique pour
       sp&eacute;cifier des caract&egrave;res qui sont dans une classe,
       en ne citant que ceux qui n'y sont pas. Le comportement est inchang&eacute;.
      </para>
      <para>
       Avec l'option d'insensibilit&eacute; &agrave; la casse, toutes les lettres
       d'une classe de caract&egrave;res repr&eacute;sentent en m&ecirc;me temps
       la majuscule et la minuscule. Par exemple, <literal>[aeiou]</literal>
       repr&eacute;sentera "<literal>A</literal>" ou "<literal>a</literal>", et
       <literal>[^aeiou]</literal> n'acceptera pas ni "<literal>A</literal>",
       tandis que sans l'option, elle l'accepterait.
      </para>
      <para>
       Le caract&egrave;re de nouvelle ligne n'est pas trait&eacute; de
       mani&egrave;re sp&eacute;ciale dans les classes de caract&egrave;res,
       quelque soit l'option <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>
       ou <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link>. Une classe
       telle que <literal>[^a]</literal> acceptera toujours une nouvelle ligne.
      </para>
	  <para>
       Le signe moins (<literal>-</literal>) est utilis&eacute; pour
       sp&eacute;cifier un intervalle de caract&egrave;res, dans
       une classe. Par exemple, <literal>[d-m]</literal> remplace toutes
       les lettres entre d et m inclus. Si le caract&egrave;re moins est
       requis dans une classe, il faut l'&eacute;chapper avec un antislash,
       ou le faire appara&icirc;tre &agrave; une position ou il ne pourra
       pas &ecirc;tre interpr&eacute;t&eacute; comme une indication d'intervalle,
       c'est &agrave; dire au d&eacute;but ou &agrave; la fin de la classe.
      </para>
      <para>
       Il n'est pas possible d'avoir le caract&egrave;re crochet fermant
       "<literal>]</literal>" comme fin d'intervalle. Un masque tel que
       <literal>[W-]46]</literal> est compris comme la classe de caract&egrave;res
       contenant deux caract&egrave;res ("W" et "-") suivi de la cha&icirc;ne
       lit&eacute;rale "46]", ce qui fait qu'il va accepter
       "<literal>W46]</literal>" ou  "<literal>-46]</literal>". Cependant, si
       "<literal>]</literal>" est &eacute;chapp&eacute; avec un antislash, le
       masque <literal>[W-\]46]</literal> est interpr&eacute;t&eacute; comme
       une classe d'un seul caract&egrave;re, contenant un intervalle de
       caract&egrave;res.
      </para>
      <para>
       La valeur octale ou hexad&eacute;cimale de  "<literal>]</literal>" peut
       aussi &ecirc;tre utilis&eacute;e pour d&eacute;terminer les limites
       de l'intervalle. Les intervalles travaillent sur des
       s&eacute;quences ASCII. Ils peuvent aussi &ecirc;tre pr&eacute;cis&eacute;es
       avec des valeurs num&eacute;riques, par exemple "<literal>[\000-\037]</literal>".
       Si cet intervalle inclus des lettres utilis&eacute;es avec une
       option d'insensibilit&eacute; de casse, les majuscules ou minuscules
       correspondantes seront aussi incluses. Par exemple, "<literal>[C-c]</literal>"
       est &eacute;quivalent &eacute; "<literal>[][\^_`wxyzabc]</literal>",
       avec l'option d'insensibilit&eacute; de casse. Si la table locale de
       caract&egrave;res est "fr", "<literal>[\xc8-\xcb]</literal>" correspond
       aux caract&egrave;res accentu&eacute;s.
      </para>
      <para>
       Les types de caract&egrave;res <literal>\d</literal>,
       <literal>\D</literal>, <literal>\S</literal>, <literal>\s</literal>,
       <literal>\w</literal>, <literal>\W</literal> peuvent aussi intervenir
       dans les classes de caract&egrave;res. Par exemple,
       "<literal>[][\^_`wxyzabc][\dABCDEF]</literal>" acceptera n'importe
       quel caract&egrave;re hexad&eacute;cimal. Un accent circonflexe peut
       aussi &ecirc;tre utilis&eacute; pour sp&eacute;cifier adroitement
       des ensembles de caract&egrave;res plus restrictifs : par exemple
       <literal>[^\W_]</literal> accepte toutes les lettres et les chiffres,
       mais pas les soulign&eacute;s. Tous les caract&egrave;res non alpha-
       num&eacute;riques autres que <literal>\, -, ^</literal> (plac&eacute;s
       en d&eacute;but de cha&icirc;ne) et <literal>]</literal> n'ont pas de
       signification particuli&egrave;re, mais ils ne perdront rien &agrave;
       &ecirc;tre &eacute;chapp&eacute;s.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.verticalbar">
	  <title>Barre verticale</title>
	  <para>
       La barre verticale <literal>|</literal> sert &agrave; s&eacute;parer des
       alternatives. Par exemple, dans le masque "<literal>/dupont|martin/</literal>"
       recherche soit "<literal>dupont</literal>", soit "<literal>martin</literal>".
       Le nombre d'alternatives n'est pas limit&eacute;, et il est m&ecirc;me possible
       d'utiliser la cha&icirc;ne vide. Lors de la recherche, toutes les alternatives
       sont essay&eacute;es, de gauche &agrave; droite, et la premi&egrave;re qui est
       accept&eacute;e est utilis&eacute;e.
      </para>
      <para>
       Si les alternatives sont dans un sous-masque, elle ne r&eacute;ussiront que
       si le masque principal r&eacute;ussi aussi.
      </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.internal_options">
	  <title>Options internes</title>
	  <para>
       Les options <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link>,
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link>,
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> et
       <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link> peuvent
       &ecirc;tre chang&eacute;e &agrave; l'int&eacute;rieur du masque
       lui-m&ecirc;me, avec des s&eacute;quences mises entre
       "<literal>(?</literal>" et "<literal>)</literal>".
       Les options sont :
       <variablelist>
        <varlistentry>
	     <term><emphasis>i</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_CASELESS
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>m</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_MULTILINE
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>s</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_DOTALL
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>x</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_EXTENDED
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
       Par exemple, <literal>(?im)</literal> rend le masque insensible &agrave;
       la casse, et multi-lignes. Il est possible d'annuler ces options en les
       faisant pr&eacute;c&eacute;der par un signe <literal>-</literal> : par
       exemple <literal>(?im-sx)</literal>, ajoutera les options
       <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link>
       et <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> mais
       annulera les options <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>
       et <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>.
       Si une option appara&icirc;t avant et apr&egrave;s le signe moins, l'option
       sera annul&eacute;e.
      </para>
      <para>
       Le domaine d'application de ces options d&eacute;pend de la position de
       la s&eacute;quence d'option. Pour toutes les s&eacute;quences d'options
       qui sont hors des sous-masques (d&eacute;finis plus loin), l'effet est le
       m&ecirc;me que si l'option avait &eacute;t&eacute; fix&eacute;e d&egrave;s
       le d&eacute;but de la recherche. Les exemples suivants se comportent tous
       de la m&ecirc;me fa&ccedil;ons : <literal>(?i)abc</literal>,
       <literal>a(?i)bc</literal>, <literal>ab(?i)c</literal>,
       <literal>abc(?i)</literal>, et sont parfaitement &eacute;quivalents au
       masque <literal>abc</literal> avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link>. En d'autres
       termes, activer des s&eacute;quences d'options dans le corps principal
       du masque revient &agrave; appliquer l'option &agrave; tout le masque, sauf
       ordre contraire dans les sous-masques. Si il y a plusieurs s&eacute;quences
       d'options qui portent sur la m&ecirc;me option, la derni&egrave;re s'appliquera.
      </para>
      <para>
       Si une option intervient dans un sous-masque, le comportement est diff&eacute;rent.
       C'est un changement de comportement apparu en Perl 5.005. Une option &agrave;
       l'int&eacute;rieur d'un sous-masque n'affecte que cette partie du masque, ce
       qui fait que <literal>(a(?i)b)c</literal> acceptera <literal>abc</literal>
       et <literal>aBc</literal> mais aucune autre cha&icirc;ne (en supposant que
       <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link> n'est pas
       utilis&eacute;). Cela signifie que les options permettent d'avoir
       diff&eacute;rente configuration de recherche pour diff&eacute;rentes
       parties du masque.
      </para>
      <para>
       Une s&eacute;quence d'options dans une alternative affecte toute
       l'alternative. Par exemple : <literal>(a(?i)b|c)</literal> accepte
       "<literal>ab</literal>", "<literal>aB</literal>", "<literal>c</literal>",
       et "<literal>C</literal>", m&ecirc;me si, comme dans le cas de
       "<literal>C</literal>", la premi&egrave;re alternative qui porte
       l'option n'est pas prise en compte. Sinon, cela risque d'introduire
       des comportements tr&egrave;s &eacute;tranges : les options
       sp&eacute;cifiques &agrave; PCRE telles que
       <link linkend="pcre.pattern.modifiers">PCRE_UNGREEDY</link> et
       <link linkend="pcre.pattern.modifiers">PCRE_EXTRA</link> peuvent
       &ecirc;tre modifi&eacute;es de la m&ecirc;me
       mani&egrave;re, en utilisant respectivement les caract&egrave;res
       U et X. L'option <literal>(?X)</literal> est particuli&egrave;re,
       car elle doit toujours intervenir avant toutes les autres options,
       m&ecirc;me au niveau du masque entier. Il vaut mieux l'activer au
       d&eacute;but du masque.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.subpatterns">
	  <title>Sous-masques</title>
	  <para>
       Les sous-masques sont d&eacute;limit&eacute;s par des parenth&egrave;ses,
       et peuvent &ecirc;tre imbriqu&eacute;es. Ajouter des sous-masques a deux
       utilit&eacute;s :
      </para>
      <para>
       1. D&eacute;limiter des alternatives. Par exemple, le masque
       <literal>char(don|mant|)</literal> acceptera les mots
       "<literal>char</literal>", "<literal>charmant</literal>", ou
       "<literal>charmant</literal>". Sans les parenth&egrave;ses, il
       n'accepterait que "<literal>chardon</literal>",
       "<literal>mant</literal>" ou la cha&icirc;ne vide "".
      </para>
      <para>
       2. Le sous-masque est consid&eacute;r&eacute; comme capturant : lorsqu'une
       cha&icirc;ne sujet est accept&eacute;e par le masque complet, les
       sous-masques sont transmis &agrave; l'appelant gr&acirc;ce &agrave;
       un vecteur de sous-masques. Les parenth&egrave;ses ouvrantes sont
       compt&eacute;es de gauche &agrave; droite, (commencant &agrave; 1).
       Par exemple, soit la cha&icirc;ne sujet "<literal>le roi soleil</literal>"
       qui est utilis&eacute;e avec le masque suivant :
       <literal>Le ((roi|prince) (soleil|charmant))</literal> les sous-masques
       captur&eacute; sont "<literal>roi soleil</literal>", "<literal>roi</literal>",
       et "<literal>soleil</literal>", num&eacute;rot&eacute;s respectivement 1, 2, et 3.
      </para>
      <para>
       L'ubiquit&eacute; des parenth&egrave;ses n'est pas toujours simple
       d'emploi. Il y a des moments o&uacute; regrouper des sous-masques
       est n&eacute;cessaire, sans pour autant capturer la valeur trouv&eacute;e.
       Si une parenth&egrave;se ouvrante est suivie de "<literal>?:</literal>",
       le sous-masque ne capture pas la cha&icirc;ne assortie, et ne sera pas
       compt&eacute; lors de la num&eacute;rotation des captures. Par exemple,
       avec la cha&icirc;ne "<literal>le prince charmant</literal>", utilis&eacute;
       avec le masque <literal>Le (( ?roi|prince) (soleil|charmant))</literal>
       les cha&icirc;nes captur&eacute;es seront "<literal>prince charmant</literal>"
       et "<literal>charmant</literal>", num&eacute;rot&eacute;s respectivement 1
       et 2.
      </para>
      <para>
       Le nombre maximal de cha&icirc;ne captur&eacute;es est de 99, et le
       nombre total de sous-masque (capturant ou non) ne doit pas
       d&eacute;passer 200.
      </para>
      <para>
	   <literal>(?i:samedi|dimanche)</literal> et
	   <literal>(?:(?i) samedi | dimanche)</literal> : De plus, comme les
	   s&eacute;quences d'options sont valables sur toute une alternative,
       les masques ci-dessus accepteront aussi bien "DIMANCHE" que "Dimanche".
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.repetitions">
	  <title>R&eacute;p&eacute;titions</title>
	  <para>
       Les r&eacute;p&eacute;titions sont sp&eacute;cifi&eacute;es avec
       des quantificateurs, qui peuvent &ecirc;tre plac&eacute;s &agrave;
       la suite des caract&egrave;res suivants :
       <variablelist>
        <varlistentry>
	     <term><emphasis>a</emphasis></term>
   	     <listitem>
	      <simpara>
	       Un caract&egrave;re unique, m&ecirc;me s'il s'agit
	       d'un m&eacute;ta caract&egrave;re
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>[abc]</emphasis></term>
   	     <listitem>
	      <simpara>
	       Une classe de caract&egrave;res
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>\2</emphasis></term>
   	     <listitem>
	      <simpara>
	       Une r&eacute;f&eacute;rence de retour (Voir section suivante)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>(a|b|c)</emphasis></term>
   	     <listitem>
	      <simpara>
	       Un sous-masque avec parenth&egrave;ses (&agrave; moins que ce ne soit
	       une assertion, voir plus loin)
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Les quantificateurs g&eacute;n&eacute;raux pr&eacute;cisent un nombre
       minimum et maximum de r&eacute;p&eacute;titions possibles, donn&eacute;s
       par deux nombres entre accolades, et s&eacute;par&eacute;s par une virgule.
       Ces nombres doivent &ecirc;tre plus petits que 65536, et le premier nombre
       doit &ecirc;tre &eacute;gal ou inf&eacute;rieur au second. Par exemple
       <literal>z{2,4}</literal> accepte "<literal>zz</literal>",
       "<literal>zzz</literal>", ou "<literal>zzzz</literal>". L'accolade fermante
       n'a pas de signification par elle m&ecirc;me.
      </para>
      <para>
       Si le second nombre est omis, mais que la virgule est l&agrave;, cela
       signifie qu'il n'y a pas de limite sup&eacute;rieure. Si le second nombre
       et la virgule sont omis, le quantificateur correspond au nombre exact de
       r&eacute;p&eacute;tition attendues. Par exemple :
       accepte n'importe quelle succession d'au moins 3 voyelles minuscules, tandis
       que <literal>\d{d}</literal> n'accepte que 8 chiffres exactement.
      </para>
      <para>
       Une accolade ouvrante qui appara&icirc;t &agrave; une position o&uacute;
       un quantificateur n'est pas accept&eacute;, ou si la syntaxe des
       quantificateurs n'est pas respect&eacute;e, sera consid&eacute;r&eacute;e
       lit&eacute;rale. Par exemple, "<literal>{,6}</literal>" n'est pas un
       quantificateur, mais une cha&icirc;ne de 4 caract&egrave;res.
      </para>
      <para>
       Le quantificateur {0} est autoris&eacute;, mais l'expression est alors
       ignor&eacute;e.
       <variablelist>
        <varlistentry>
	     <term><emphasis>*</emphasis></term>
   	     <listitem>
	      <simpara>
	       &eacute;quivalent &agrave; {0,}
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>+</emphasis></term>
   	     <listitem>
	      <simpara>
	       &eacute;quivalent &agrave; {1,}
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>?</emphasis></term>
   	     <listitem>
	      <simpara>
	       &eacute;quivalent &agrave; {0,1}
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Il est possible de constituer des boucles infinies en cr&eacute;ant un sous-masque
       sans caract&egrave;res, mais pourvu d'un quantificateur sans limite
       sup&eacute;rieure. Par exemple "<literal>(a?)*</literal>.
      </para>
      <para>
       Les versions plus anciennes de Perl et PCRE g&eacute;n&eacute;raient alors
       une erreur au moment de la compilation. Cependant, &eacute;tant donn&eacute;
       qu'il existe des situations o&uacute; ces constructions peuvent &ecirc;tre
       utiles, ces masques sont d&eacute;sormais autoris&eacute;s. Cependant, si
       la r&eacute;p&eacute;tion du sous-masque ne trouve aucun caract&egrave;re,
       la boucle est interrompue.
      </para>
      <para>
       Par d&eacute;faut, les quantificateurs sont dits "gourmands", c'est &agrave;
       dire, qu'ils cherchent d'abord &agrave; trouve le nombre maximal de
       r&eacute;p&eacute;titions qui autorise le succ&egrave;s de la recherche.
       L'exemple classique pos&eacute; par cette gourmandise est la recherche de
       commentaires d'un programme en C. Les commentaires apparaissent entre les
       s&eacute;quences <literal>/*....*/</literal> et &agrave; l'int&eacute;rieur
       de ces d&eacute;limiteurs, les <literal>*</literal> et <literal>/</literal>
       sont autoris&eacute;s. Appliquer le masque <literal>/\*.*\*/</literal>
       &agrave; la cha&icirc;ne
       <literal>/* first commet */  not comment  /* second comment */</literal>
       ne peut r&eacute;ussir, car le masque travaille sur toute la cha&icirc;ne,
       &agrave; cause de la gourmandise du caract&egrave;re <literal>.*</literal>.
      </para>
      <para>
       Cependant, un quantificateur suivi d'un point d'interrogation cesse
       d'&ecirc;tre gourmand, et au contraire, ne recherche que le nombre
       minimum de r&eacute;p&eacute;tition. Dans ces conditions, le masque
       <literal>/\*.*?\*/</literal> trouvera bien les commentaires du code
       C. La signification des autres quantificateurs n'est pas chang&eacute;e.
      </para>
      <para>
       Attention &agrave; ne pas confondre l'utilisation du point d'interrogation
       ici avec son utilisation comme quantificateur lui m&ecirc;me.
       A cause cette ambiguit&eacute;, il peut appara&icirc;tre des situations
       o&uacute; il faut le doubler : <literal>\d??\d</literal>. Ce masque va
       tenter de lire un seul chiffre, mais le cas &eacute;ch&eacute;ant,
       il acceptera 2 chiffres pour permettre &agrave; la recherche
       d'aboutir. Si l'option <link linkend="pcre.pattern.modifiers">PCRE_UNGREEDY</link>
       est activ&eacute;e, (une option qui
       n'est pas disponible avec Perl) alors les quantificateurs sont
       non gourmand par d&eacute;faut, mais peuvent &ecirc;tre
       rendu gourmand au cas par cas, en ajoutant un point d'interrogation
       apr&egrave;s. En d'autres termes, cette option inverse le comportement par
       d&eacute;faut.
      </para>
      <para>
       Lorsqu'un sous-masque est quantifi&eacute; avec un nombre minimum
       de r&eacute;p&eacute;titions, qui soit plus grand que 1, ou avec
       un maximum de r&eacute;p&eacute;titions, le masque compil&eacute; aura
       besoin de plus de place de stockage, proportionnellement au minimum
       et au maximum.
      </para>
      <para>
       Si un masque commence par <literal>..*</literal> ou <literal>.{0,}</literal>
       et que l'option <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>
       (&eacute;quivalent en Perl &agrave; /s) est
       activ&eacute;e, c'est &agrave; dire en autorisant le remplacement des nouvelles
       lignes par un m&eacute;ta-caract&egrave;re, alors le masque est
       implicitement ancr&eacute;, car tout ce qui suit va &ecirc;tre
       mang&eacute; par la premi&egrave;re s&eacute;quence, et se comportera
       comme si le masque se terminait par le m&eacute;ta caract&egrave;re
       <literal>\A</literal>. Dans le cas o&uacute; on sait d'avance qu'il
       n'y aura pas de caract&egrave;re de nouvelle ligne, activer l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> et commencer
       le masque par <literal>.*</literal> permet d'optmiser le masque.
      </para>
      <para>
       Alternativement, on peut utiliser <literal>^</literal> pour ancrer
       explicitement le masque. Lorsqu'un sous-masque capturant est
       r&eacute;p&eacute;t&eacute;, la valeur captur&eacute;e est la
       derni&egrave;re. Par exemple, apr&egrave;s que
       "<literal>(inter[net]{3}\s*)+</literal>" ai &eacute;t&eacute;
       appliqu&eacute; &agrave; "<literal>internet interne</literal>",
       la valeur de la cha&icirc;ne captur&eacute;e est "<literal>interne</literal>".
      </para>
      <para>
       Cependant, s'il y a des sous-masques imbriqu&eacute;s, la valeur
       captur&eacute;e correspondante peut l'avoir &eacute;t&eacute; lors
       des pr&eacute;c&eacute;dentes it&eacute;rations. Par exemple :
       <literal>/(a|(b))+/</literal> accepte "<literal>aba</literal>" et
       la deuxi&egrave;me valeur captur&eacute;e est "<literal>b</literal>".
      </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.back_references">
	  <title>R&eacute;f&eacute;rences arri&egrave;res </title>
	  <para>
       En dehors des classes de caract&egrave;res, un antislash suivi
       d'un nombre plus grand que 0 (et possiblement plusieurs chiffres)
       est une r&eacute;f&eacute;rence arri&egrave;re (c'est &agrave;
       dire vers la gauche) dans le masque, en supposant qu'il y ait
       suffisamment de sous-masques capturants pr&eacute;c&eacute;dants.
      </para>
      <para>
       Cependant, si le nombre d&eacute;cimal suivant l'antislash est
       plus petit que 10, il sera toujours consid&eacute;r&eacute;
       comme une r&eacute;f&eacute;rence arri&egrave;re, et cela
       g&eacute;n&eacute;rera une erreur si le nombre de capture
       n'est pas suffisant. En d'autres termes, il faut qu'il existe
       suffisamment de parenth&egrave;ses ouvrantes &agrave; gauche
       de la r&eacute;f&eacute;rence, surtout si la r&eacute;f&eacute;rence
       est inf&eacute;rieure &agrave; 10.
      </para>
      <para>
       Reportez vous &agrave; la section "antislash" pour avoir de
       plus amples d&eacute;tails &agrave; propos du nombre de
       chiffres qui suivent l'antislash.
      </para>
      <para>
       La r&eacute;f&eacute;rence arri&egrave;re remplace ce qui a
       &eacute;t&eacute; captur&eacute; par un sous-masque dans le
       masque courant, plut&ocirc;t que remplace le sous-masque
       lui-m&ecirc;me. Ainsi <literal>(calme|rapide)</literal> et
       <literal>\1ment</literal> trouvera "<literal>calme et calmement</literal>"
       et "<literal>rapide et rapidement</literal>", mais pas
       "<literal>calme et rapidement</literal>". Si la recherche tient
       compte de la casse, alors la casse de la cha&icirc;ne
       captur&eacute;e sera importante. Par exemple,
       <literal>((?i)rah)\s+\1</literal> trouve "<literal>rah rah</literal>"
       et "<literal>RAH RAH</literal>", mais pas "<literal>RAH rah</literal>",
       m&ecirc;me si le sous-masque capturant initial ne tenait pas compte
       de la casse.
      </para>
      <para>
       Il peut y avoir plusieurs r&eacute;f&eacute;rences arri&egrave;res dans
       le m&ecirc;me sous-masque. Si un sous-masque n'a pas &eacute;t&eacute;
       utilis&eacute; dans une recherche, alors les r&eacute;f&eacute;rences
       arri&egrave;res &eacute;choueront. Par exemple "<literal>(a|(bc))\2</literal>"
       ne r&eacute;ussira jamais si la cha&icirc;ne sujet commence par
       "<literal>a</literal>" plut&ocirc;t que par "<literal>bc</literal>".
      </para>
      <para>
       Etant donn&eacute; qu'il peyt y avoir jusqu'&agrave; 99 r&eacute;f&eacute;rences
       arri&egrave;res, tous les chiffres apr&egrave;s l'antislash sont
       consid&eacute;r&eacute;s comment faisant potentiellement partie de
       la r&eacute;f&eacute;rence arri&egrave;re. Si le masque recherche un
       chiffre apr&egrave;s la r&eacute;f&eacute;rence, alors il faut
       imp&eacute;rativement utiliser des d&eacute;limiteurs pour terminer
       la r&eacute;f&eacute;rence arri&egrave;re.
      </para>
      <para>>
       Si l'option <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>
       est activ&eacute;e, on peut utiliser un espace.
       Sinon, un commentaire vide fait l'affaire. Une r&eacute;f&eacute;rence
       arri&egrave;re qui intervient &agrave; l'int&eacute;rieur de
       parenth&egrave;ses auquel elle fait r&eacute;f&eacute;rence
       &eacute;chouera d&egrave;s que le sous-masque sera utilis&eacute;. Par exemple,
       <literal>(a\1)</literal> &eacute;chouera toujours. Cependant, ces
       r&eacute;f&eacute;rences peuvent &ecirc;tre utiles dans les
       sous-masques r&eacute;p&eacute;titifs. Par exemple, le masque
       "<literal>(a|b\1)+</literal>" pourra convenir pour "<literal>a</literal>",
       "<literal>aba</literal>", "<literal>ababaa</literal>", etc....
      </para>
      <para>
       A chaque it&eacute;ration du sous-masque, la r&eacute;f&eacute;rence
       arri&egrave;re utilise le r&eacute;sultat du dernier sous-masque.
       Pour que cela fonctionne, il faut que la premi&egrave;re
       it&eacute;ration n'ai pas besoin d'utiliser la r&eacute;f&eacute;rence
       arri&egrave;re. Cela arrive avec les alternatives, comme dans
       l'exemple ci dessus, ou avec un quantificateur de minimum 0.
  	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.assertions">
	  <title>Assertions</title>
	  <para>
       Une assertion est un test sur les caract&egrave;res suivants ou
       pr&eacute;c&eacute;dent celui qui est en cours d'&eacute;tude. Ce
       test ne consomme par de caract&egrave;re (ie, on ne d&eacute;place
       pas le pointeur de caract&egrave;res). Les assertions simples sont
       cod&eacute;es avec <literal>\b</literal>, <literal>\B</literal>,
       <literal>\A</literal>, <literal>\Z</literal>, <literal>\z</literal>,
       <literal>^</literal> et <literal>$</literal>, et sont d&eacute;crites
       pr&eacute;c&eacute;demment.
      </para>
      <para>
       Il existe cependant un type d'assertions plus complexes, cod&eacute;es
       sous la forme de sous-masques. Il en existe deux types : celles qui
       travaillent au-dela de la position courante (<literal>\w+(?=;)</literal>),
       et celles qui travaillent en de&ccedil;a (<literal>(?!)\w+</literal>).
      </para>
      <para>
       Une assertion se comporte comme un sous-masque, hormis le fait qu'elle
       ne d&eacute;place pas le pointeur de position. Les assertions avant
       commencent par <literal>(?=</literal> pour les assertions positives, et
       par <literal>(?!</literal>, pour les assertions n&eacute;gatives. Par exemple :
       <literal>\w+(?=;)</literal> s'assure qu'un mot est suivi d'un point-virgule,
       mais n'inclus pas le point virgule dans la capture. D'autre part,
       <literal>(?!foo)bar</literal> en est proche, mais ne trouve pas une
       occurrence de "<literal>bar</literal>" qui soit pr&eacute;c&eacute;d&eacute;e
       par quelque chose d'autre que "<literal>foo</literal>foo"; il trouve toutes
       les occurrences de "<literal>bar</literal>", quelque soit ce qui
       le pr&eacute;c&eacute;de, car l'assertion <literal>(?!foo)</literal>
        est toujours vraie quand les trois caract&egrave;res suivants sont
        "<literal>bar</literal>". Une assertion arri&egrave;re est ici
        n&eacute;cessaire.
       </para>
       <para>
        Les assertions arri&egrave;res commencent par <literal>(?&lt;=</literal>
        pour les assertions positives, et <literal>(?&lt;!</literal> pour les
        assertions n&eacute;gatives. Par exemple : <literal>(?&lt;!foo)bar</literal>
        trouve les occurrences de "<literal>bar</literal>" qui ne sont pas
        pr&eacute;c&eacute;d&eacute;es par "<literal>foo</literal>".
       </para>
       <para>
        Le contenu d'une r&eacute;f&eacute;rence arri&egrave;re est limit&eacute;
        de telle fa&ccedil;on que les cha&icirc;nes qu'il utilise
        soient toujours de la m&ecirc;me taille. Cependant, lorsqu'il
        y a plusieurs alternatives, elles n'ont pas besoin d'&ecirc;tre
        de la m&ecirc;me taille. Par exemple, <literal>(?&lt;=bullock|donkey)</literal>
        est autoris&eacute;, tandis que <literal>(?&lt;!dogs?|cats?)</literal>
        provoque une erreur de compilation. Les alternatives qui ont des
        longueurs diff&eacute;rentes ne sont autoris&eacute;es qu'au niveau
        sup&eacute;rieur des assertions arri&egrave;res. C'est une
        am&eacute;lioration du fonctionnement de Perl 5.005, qui impose
        aux alternatives d'avoir toutes la m&ecirc;me taille. Une
        assertion telle que <literal>(?&lt;=ab(c|de))</literal> n'est pas
        autoris&eacute;e, car l'assertion de bas niveau (la deuxi&egrave;me,
        ici) a deux alternatives de longueurs diff&eacute;rentes. Pour
        la rendre acceptable, il faut &eacute;crire <literal>(?&lt;=abc|abde)</literal>
       </para>
       <para>
        L'impl&eacute;mentation des assertions arri&egrave;res d&eacute;place
        temporairement le pointeur de position vers l'arri&egrave;re, et cherche
        &agrave; v&eacute;rifier l'assertion. Si le nombre de caract&egrave;res
        est diff&eacute;rent, la position ne sera pas correcte, et l'assertion
        &eacute;chouera. La combinaison d'assertions arri&egrave;res avec des
        sous-masques peut &ecirc;tre particuli&egrave;rement pratique &agrave;
        fin des cha&icirc;nes. Un exemple est donn&eacute; &agrave; la fin de
        cette section.
       </para>
       <para>
        Plusieurs assertions peuvent intervenir successivement. Par exemple,
        le masque <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal> recherche
        les cha&icirc;nes "<literal>foo</literal>" pr&eacute;c&eacute;d&eacute;es
        par trois chiffres qui ne sont pas "999". Notez que chaque assertion
        est appliqu&eacute;es ind&eacute;pendemment, au m&ecirc;me point de
        la cha&icirc;ne &agrave; traiter. Tout d'abord, il est
        v&eacute;rifi&eacute; que les trois premiers caract&egrave;res ont
        tous des chiffres, puis on s'assure que ces trois caract&egrave;res
 	    ne sont pas "<literal>999</literal>". Le masque pr&eacute;c&eacute;dant
 	    n'accepte pas "<literal>foo</literal>" pr&eacute;c&eacute;d&eacute; de
 	    6 caract&egrave;res, les trois premiers &eacute;tant des chiffres et
 	    les trois suivants &eacute;tant diff&eacute;rents de "<literal>999</literal>".
 	    Par exemple, ce masque n'acceptera pas la cha&icirc;ne
 	    "<literal>123abcfoo</literal>". Pour ce faire, il faut utiliser le masque
 	    suivant : <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>. Dans ce
 	    masque, la premi&egrave;re assertion v&eacute;rifie les six premiers
 	    caract&egrave;res, s'assure que les trois premiers sont des entiers,
 	    et la deuxi&egrave;me assertion s'assure que les trois derniers
 	    caract&egrave;res ne sont pas "<literal>999</literal>".
 	   </para>
 	   <para>
        De plus, les assertions peuvent &ecirc;tre imbriqu&eacute;es :
        <literal>(?&lt;=(?&lt;!foo)bar)baz</literal> recherche les
        occurrences de "<literal>baz</literal>" qui sont
        pr&eacute;c&eacute;d&eacute;es par "<literal>bar</literal>", qui,
        &agrave; son tour, n'est pas pr&eacute;c&eacute;d&eacute; par
        "<literal>foo</literal>". Au contraire,
        <literal>(?&lt;=\d{3}(?!999)...)foo</literal> est un autre masque,
        qui recherche les caract&egrave;res "<literal>foo</literal>",
        pr&eacute;c&eacute;d&eacute;s par trois chiffres, suivis trois
        autres caract&egrave;res qui ne forment pas "<literal>999</literal>".
        Les assertions ne sont pas capturantes, et ne peuvent pas &ecirc;tre
        r&eacute;p&eacute;t&eacute;es. Si une assertion contient des sous-masques
        capturants en son sein, ils seront compris dans le nombre de sous-masques
        capturants du masque entier. La capture est r&eacute;alis&eacute;e pour
        les assertions positives, mais cela n'a pas de sens pour les
        assertions n&eacute;gatives.
       </para>
       <para>
        200 assertions au maximum sont autoris&eacute;es.
  	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.onlyonce">
	  <title>Sous-masques uniques</title>
	  <para>
       Avec les quantificateurs de r&eacute;p&eacute;titions, l'&eacute;chec
       d'une recherche conduit normalement &agrave; une autre recherche, avec
       un nombre diff&eacute;rent de r&eacute;p&eacute;titions, pour
       voir si le masque ne s'applique pas dans d'autres conditions.
       Parfois, il est pratique d'&eacute;viter ce comportement, soit
       pour changer la nature de la recherche, soit pour la faire abandonner
       plus t&ocirc;t, si on pense qu'il n'est pas besoin d'aller plus loin.
      </para>
      <para>
       Consid&eacute;rons par exemple, le masque <literal>\d+foo</literal>
       appliqu&eacute; &agrave; la ligne <literal>123456bar</literal>.
       Apr&egrave;s avoir tent&eacute; d'utiliser les 6 chiffres suivi
       de "<literal>foo</literal>" qui font &eacute;chouer, l'action habituelle
       sera de r&eacute;essayer avec 5 chiffres, puis avec 4, et ainsi de
       suite jusqu'&agrave; l'&eacute;chec final.
      </para>
      <para>
       Un sous-masque &eacute;valu&eacute; une seule fois permettrait
       d'indiquer que lorsqu'une partie du masque est trouv&eacute;e, elle
       n'a pas besoin d'&ecirc;tre r&eacute;&eacute;valu&eacute;e &agrave;
       chaque tentative. Ceci conduirait &agrave; ce que la recherche
       &eacute;choue imm&eacute;diatement apr&egrave;s le premier test.
       Ces assertions ont leur propre notation, commencant avec
       <literal>(?&gt;</literal> comme ceci : <literal>(?&gt;\d+)bar</literal>.
      </para>
      <para>
       Ce type de parenth&egrave;ses verrouille le sous-masque qu'il contient
       un fois qu'il a &eacute;t&eacute; trouv&eacute;, et emp&ecirc;che un
       &eacute;chec ult&eacute;rieur d'y repasser, mais autorise &agrave;
       revenir plus loin en arri&egrave;re. Une autre description est que
       les sous-masques de ce type recherche les cha&icirc;nes de
       caract&egrave;res, et les ancre le sous-masque &agrave; l'int&eacute;rieur
       de la cha&icirc;ne.
      </para>
      <para>
       Les sous-masques uniques ne sont pas capturants. Des cas simples comme
       ceux pr&eacute;sent&eacute;s ci-dessus peuvent &ecirc;tre pris comme
       des situations maximisantes, qui r&eacute;servent le maximum de
       caract&egrave;res. En effet, alors que <literal>\d+</literal> et
       <literal>\d+?</literal> ajustent le nombre de chiffres trouv&eacute;s
       de mani&egrave;re &agrave; laisser la possibilit&eacute; au masque de
       r&eacute;ussir, <literal>(?&gt;\d+)</literal> ne peut retenir que la
       s&eacute;quence enti&egrave;re de chiffres. Cette construction peut
       contenir un nombre arbitraire de sous-masques complexes, et ils peuvent
       &ecirc;tre imbriqu&eacute;s.
      </para>
      <para>
       Les sous-masques uniques ne peuvent &ecirc;tre utilis&eacute;s qu'avec
       les assertions arri&egrave;res, pour effectuer une recherche efficace
       en fin de cha&icirc;ne. Consid&eacute;rons un masque simple tel que
       "<literal>abcd$</literal>" appliqu&eacute; &agrave; une tr&egrave;s
       longue cha&icirc;ne qui ne lui correspond pas. A cause du syst&egrave;me
       de recherche de gauche &agrave; droite, PCRE va commencer par rechercher
       un "<literal>a</literal>" dans la cha&icirc;ne sujet, puis v&eacute;rifier
       si ce qui suit convient au reste du masque. Si le masque est
       sp&eacute;cifi&eacute; sous la forme <literal>^.*abcd$</literal>
       alors, la s&eacute;quence <literal>.*</literal> remplace en premier
       lieu la cha&icirc;ne enti&egrave;re, et &eacute;choue, repart en
       arri&egrave;re, et remplace tous les caract&egrave;res sauf le dernier,
       &eacute;choue, retourne en arri&egrave;re, prend un caract&egrave;re
       de moins, etc... et ainsi de suite. Encore une fois, la recherche du
       "<literal>a</literal>" passe en revue toute la cha&icirc;ne de gauche
       &agrave; droite, ce qui n'est pas tr&egrave;s efficace. Par contre,
       si le masque &eacute;tait &eacute;crit <literal>^(?&gt;.*)(?&lt;=abcd)</literal>
       alors il n'y aurait pas de retour en arri&egrave;re, pour satisfaire
       la s&eacute;quence <literal>.*</literal>, car elle ne peut que remplacer
       toute la cha&icirc;ne. L'assertion arri&egrave;re cons&eacute;cutive
       va alors faire un test sur les 4 derniers caract&egrave;res. Si elle
       &eacute;choue, la recherche est imm&eacute;diatement interrompue.
      </para>
      <para>
       Pour les cha&icirc;nes tr&egrave;s longues, cette approche fait la
       diff&eacute;rence en terme de performances et de temps de recherche.
	   Lorsqu'un masque contient une r&eacute;p&eacute;tition illimit&eacute;e
	   dans un sous-masque, qui contient lui-m&ecirc;me un nombre
	   illimit&eacute; de r&eacute;p&eacute;titeur, l'utilisation des
	   sous-masques &agrave; utilisation unique sont la seule fa&ccedil;on
	   d'&eacute;viter l'&eacute;chec de la recherche &agrave;  apr&egrave;s un
	   temps de calcul trop long.
	  </para>
	  <para>
   	   Le masque <literal>(\D+|&lt;\d+&gt;)*[!?]</literal> recherche un nombre
       illimit&eacute; de sous-cha&icirc;nes, qui contiennent soit
	   des non-chiffres, soit des chiffres inclus dans &lt;&gt;, suivi soit
	   par <literal>!</literal> ou par <literal>?</literal>. Lorsqu'il trouve
	   une solution, ce masque va tr&egrave;s vite. Mais, lorsqu'il est
	   appliqu&eacute; &agrave; une cha&icirc;ne telle que :
       <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>,
	   il lui faut beaucoup de temps pour annoncer un &eacute;chec. Cela est
	   d&ucirc; au fait que la chaine peut &ecirc;tre divis&eacute;e en deux
	   sous-cha&icirc;nes d'un grand nombre de fa&ccedil;ons, et qu'elles
	   ont toutes &eacute;t&eacute; essay&eacute;es. (Cet exemple utilisait
	   <literal>[!?]</literal> plut&ocirc;t qu'un caract&egrave;re simple, car
	   PCRE et PHP utilise une optimisation qui leur permettent de d&eacute;tecter
	   rapidement l'&eacute;chec lorsqu'un caract&egrave;re unique est
	   trouv&eacute;. Il se souvient du dernier caract&egrave;re qui est
	   attendu, et s'aper&ccedil;oit rapidement qu'il n'y a pas ce caract&egrave;re).
	  </para>
	  <para>
	   Si le masque utilis&eacute; est <literal>((?&gt;\D+)|&;lt;\d+&gt;)*[!?]</literal>
       les s&eacute;quences de chiffres ne peuvent pas &ecirc;tre
       trouv&eacute;es, et l'&eacute;chec intervient rapidement.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.conditional">
	  <title>Les sous-masques conditionnels</title>
	  <para>
       Il est possible de lier un sous-masque &agrave; une condition, ou de
       choisir entre deux sous-masques alternatifs, en fonction du
       r&eacute;sultat d'une assertion, ou suivant les r&eacute;sultats
       de recherche pr&eacute;c&eacute;dents.
      </para>
      <para>
       Les deux formes possibles de sous-masques conditionnels sont
       <literal>(?(condition)masque positif)</literal> et
       <literal>(?(condition) masque positif | masque n&eacute;gatif)</literal>.
      </para>
      <para>
       Si les conditions sont satisfaites, le masque positif est utilis&eacute;,
       sinon, le masque n&eacute;gatif est utilis&eacute;, si pr&eacute;sent.
       S'il y a plus de deux alternatives, une erreur est g&eacute;n&eacute;r&eacute;e
       &agrave; la compilation.
      </para>
      <para>
       Il y a deux types de conditions : si le texte entre les parenth&egrave;ses
       est une s&eacute;quence de chiffres, alors la condition est satisfaite si
       le sous-masque correspondant &agrave; ce num&eacute;ro a r&eacute;ussi.
       Consid&eacute;rons le masque suivant, qui contient des espaces non
       significatifs pour le rendre plus compr&eacute;hensible (on supposera
       l'option <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>
       activ&eacute;e) et qui est divis&eacute; en trois parties
       pour simplifier les explications : <literal>( \( )?    [^()]+    (?(1) \) )</literal>.
      </para>
      <para>
       La premi&egrave;re partie recherche une parenth&egrave;se ouvrante
       optionnelle, et si elle existe, elle est captur&eacute;e. La deuxi&egrave;me
       partie recherche un s&eacute;quence de caract&egrave;res qui ne contiennent
       pas de parenth&egrave;ses. La troisi&egrave;me partie est
       conditionn&eacute;e &agrave; la premi&egrave;re, et s'assure que si il
       y avait une parenth&egrave;se ouvrante, il en existe une fermante.
       Si une parenth&egrave;se ouvrante a &eacute;t&eacute; trouv&eacute;e,
       elle a &eacute;t&eacute; captur&eacute;e, et donc la premi&egrave;re capture
       existe, et la condition est ex&eacute;cut&eacute;e. Sinon, elle est
       ignor&eacute;e.
      </para>
      <para>
       Ce masque recherche donc une s&eacute;quence de lettres, &eacute;ventuellement
       plac&eacute;es entre parenth&egrave;se. Si la condition n'est pas une
       s&eacute;quence de chiffres, il faut que ce soit une assertion.
       Ce peut &ecirc;tre une assertion positive ou n&eacute;gative,
       arri&egrave;re ou avant. Consid&eacute;rons le masque suivant
       (m&ecirc;me conditions que le pr&eacute;c&eacute;dent) et avec deux
       alternatives en seconde ligne :
       <literal>(?(?=[^a-z]*[a-z])\d{2}[a-z]{3}-\d{2} | \d{2}-\d{2}-\d{2} )</literal>.
       La condition est une assertion avant positive, qui recherche une
       s&eacute;quence optionnelle de caract&egrave;res non-lettre. En d'autres
       termes, elle teste la presence d'au moins une lettre dans la cha&icirc;ne
       sujet. Si une lettre est trouv&eacute;e, la recherche se poursuit avec
       la premi&egrave;re alternative, et sinon, avec la seconde. Ce masque
       recherche des cha&icirc;nes de la forme <literal>dd-aaa-dd</literal> ou
       <literal>dd-dd-dd</literal>, avec "<literal>aaa</literal>" qui sont des
       lettres, et <literal>dd</literal> qui sont des chiffres.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.comments">
	  <title>Commentaires</title>
	  <simpara>
       La s&eacute;quence <literal>(?#</literal> marque le d&eacute;but d'un commentaire,
       qui se termine &agrave; la procha&icirc;ne parenth&egrave;se fermante. Les
       parenth&egrave;ses imbriqu&eacute;es ne sont pas autoris&eacute;es. Les
       caract&egrave;res entre ces d&eacute;limiteurs ne jouent alors aucun r&ocirc;le
       dans le masque.
	  </simpara>
	  <simpara>
       Si l'option <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>
        est activ&eacute;e, les caract&egrave;res di&egrave;ses
       <literal>#</literal> non &eacute;chapp&eacute;s en dehors d'une classe de
       caract&egrave;res introduisent un commentaire qui continuera jusqu'&agrave;
       la procha&icirc;ne ligne dans le masque.
	  </simpara>
	 </refsect2>
	 <refsect2 id="regexp.reference.recursive">
	  <title>Masques r&eacute;cursifs</title>
 	  <para>
 	   Consid&eacute;rons le cas o&ugrave; il faut recherche dans une
 	   cha&icirc;ne, avec un niveau d'imbrications infini de
 	   parenth&egrave;ses. Sans l'aide de la r&eacute;cursivit&eacute;, le
 	   mieux que nous puissions obtenir est de cr&eacute;er un masque avec un
	   niveau fix&eacute; de profondeur d'imbrication. Il n'est pas possible
	   de traiter des masques &agrave; niveau d'imbrications variable.
	   PCRE fournit un nouvel outil exp&eacute;rimental qui permet
	   d'utiliser la r&eacute;cursivit&eacute; dans les masques (entre autre).
	   L'option <literal>(?R)</literal> est fournie pour servir la cause de
	   la r&eacute;cursivit&eacute;. Le masque suivant r&eacute;soud le
	   probl&egrave;me des parenth&egrave;ses (l'option
	   <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link> est
	   utilis&eacute;e pour ignorer les espaces) :
       <literal>\( ( (?&gt;[^()]+) | (?R) )* \)</literal>
      </para>
      <para>
       Tout d'abord, le masque recherche une parenth&egrave;se ouvrante. Puis,
       il recherche n'importe quel nombre de sous-cha&icirc;nes qui sont soit
       des s&eacute;quences de caract&egrave;res non-parenth&egrave;ses, ou
       bien une recherche r&eacute;cursive avec le m&ecirc;me masque (i.e.
       une cha&icirc;ne correctement incluse entre parenth&egrave;ses).
       Finalement, il recherche une parenth&egrave;se fermante.
      </para>
      <para>
       Cet exemple particulier contient un nombre illimit&eacute; de
       r&eacute;p&eacute;titions imbriqu&eacute;es, ce qui fait que
       l'utilisation de sous-cha&icirc;nes &agrave; utilisation unique
       pour rechercher les s&eacute;quence de caract&egrave;res
       non-parenth&egrave;ses est important, lorsqu'il s'applique &agrave;
       une cha&icirc;ne qui n'est pas valide. Par exemple, si on l'applique
       &agrave; "<literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>"
       la r&eacute;ponse arrive rapidement. Sinon, si les sous-cha&icirc;nes
       &agrave; utilisation unique ne sont pas utilis&eacute;es, la
       recherche peut prendre un tr&egrave;s long temps, car il existe
       de tr&egrave;s nombreuses combinaisons de <literal>+</literal> et
       <literal>*</literal> &agrave; tester avant de conclure &agrave;
       l'&eacute;chec.
      </para>
      <para>
       Les valeurs utilis&eacute;es pour capturer les sous-masques sont celles
       utilis&eacute;es par les niveaux les plus hauts de
       r&eacute;cursivit&eacute;s, auquel la valeur est fix&eacute;e.
       Si le masque pr&eacute;c&eacute;dent est utilis&eacute; avec
       <literal>(ab(cd)ef)</literal> la valeur de la parenth&egrave;se
       capturante est "<literal>ef</literal>", qui est la derni&egrave;re
       valeur lue au niveau sup&eacute;rieur. Si de nouvelles
       parenth&egrave;ses sont ajout&eacute;es, par exemple :
       <literal>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</literal>
       alors la cha&icirc;ne captur&eacute;e est "<literal>ab(cd)ef</literal>",
       c'est &agrave; dire le contenu de la parenth&egrave;ses capturant
       de plus haut niveau. S'il y a plus de 15 parenth&egrave;ses
       capturantes dans une cha&icirc;ne, PCRE doit utiliser plus
       de m&eacute;moire pour stocker ces donn&eacute;es. S'il ne
       peut obtenir cette m&eacute;moire suppl&eacute;mentaire, il ne fait
       que sauver les 15 premi&egrave;res, car il n'y a pas moyen de
       g&eacute;n&eacute;rer une erreur de m&eacute;moire lors d'une
       r&eacute;cursion.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.performances">
	  <title>Performances</title>
	  <para>
       Certaines s&eacute;quences de recherches sont plus efficaces que d'autres.
       Ainsi, il est plus efficace d'utiliser une classe de caract&egrave;res
       telle que <literal>[aeiou]</literal> plut&ocirc;t qu'une alternative
       <literal>(a|e|i|o|u)</literal>.
      </para>
      <para>
       En g&eacute;n&eacute;ral, le masque le plus simple, qui permette
       la recherche d&eacute;sir&eacute;e est le plus efficace. Le livre
       de Jeffrey Friedl's contient de nombreuses &eacute;tudes &agrave;
       propos de l'optimisation des expressions r&eacute;guli&egrave;res.
      </para>
      <para>
       Lorsqu'un masque commence par.* et que l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> est
       activ&eacute;e, le masque est implicitement ancr&eacute; par PCRE,
       &eacute;tant donn&eacute; qu'il ne peut que rechercher au d&eacute;but
       de la cha&icirc;ne. Cependant, si option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> n'est pas
       activ&eacute;e, PCRE ne peut faire aucune optimisation car le
       m&eacute;ta-caract&egrave;res point "<literal>.</literal>"
       ne remplace pas une nouvelle ligne, et si la cha&icirc;ne
       sujet contient des nouvelles lignes, le masque peut trouver une
       solution qui serait situ&eacute;e juste apr&egrave;s une
       de ces nouvelles lignes, et non pas seulement au d&eacute;but
       de la cha&icirc;ne sujet. Par exemple, le masque,
       <literal>(.*)second</literal> acceptera la cha&icirc;ne
       "<literal>premier \net second</literal>" (avec "<literal>\n</literal>"
       qui remplace la nouvelle ligne), et la premi&egrave;re cha&icirc;ne
       captur&eacute;e sera "<literal>et</literal>".
      </para>
      <para>
       Afin d'effectuer la recherche, PCRE va essayer d'appliquer le masque
       &agrave; partir de chaque d&eacute;but de ligne. Si vous utilisez un
       tel masque avec des cha&icirc;nes qui ne contiennent pas de
       caract&egrave;res de nouvelles lignes, les meilleures performances
       seront atteintes avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>, ou en ancrant le
       masque avec <literal>^.*</literal>. Cela &eacute;vite &agrave; PCRE
       de scanner toute la cha&icirc;ne pour rechercher un caract&egrave;re
       de nouvelle ligne et recommencer la recherche.
      </para>
      <para>
  	   Attention aux masques qui contiennent des quantificateurs infinis
	   imbriqu&eacute;s. Ils peuvent demander un temps de calcul tr&egrave;s
	   long, lorsqu'appliqu&eacute;s &agrave; une cha&icirc;ne qui ne
	   correspond pas &agrave; ce masque. Par exemple, <literal>(a+)*</literal>
       peut accepter "<literal>aaaa</literal>" de 33 mani&egrave;res
       diff&eacute;rentes, et ce nombre croit rapidement avec la taille
       de la cha&icirc;ne (le quantificateur <literal>*</literal> peut prendre
       les valeurs de 0, 1, 2, 3, ou 4, et pour chaque cas non nul, le
       quantificateur <literal>+</literal> peut prendre diff&eacute;rentes
       valeurs).
      </para>
      <para>
       Lorsque le reste de la cha&icirc;ne est tel que l'on s'achemine
       vers un &eacute;chec, PCRE doit en principe v&eacute;rifier
       toutes les possibilit&eacute;s, et cela prend un temps
       extr&ecirc;mement long. Un optmiseur rep&egrave;re les cas
       les plus simples, tel que <literal>(a+)*b</literal> o&ugrave;
       un caract&egrave;re simple suit les quantificateurs. Avant de partir
       dans les proc&eacute;dures standard de recherche, PCRE
       s'assure qu'il y a au moins un "<literal>b</literal>" dans la
       cha&icirc;ne, et si ce n'est pas le cas, l'&eacute;chec est
       annonc&eacute; imm&eacute;diatement. Sinon, il n'y a pas
       d'optimisation dans la recherche. Vous pouvez voir la
       diff&eacute;rence de comportement avec le masque suivant :
       <literal>(a+)*\d</literal>. Le premier retourne un &eacute;chec
       quasi-imm&eacute;diatement, s'il est appliqu&eacute; &agrave;
       une ligne de "<literal>a</literal>", alors que le second masque
       prend un temps significatif pour une cha&icirc;ne de plus de
       20 caract&egrave;res.
      </para>
	 </refsect2>
   </refsect1>
  </refentry>
</reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
