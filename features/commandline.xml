<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
<chapter id="features.commandline">
 <title>Utiliser PHP en ligne de commande</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  Depuis la version 4.3, &php; supporte un nouveau type
  de <literal>SAPI</literal> (Server Application Programming Interface,
  c'est à dire Interface de Programmation d'Applications Serveur) appelé
  <literal>CLI</literal>, ce qui signifie <emphasis>Command Line Interface</emphasis>
  et se traduit par <literal>Interface de Ligne de Commande</literal>. 
  Comme son nom l'indique, ce type <literal>SAPI</literal> cible les
  applications shell (ou desktop), écrites en PHP. Il y a pas mal de
  différences enter le type <literal>CLI SAPI</literal> et les autres
  <literal>SAPI</literal>, qui sont expliqués dans ce chapitre.
 </para>
 <para>
  Le <literal>CLI SAPI</literal> a été publié pour la première fois avec
  la version <literal>PHP 4.2.0</literal>, mais il est resté expérimental,
  et doit être explicitement activé avec la commande <literal>--enable-cli</literal>,
  lorsque vous exécutez le script <literal>./configure</literal>. Depuis
  PHP 4.3.0, le <literal>CLI SAPI</literal> n'est plus expérimental, et
  est donc <emphasis role="strong">toujours</emphasis> compilé et 
  installé comme binaire PHP (appelé aussi <filename>php.exe</filename> sous
  Windows).
 </para>
 <para>
  Les différences les plus notables entre le <literal>CLI SAPI</literal> et les 
  <literal>SAPI</literal> sont :
  <itemizedlist>
   <listitem>
    <para>
     Contrairement au <literal>CGI SAPI</literal>, aucun en-tête HTTP n'est écrit
     dans le résultat.
    </para>
    <para>
     Bien que le <literal>CGI SAPI</literal> fournisse un moyen de supprimer les
     en-têtes HTTP, il n'y a pas moyen d'activer les en-têtes HTTP dans le 
     <literal>CLI SAPI</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     Il y a plusieurs directives du &php.ini; qui sont ignorées par le 
     <literal>CLI SAPI</literal>, car elles n'ont pas de sens, en environnement
     shell : 
     <table>
      <title>Directives &php.ini; ignorées</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Directive</entry>
         <entry>Valeur par défaut pour <literal>CLI SAPI</literal></entry>
         <entry>Commentaire</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          Il peut être bien difficile de lire les messages d'erreur sur un terminal
          lorsqu'ils sont noyés dans des balises HTML sans grand intérêts. Par
          conséquent, cette directive est forcée à &false;.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          Il est souhaitable que tout affichage en provenance de 
          <function>print</function>, <function>echo</function> et consorts soit
          immédiatement affiché dans le terminal, et non pas placé dans un
          buffer quelconque. Vous pouvez toujours utiliser 
          <link linkend="ref.outcontrol">la bufferisation de sortie</link>
          si vous voulez retarder un affichage, ou bien en manipuler ultimement
          le contenu.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (unlimited)</entry>
         <entry>
          Etant donné les possibilités infinies de PHP en 
          environnement shell, le temps d'exécution maximal d'un 
          script PHP a été rendu illimité.
          Alors que les scripts destinés au web doivent s'accomplir en une 
          fraction de seconde, il arrive que les scripts shell requièrent
          bien plus de temps.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          En donnant la valeur de &true; à cette directive, vous aurez toujours
          accès à la variable <emphasis>argc</emphasis> (représentant le nombre
          d'arguments passés à l'application) et 
          <emphasis>argv</emphasis> (le tableau contenant les arguments passés)
          dans le <literal>CLI SAPI</literal>.
         </para>
         <para>
          Depuis &php; 4.3.0, les variables <varname>$argc</varname>
          et <varname>$argv</varname> sont définies et remplies avec les valeurs
          appropriées, en utilisant <literal>CLI SAPI</literal>. Avant cette version,
          la création de ces variables était liée au comportement des versions 
          <literal>CGI</literal> et <literal>MODULE</literal>, qui requièrent l'activation
          de la directive &php; 
          <link linkend="ini.register-globals">register_globals</link>. 
          Indépendamment de la version ou de la valeur de register_globals,
          vous pouvez toujour accéder à 
          <link linkend="reserved.variables.server"><varname>$_SERVER</varname></link> et
          <varname>$HTTP_SERVER_VARS</varname>.  Par exemple:
          <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      Ces directives ne peuvent pas être initialisées avec d'autres valeurs
      dans le fichier &php.ini; ou par une autre méthode. C'est une limitation,
      car ces valeurs par défaut s'appliquent une fois que tous les autres
      fichiers de configuration ont été analysés. Cependant, ces
      valeurs peuvent être modifiées durant l'exécution (ce qui n'est pas
      logique pour certaines directives, comme par exemple 
      <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Pour faciliter le travail en environnement shell, les constantes suivantes
     sont définies : 
     <table>
      <title>Constantes spécifiques au CLI</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Constante</entry>
         <entry>Déscription</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         Un descripteur de fichier déjà disponible vers <literal>stdin</literal>. 
         Cela évite de l'ouvrir avec 
         <programlisting role="php">
<![CDATA[
$stdin = fopen('php://stdin', 'r');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         Un descripteur de fichier déjà disponible vers <literal>stdout</literal>.
         Cela évite de l'ouvrir avec 
         <programlisting role="php">
<![CDATA[
$stdout = fopen('php://stdout', 'w');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         Un descripteur de fichier déjà disponible vers 
         <literal>stderr</literal>. Cela évite de l'ouvrir avec 
         <programlisting role="php">
<![CDATA[
$stderr = fopen('php://stderr', 'w');
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Etant donné ce qui précède, vous n'avez pas besoin d'ouvrir un fichier
     vers <literal>stderr</literal> par vous-même, mais vous pouvez utiliser
     cette constante directement, comme un descripteur de fichier : 
     <programlisting role="php">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     Vous n'avez pas non plus à fermer explicitement ces fichiers, PHP s'en 
     chargera automatiquement.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>CLI SAPI</literal> <emphasis role="strong">ne transforme pas</emphasis>
     le dossier courant en dossier d'exécution du script!
    </para>
    <para>
     Exemple de différence entre <literal>CGI SAPI</literal> et <literal>CLI SAPI</literal>:
     <programlisting role="php">
<![CDATA[
<?php
    /* Un test simple : affiche le dossier d'exécution */
    echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     Lorsque vous utilisez la version <literal>CGI</literal>, l'affichage pourra être
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f autre_dossier/test.php
/tmp/autre_dossier
]]>
     </screen>
     Cela monter clairement que &php; modifie le dossier
     courant, et utilise le dossier du script exécuté.
    </para>
    <para>
     En utilisant le <literal>CLI SAPI</literal>, on obtient :
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f autre_dossier/test.php
/tmp
]]>
     </screen>
     Cela donne beaucoup plus de souplesse lorsque vous rédigez des
     scripts shell avec &php;.
    </para>
    <note>
     <para>
      <literal>CGI SAPI</literal> supporte le même comportement de 
      <literal>CLI SAPI</literal>, en lui passant l'option 
      <literal>-C</literal>, lorsque vous l'invoquez en ligne de commmande.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  La liste des options de ligne de commande fournies par &php;
  est disponible en exécutant &php; avec l'option <literal>-h</literal> :
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
  </screen>
 </para>
 <para>
  Le <literal>CLI SAPI</literal> dispose de trois moyens pour lire le 
  code du script PHP que vous voulez exécuter : 
  <orderedlist>
   <listitem>
    <para>
     Indiquer à &php; d'exécuter un fichier : 
    </para>
    <para>
     <screen>
<![CDATA[
php mon_script.php

php -f mon_script.php
]]>
     </screen>
     Les deux méthodes (en utilisant <literal>-f</literal> ou pas) exécute le
     script contenu dans le fichier <filename>mon_script.php</filename>. Vous 
     pouvez choisir n'importe quel fichier, et ces fichiers ne sont pas
     tenus d'utiliser l'extension <filename>.php</filename>. N'importe
     quelle extension peut faire l'affaire.
    </para>
   </listitem>
   <listitem>
    <para>
     Donner du code &php; à exécuter directement en ligne de commande.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     Une attention particulière doit alors être apportée aux variables d'environnement,
     qui seront remplacées, et aux guillements, qui ont des significations spéciales en
     ligne de commande.
    </para>
    <note>
     <para>
      Lisez l'exemple attentivement, il n'y a ni balise d'ouverture, ni balise de fermeture!
      L'option <literal>-r</literal> fonctionne sans ces balises, et les ajouter conduira
      alors à une erreur d'analyse.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Donner du code &php; dans l'entrée standard 
     (<literal>stdin</literal>).
    </para>
    <para>
     Cela donne la possibilité de créer dynamiquement du code 
     &php;, puis de le fournir à PHP, et enfin,
     de le traiter à nouveau en shell. Voici un exemple fictif :
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  Il n'est pas possible de combiner ces trois modes d'exécution.
 </para>
 <para>
  Comme toute application shell, l'exécutable &php; accepte
  des arguments, et votre script peut aussi les recevoirs. Le nombre d'arguments
  n'est pas limité par PHP, mais par le shell, qui a une limite en terme
  de nombre de caractères qui peuvent être passés. Généralement, vous n'atteidrez
  pas cette limite, mais cela reste possible. Les arguments passés au script seront
  transmis via la variable tableau <literal>$argv</literal>. L,index zéro 
  contiendra toujours le nom du script appelé. Si le code a été fourni en ligne
  de commande, ou via <literal>stdin</literal>, ce premier élément vaudra
  <literal>-</literal>. L'autre variable globale fournie est 
  <literal>$argc</literal> qui contient le nombre d'éléments dans le tableau
  <literal>$argv</literal> : ce nombre est <emphasis role="strong">différent</emphasis> 
  du nombre d'arguments passés au script.
 </para>
 <para>
  Tant que les arguments que vous passez à votre script ne commencent pas par 
  le caractère <literal>-</literal>, il n'y a rien de spécial à surveiller.
  Si vous passez des arguments à voter script qui commencent par 
  <literal>-</literal>, cela posera des problèmes car &php;
  va penser qu'il doit les interpréter. Pour éviter cela, utilisez le séparateur
  <literal>--</literal>. Après cet argument, tous les arguments suivants seront
  passés à votre script sans être modifié ou analysé par PHP.
 </para>
 <screen>
<![CDATA[
# Cela ne va pas exécuter le code, mais afficher l'aide de PHP
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Cela va passer l'argument '-h' à votre script, et éviter que PHP ne le traite
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
 </screen>
 <para>
  Cependant, il y a une autre méthode pour utiliser PHP en script shell.
  Vous pouvez aussi utiliser la ligne <literal>#!/usr/bin/php</literal> 
  en tout début de votre script, suivi de code PHP compris entre
  balise ouvrantes/fermantes. Vous pouvez aussi ajouter après 
  <literal>#!/usr/bin/php</literal> les options nécessaires. Vous 
  pouvez aussi le faire en ligne de commande.
  De cette manière, le script peut être exécuté comme un script
  shell habituel :
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
  En supposant que ce fichier s'appelle<filename>test</filename>, dans le
  dossier courant, nous pouvons alors faire ceci : 
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
  Comme vous le voyez, aucune précaution n'est nécessaire pour passer des 
  paramètres qui commencent par <literal>-</literal> à votre script.
 </para>
 <para>
  <table>
   <title>Options de ligne de commande</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>
       <para>
        Affiche le code avec la colorisation syntaxique.
       </para>
       <para>
        Cette option utilise le mécanisme interne pour analyser le fichier,
        et produire une version colorisée du code source, au format HTML.
        Notez que cette option ne fait que générer un bloc
        <literal>HTML</literal>, sans les en-têtes.
        <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>
       </para>
       <note>
        <para>
         Cette option ne fonctionne pas avec l'option <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>
       <para>
        Affiche la source sans les commentaires et les espaces.
       </para>
       <note>
        <para>
         Cette option ne fonctionne pas avec l'option <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       <para>
        Analyse et exécute le fichier donné après l'option <literal>-f</literal>.
        Cette optione est optionnelle, et peut être omise. Le seul nom du fichier
        est suffisant.
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       <para>
        Affiche les versions de PHP, PHP SAPI, et Zend sur le terminal. Par exemple : 
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0-dev (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.2.1, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       <para>
        Avec cette option, vous pouvez spécifier le nom du dossier dans lequel
        PHP va recherche le fichier &php.ini;, ou encore vous pouvez
        spécifier un fichier de configuration directement (qui n'a pas
        obligatoirement à être appelé &php.ini;) :
        <screen>
<![CDATA[
$ php -c /custom/directory/ mon_script.php

$ php -c /custom/directory/custom-file.ini mon_script.php
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>
       <para>
        Exécute PHP de manière interactive.
        <!-- 
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       <para>
        Cette option permet de modifier n'importe quelle directive de configuration
        du fichier &php.ini;. La syntaxe est :
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para>
        Exemples:
        <screen>
<![CDATA[
# L'omission de la valeur conduit à donner la valeur de "1"
$ php -d max_execution_time -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passer une valeur vide conduit à donner la valeur de ""
php -d max_execution_time= -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# La directive de configuration sera n'importe quelle valeur passée après le caractère '='
$  php -d max_execution_time=20 -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>
       <para>
        Génére des informations étendues pour le profilage et le débogage.
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>
       <para>
        Charge une extension Zend. Si seulement un fichier est fourni, PHP
        essaie de charger cette extension dans le dossier courant par défaut
        des librairie sur votre système (généralement spécifié avec 
        <filename>/etc/ld.so.conf</filename> sous Linux). Passer un nom de
        fichier avec le chemin complet fera que PHP utilisera ce fichier,
        sans recherche dans les dossiers classiques. Un chemin de dossier
        relatif indiquera à PHP qu'il doit chercher uniquement les extensions
        dans ce dossier.
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       <para>
        Cette option permet de faire une vérification syntaxique sur le code
        PHP fourni. En cas de réussite, le message 
        <literal>No syntax errors detected in &lt;filename&gt;</literal> 
        (<literal>Aucune d'erreur de syntaxe n'ont été détectées dans &lt;nom_de_fichier&gt;</literal> 
        est affiché sur la sortie standard, et le script shell retourne
        <literal>0</literal>. En cas d'erreur, le message 
        <literal>Errors parsing &lt;filename&gt;</literal> 
        (<literal>Erreurs d'analyse dans le fichier &lt;filename&gt;</literal>) 
        est affiché, en plus des messages d'erreurs détectés par l'analyseur
        lui même. Le script shell retourne le code <literal>255</literal>.
       </para>
       <para>
        Cette option ne détecte pas les erreurs fatales (comme par exemple les
        fonctions non définies). Utilisez <literal>-f</literal> si vous voulez
        tester aussi ces erreurs.
       </para>
       <note>
        <para>
         Cette option ne fonctionne pas avec l'option <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       <para>
        Cette option liste les extensions PHP et Zend compilées et chargées : 
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       Cette option appelle la fonction <function>phpinfo</function>, et
       affiche le résultat. Si &php; ne fonctionne pas
       correctement, il est recommandé d'utiliser la commande <literal>php -i</literal> 
       et de voir si il n'y a pas d'erreurs affichées avant ou après la
       table d'information. N'oubliez pas que le résutltat de cette
       option est au format <literal>HTML</literal>, et donc grand
       et illisible directement.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>
       <para>
        Cette option permet l'exécution de &php; directement
        dans la ligne de commande. Les balises de &php; 
        (<literal>&lt;?php</literal> et <literal>?&gt;</literal>) 
        <emphasis role="strong">ne sont pas</emphasis> demandées, et coauseront
        une erreur d'analyse.
       </para>
       <note>
        <para>
         De l'attention doit être portée lors de l'utilisation de cette option
         de &php;, pour qu'il n'y ait pas de collision avec
         les substitutions de variables en lignes de commande, réalisées par le
         shell.
        </para>
        <para>
         Exemple conduisant à une erreur d'analyse : 
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         Le problème ici est que le shell (sh/bash) effectue une substitution
         de variables, grâce aux guillemets doubles <literal>"</literal>. 
         puisque la variable <literal>$foo</literal> n'est probablement pas
         définie dans le shell, elle est remplacée par rien, ce qui fait
         que le code passé à PHP pour l'exécution est : 
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         La solution de ce problème est d'utiliser les guillemets simples
         <literal>'</literal>. Les variables de ces chaînes ne seront pas
         substituées par leurs valeurs par le shell.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         Si vous utilisez un shell différent de sh/bash, vous pouvez
         rencontrer d'autres problèmes. N'hésitez pas à ouvrir un
         rapport de bugs, ou d'envoyer un mail à 
         phpdoc@lists.php.net.

         Il est toujours très facile d'avoir des problèmes lorsque vous essayez
         d'inclure des variables shell dans le code, ou d'utiliser les anti-slash
         pour l'échappement. Vous aurez été prévenu.
       <!-- :-) -->
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       Avec cette option, vous pouvez obtenir des informations sur la liste des
       options supporté par votre PHP, avec des explications succintes.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php > test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 <para>
  This list of command line options is consistent with PHP 4.0.6.
  You can get the actual list and some one line descriptions
  with the <literal>-h</literal> option. The output of
  <literal>php -h</literal> should be something like this:
  <screen>
<![CDATA[
Usage: php [-q] [-h] [-s [-v] [-i] [-f <file>] |  {<file> [args...]}
  -q             Quiet-mode.  Suppress HTTP Header output.
  -s             Display colour syntax highlighted source.
  -f <file>      Parse <file>.  Implies `-q'
  -v             Version number
  -C             Do not chdir to the script's directory
  -c <path>      Look for php.ini file in this directory
  -d foo[=bar]   Define INI entry foo with value 'bar'
  -e             Generate extended information for debugger/profiler
  -z <file>      Load Zend extension <file>.
  -l             Syntax check only (lint)
  -m             Show compiled in modules
  -i             PHP information
  -h             This help
]]>
  </screen>
 </para>
 <para>
  Here we list some of the most important command line options
  with detailed explanations.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-q</entry>
      <entry>
       Suppress HTTP headers output. Normally PHP prints out
       HTTP headers for the calling program (ie. webserver)
       to hand on to the browser. When writing command line
       applications these headers are useless.
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>
       Display the color highlighted source of the file
       given with its name. This is the same as if you were
       printing out the source using the
       <function>highlight_file</function> function in
       a PHP script.
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       Parse the file given, and search for syntactical and
       fatal errors. This option implies -q. Use for
       debugging purposes.
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       By calling PHP with this option, you can ask
       it to print out its version number, ie: 4.0.6. 
      </entry>
     </row>
     <row>
      <entry>-C</entry>
      <entry>
       Normally PHP changes the working directory to the
       running scripts directory. This makes it possible
       for example, to open files in the same directory,
       with only specifying the name of the file. If you
       would like to disable this directory change, use
       this option.
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       Using this option, you can specify an alternative
       &php.ini; path, so PHP will
       search your configurations file in this path
       instead of the default one.
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       With this option, you can set individual 
       &php.ini; settings in the
       time of running a script.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       Check the file given for syntax errors. This
       option implies -q. Use for debugging purposes.
       This option won't find fatal errors (like undefined
       functions). Use -f if you would like to test
       for fatal errors too.
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       Using this option, PHP prints out the built in
       (and loaded) PHP and Zend modules, the PHP
       and Zend version numbers, and a short Zend
       copyright notice.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls
       <function>phpinfo</function>, and prints
       out the results. If PHP is not working well,
       it is advisable to make a <literal>php -i</literal>
       and see if any error messages are printed out
       before or in place of the information tables.
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about
       the actual list of command line options and some
       one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 -->
 <para>
  L'exécutable PHP peut être utilisé pour exécuter des scripts indépendants du
  serveur web. Si vous êtes sur un système Unix, il est recommandé d'ajouter
  la ligne de configuration en début de scripts, de le rendre exécutable de
  manière à ce que le système sache quel programme doit exécuter le script.
  Sous Windows, vous pouvez associer l'exécutable <literal>php.exe</literal> 
  avec le double-clic sur les fichiers d'extension <literal>.php</literal>,
  ou bien vous pouvez faire un fichier batch pour exécuter le script grâce
  à PHP. La première ligne utilisée dans le monde Unix ne perturbera pas
  PHP sous Windows, ce qui rend les scripts facilements portables. Un exemple
  complet est disponible ci-dessous : 
 </para>
 <example>
  <title>Script prévu pour être exécuté en ligne de commande (script.php)</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

C'est une ligne de commande à une option.

  Utilisation :
  <?php echo $argv[0]; ?> <option>

  <option> peut être un mot que vous souhaitez afficher.
  Avec les options --help, -help, -h,
  et -?, vous obtiendrez cette aide.
  
<?php
} else {
    echo $argv[1];
}
?>
]]>
  </programlisting>
 </example>
 <para>
  Dans le script ci-dessus, nous utilisons la première ligne pour indiquer
  que le fichier doit être exécuté par PHP. Nous travaillons avec une version
  CLI, donc il n'y a pas d'en-têtes HTTP qui soient affichés. Il y a deux
  variables que vous pouvez utiliser avec les applications de ligne de commande :
  <varname>$argc</varname> et <varname>$argv</varname>. La première
  est le nombre d'arguments plus un (le nom du script qui est
  exécuté). La seconde est un tableau contenant les arguments, commençant
  avec le nom du script en élément 0 (<varname>$argv[0]</varname>).
 </para>
 <para>
  Dans notre exemple, nous avons vérifié qu'il y a plus ou moins d'un
  argument. De plus, si cet argument est <literal>--help</literal>,
  <literal>-help</literal>, <literal>-h</literal> ou <literal>-?</literal>,
  nous avons affiché un message d'aide, ainsi que le nom du
  script. Nous nous recevons un autre argument, cet argument est affiché
  dans le terminal.
 </para>
 <para>
  Pour exécuter le script ci-dessus sous Unix, vous devez le rendre
  exécuétable, puis l'appeler avec une commande comme : 
  <literal>script.php echothis</literal> ou
  <literal>script.php -h</literal>. Sous Windows, vous pouvez faire un
  fichier batch pour cela :
  </para>
 <example>
  <title>Fichier batch pour exécuter un script PHP en ligne de commande (script.bat)</title>
  <programlisting role="winbat">
@c:\php\php.exe script.php %1 %2 %3 %4
  </programlisting>
 </example>
 <para>
  Si vous avez nommé le programme ci-dessus 
  <filename>script.php</filename>, et que vous avez votre exécutable
  <filename>php.exe</filename> situé à 
  <filename>c:\php\php.exe</filename>, ce fichier batch l'exécutera
  avec les options que vous lui passez : 
  <literal>script.bat echothis</literal> ou
  <literal>script.bat -h</literal>.
 </para>
 <para>
  Voir aussi l'extension <link linkend="ref.readline">Readline</link>,
  qui dispose de nombreuses fonctions pour améliorer la convivialité
  de vos applications en ligne de commande.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
