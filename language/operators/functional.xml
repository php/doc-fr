<?xml version="1.0" encoding="utf-8"?>
<sect1 xml:id="language.operators.functional">
 <title>Opérateurs fonctionnels</title>
 <titleabbrev>Fonctionnels</titleabbrev>
 <para>
  PHP 8.5 et versions ultérieures prennent en charge un opérateur qui fonctionne directement
  sur les fonctions appelables. L'opérateur <literal>|&gt;</literal>, ou « pipe », accepte
  une fonction appelable à un seul paramètre à droite et lui transmet la valeur de gauche,
  le résultat étant la valeur renvoyée par la fonction appelable. La fonction appelable de
  droite peut être n'importe quelle fonction appelable PHP valide : une <classname>Closure</classname>,
  une <link linkend="functions.first_class_callable_syntax">fonction appelable de première classe
 </link>, un objet qui implémente <link linkend="object.invoke">__invoke()</link>, etc.
 </para>
 <para>
  Cela signifie que les deux lignes suivantes sont logiquement équivalentes.
  <example>
   <title>En utilisant <literal>|&gt;</literal></title>
   <programlisting role="php">
<![CDATA[
<?php
$result = "Hello World" |> strlen(...);
echo $result, PHP_EOL;

$result = strlen("Hello World");
echo $result, PHP_EOL;
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
11
11
]]>
   </screen>
  </example>
 </para>
 <para>
  Pour un seul appel, cette fonction n'est pas particulièrement utile. Elle devient utile lorsque plusieurs appels sont enchaînés.
  Autrement dit, les deux fragments de code suivants sont logiquement équivalents :
  <example>
   <title>Enchaînement |&gt; calls</title>
   <programlisting role="php">
<![CDATA[
<?php
$result = "PHP Rocks"
    |> htmlentities(...)
    |> str_split(...)
    |> (fn($x) => array_map(strtoupper(...), $x))
    |> (fn($x) => array_filter($x, fn($v) => $v != 'O'))
;
echo $result, PHP_EOL;

$temp = "PHP Rocks";
$temp = htmlentities($temp);
$temp = str_split($temp);
$temp = array_map(strtoupper(...), $temp);
$temp = array_filter($temp, fn($v) => $v != 'O');
$result = $temp;
echo $result, PHP_EOL;
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => P
    [1] => H
    [2] => P
    [3] =>
    [4] => R
    [6] => C
    [7] => K
    [8] => S
)
Array
(
    [0] => P
    [1] => H
    [2] => P
    [3] =>
    [4] => R
    [6] => C
    [7] => K
    [8] => S
)
]]>
   </screen>
  </example>
 </para>
 <para>
  La partie gauche de l'opérateur de pipeline peut être n'importe quelle valeur ou expression. La partie droite
  peut être n'importe quelle fonction PHP valide acceptant un seul paramètre, ou toute expression
  qui s'évalue à une telle fonction. Les fonctions avec plus d'un paramètre obligatoire
  ne sont pas autorisées et échoueront comme si la fonction était appelée normalement
  avec des arguments insuffisants. Les fonctions qui prennent une variable par référence ne sont pas autorisées.
  Si la partie droite ne s'évalue pas à une fonction valide, une erreur sera générée.
 </para>
 <note>
  <para>
   Sachez que, pour éviter toute ambiguïté syntaxique, <link linkend="functions.arrow">arrow functions</link>
   L'expression DOIT être placée entre parenthèses lorsqu'elle est utilisée avec un opérateur de pipeline, comme dans les exemples ci-dessus.
   Ne pas le faire entraînera une erreur fatale.
  </para>
 </note>

 <sect2 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><classname>Closure</classname></member>
   </simplelist>
  </para>
 </sect2>
</sect1>
