<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.34 $ -->
  <chapter id="language.types">
	<title>Les types</title>
  <sect1 id="language.types.intro">
  <title>Introduction</title>
   <simpara>
    &php; supporte les huit types basiques suivants :
   </simpara>
   <para>
    &php; supporte quatre types scalaires :
    <itemizedlist>
     <listitem>
      <simpara>
       <link linkend="language.types.boolean">bool»en</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.integer">entier</link>
      </simpara>
     </listitem>
     <listitem>
       <simpara>
       <link linkend="language.types.float">nombre ‡ virgule
       flottante</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string">chaÓne de
       caractÀres</link>
      </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   &php; supporte deux types compos»s :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">tableau</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objet</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   &php; supporte deux types sp»ciaux :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.resource">ressource</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.null">null</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <note>
   <simpara>
    Dans ce manuel, vous rencontrerez souvent le type <literal>mixed</literal>.
    C'est un pseudo-type, qui indique que le paramÀtre peut
    indiff»remment prendre plusieurs types.
   </simpara>

  </note>
  <simpara>
   Habituellement, le type d'une variable n'est pas d»clar»
   par le programmeur. Il est d»cid» au moment de
   l'ex»cution par le &php;, en fonction du contexte dans
   lequel la variable est utilis»e.
  </simpara>
  <note>
   <simpara>
    Si vous voulez v»rifier le type et la valeur d'une variable
    ou d'une <link linkend="language.expressions">expression</link>, utilisez
    la fonction <function>var_dump</function>.
   </simpara>
   <para>
    Si vous souhaitez simplement une repr»sentation lisible pour du d»bogage,
    utilisez la fonction <function>gettype</function>. Pour v»rifier la pr»sence
    de certains types, <emphasis>n'utilisez pas</emphasis> <function>gettype</function>, 
    mais plutÙt les fonctions <literal>is_<replaceable>type</replaceable></literal>. 
    Par exemple : 
    <example>
    <title>Exemples de v»rification de type de variable</title>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // un bool»en
$str  = "foo";  // une chaÓne de caractÀres
$int  = 12;     // un entier

echo gettype($bool); // affiche "boolean"
echo gettype($str);  // affiche "string"

// Ceci est un engier, on l'incr»mente de 4
if (is_int($int)) {
    $int += 4;
}

// Si $bool est une chaÓne, l'afficher
// (Ne pas imprimer n'importe quoi).
if (is_string($bool)) {
    echo "Chaine : $bool";
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
  <simpara>
   Si vous voulez forcer une variable ‡ Ítre convertie
   en un certain type, vous devez transtyper
   (<link linkend="language.types.typecasting">cast</link>) la
   variable ou utiliser la fonction <function>settype</function>.
  </simpara>
  <simpara>
   Il est ‡ noter qu'une variable peut se comporter de
   maniÀre diff»rente suivant les situations, en
   fonction du type qui lui est affect».
   Pour plus d'informations, voir le paragraphe
   <link linkend="language.types.type-juggling">transtypage</link>.
  </simpara>
 </sect1>
   <sect1 id="language.types.boolean">
    <title>Bool»ens</title>
    <simpara>
     C'est le type le plus simple. Un bool»en exprime les valeurs
      de &true; ou &false;.
    </simpara>
    <sect2 id="language.types.boolean.syntax">
     <title>Syntaxe</title>
     <para>
     Vous pouvez utiliser les constantes '&true;' et
     '&false;' pour sp»cifier une valeur de type
      <type>bool</type>. Ces constantes sont insensibles
      ‡ la casse.
      <example>
       <title>Utilisation des constantes &true; et &false;</title>
       <programlisting role="php">
<![CDATA[
<?php
  $foo = True; 
  // assigne la valeur TRUE ‡ la variable $foo
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      G»n»ralement, vous les cr»erez
      avec un des <link linkend="language.operators">op»rateurs</link>
      qui retourne une valeur <type>bool</type>, pour le passer
      ‡ une <link linkend="control-structures">structure de contrÙle</link>.
      <example>
       <title>Utilisation des constantes &true; et &false; avec une structure de contrÙle</title>
       <programlisting role="php">
<![CDATA[
// == est un op»rateur d'»galit»
// qui retourne un bool»en
if ($action == "show_version") {
    echo "La version est la 1.23";
}

// Ceci n'est pas n»cessaire
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// car vous pouvez simplement utiliser
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </example>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Conversion en bool»en</title>
      <simpara>
       Reportez-vous au chapitre
       "<link linkend="language.types.type-juggling">D»finition du type</link>"
       pour plus d'informations sur les conversions.
      </simpara>
      <para>
       Lors des conversions de valeurs de type <type>bool</type>, les valeurs
       suivantes sont consid»r»es comme fausse (&false;) :
       <itemizedlist>
        <listitem>
         <simpara>
          Le <link linkend="language.types.boolean">bool»en</link> &false;
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          L'<link linkend="language.types.integer">entier</link> 0 (z»ro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.float">nombre ‡ virgule flottante</link> 0.0 (z»ro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La <link linkend="language.types.string">chaÓne</link> vide,
          et la <link linkend="language.types.string">chaÓne</link> "0"
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.array">tableau</link> vide
          (aucun »l»ment)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
         L'<link linkend="language.types.object">objet</link> vide
         (aucun »l»ment)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La constante sp»ciale <link linkend="language.types.null">&null;</link>
         </simpara>
        </listitem>
       </itemizedlist>
       Toutes les autres valeurs sont consid»r»es comme
       vraies (&true; (y compris les
       <link linkend="language.types.resource">ressources</link>).
       <warning>
        <simpara>
         <literal>-1</literal> est consid»r» comme vrai!
        </simpara>
       </warning>
       <example>
        <title>Conversion en bool»en</title>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </example>
      </para>
    </sect2>
  </sect1>
  <sect1 id="language.types.integer">
   <title>Entiers</title>
   <para>
    Un entier est un nombre de l'ensemble des entiers naturels Z :
    <literal>Z = {...., -2, -1, 0, 1, 2, ...}</literal>. Il est possible de sp»cifier
    les nombres entiers (<literal>integer</literal>) de toutes les maniÀres suivantes :
    d»cimale (base 10), hexad»cimale (base 16), octale (base 8)
    »ventuellement pr»c»d» du signe moins
    (<literal>-</literal>).
   </para>
    <sect2 id="language.types.integer.syntax">
     <title>Syntaxe</title>
     <simpara>
      Les entiers peuvent Ítre sp»cifi»s en base d»cimale (dite aussi
      base 10), en hexad»cimale (base 16) ou octale (base 8).
      Les entiers peuvent Ítre optionnellement pr»c»d»s par le signe
      plus ou moins (- or +).
     </simpara>
     <para>
    Pour utiliser la notation octale, vous devez pr»fixer le nombre avec
    un z»ro; pour utiliser la notation hexad»cimale, vous devez
    pr»fixer le nombre avec <literal>0x</literal>.
      <example>
       <title>Notations entiÀres</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; // nombre entier en base 10
$a = -123; // nombre entier n»gatif
$a = 0123; // nombre entier en base 8, octale (»quivalent ‡ 83 en base 10)
$a = 0x1A; // nombre entier en base 16, hexad»cimale
           // (»quivalent ‡ 26 en base 10)
]]>
       </programlisting>
      </example>
     Techniquement, la structure d'un entier suit les rÀgles suivantes :
      <example>
      <title>Structure d'un entier</title>
       <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
       </programlisting>
      </example> 
      La taille des entiers d»pend de la plate-forme de support, mais
    la valeur maximale est g»n»ralement de 2 milliards et des
    poussiÀres (c'est un entier sign» de 32 bits). &php; ne supporte
    pas les entiers non sign»s.
     </para>
    </sect2>

    <sect2 id="language.types.integer.overflow">
     <title>D»passement de capacit» des entiers</title>
     <para>
      Si un nombre est hors de l'intervalle de validit»
      des entiers, il sera interprÀt» comme un <type>float</type>.
      <example>
      <title>D»passement de capacit» des entiers</title>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// affiche : int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// affiche : float(2147483648)

// this goes also for hexadecimal specified integers:
var_dump( 0x80000000 );
// affiche : float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// affiche : float(50000000000)
?>
]]>
       </programlisting>
      </example>
      De mÍme, si une fonction ou un op»rateur retourne un entier qui
      est hors des limites de validit» des entiers, il sera aussi
      automatiquement converti en <type>float</type>.
     </para>
     <para>
      En &php;, il n'y a pas de division entiÀre. <literal>1/2</literal> 
      sera un nombre ‡ virgule flottante (<type>float</type>)
      de valeur <literal>0.5</literal>. 
      <!-- See ??? for more information. (with the
      operators, or with type-jug) -->
     </para>
      <warning>
       <simpara>
        Malheureusement, il y a un bug dans le moteur (corrig» en 4.1.0), 
        qui fait que &php; ne fonctionne pas toujours bien lorsque des nombres 
        n»gatifs sont utilis»s. Lorsque les deux op»randes 
        sont positifs, il n'y a pas de problÀmes. Par exemple :
        <literal>-50000 * $million</literal>, conduit ‡
        <literal>-429496728</literal>.
       </simpara>
      </warning>
     <para>
      Il n'existe pas de division entiÀre en &php;.
      <literal>1/2</literal> g»n»rera le <type>float</type>
      <literal>0.5</literal>. Vous pouvez forcer la valeur
      au format entier pour faire l'arrondi, ou bien utiliser
      les fonctions <function>round</function>,
      <function>floor</function> ou <function>ceil</function>.
      <example>
       <title>Divisions entiÀres</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         
  // float(3.5714285714286) 
var_dump((int) (25/7)); 
  // int(3)
var_dump(round(25/7));  
  // float(4) 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect2>
    <sect2 id="language.types.integer.casting">
     <title>Conversion en entiers</title>
      <simpara>
       Pour explicitement convertir une valeur en &integer;,
       utilisez les op»rateurs de transtypage <literal>(int)</literal>
       ou <literal>(integer)</literal>. Cependant, dans la plupart des
       situations, vous n'en aurez pas besoin, car une valeur sera
       automatiquement convertie si un op»rateur, une fonction ou tout
       autre »l»ment du langage requiert un <type>entier</type>.
      </simpara>
      <simpara>
       Reportez-vous ‡ la section
       <link linkend="language.types.type-juggling">d»finition de
       type</link> pour plus d'informations sur les conversions.
      </simpara>
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>
        Depuis un <link 
        linkend="language.types.boolean">bool»en</link>
       </title>
       <simpara>
        <link linkend="language.types.boolean">&false;</link> devient 0
        (z»ro), et <link linkend="language.types.boolean">&true;</link>
        devient 1 (un).
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-float">
       <title>
        Depuis un <link linkend="language.types.float">nombre ‡ virgule
        flottante</link>
       </title>
       <simpara>
        Lors de conversion entre un nombre ‡ virgule flottante et
        un entier, le nombre sera arrondi ‡ la valeur inf»rieure
        s'il est positif, et sup»rieure s'il est n»gatif
        (conversion dite 'vers z»ro').
       </simpara>
       <para>
        Si le nombre est hors de l'intervalle de validit»
        des entiers, (g»n»ralement 
        <literal>+/- 2.15e+9 = 2^31</literal>),
        le r»sultat est ind»fini, car les nombres ‡
        virgule flottante n'ont pas assez de pr»cision pour fournir une
        valeur exacte pour un entier.
        <warning>
         <simpara>
          Aucune alerte, mÍme pas le plus petit message ne
          sera affich» dans ce cas.
         </simpara>
        </warning>
       </para>
       <warning>
        <para>
         Ne transformez jamais une fraction inconnue en entier, car cela
         peut conduire ‡ des r»sultats irrationnels.
      <example>
       <title>Attention aux erreurs de fractions</title>
          <programlisting role="php">
<![CDATA[
<?php
  echo (int) ( (0.1+0.7) * 10 );
// affiche 7!
?>
]]>
         </programlisting>
        </example>
        Pour plus d'informations, reportez-vous aux
        <link linkend="warn.float-precision">alertes</link> li»es
        aux nombres ‡ virgule flottante.
       </para>
      </warning>
      </sect3>
      <sect3 id="language.types.integer.casting.from-string">
       <title>A partir de chaÓnes de caractÀres</title>
       <simpara>
        Reportez-vous ‡ la section des
        <link linkend="language.types.string.conversion">conversions de 
        chaÓnes</link>.
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-other">
       <title>Conversion d'autres types</title>
       <para>
        La conversion d'autres types en entier est ind»finie.
        Actuellement, &php; convertit d'abord la valeur en
        <link linkend="language.types.boolean.casting">bool»en</link>.
        <caution>
         <simpara>
          Mais, ne vous fiez pas ‡ ce comportement, car il
          est susceptible de changer sans pr»avis!
         </simpara>
        </caution>
       </para>
    <para>
     Voir aussi :
     <link linkend="ref.gmp">Nombres de grande taille</link> et
     <link linkend="language.types.float">Nombres ‡ virgules flottantes</link>.
    </para>
       <!--
        IMO, it would more sense as (int) $arr returned the
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and
        (bool)(int) $arr will still behave the same.
        -->
    </sect3>
   </sect2>
  </sect1>
  <sect1 id="language.types.float">
   <title>Les nombres ‡ virgule flottante</title>
   <para>
    Les nombres ‡ virgule flottante (connus aussi sous le
    vocable de "<literal>double</literal>" ou "<literal>float</literal>"
    "<literal>nombre r»»ls</literal>") peuvent Ítre
    sp»cifi»s en utilisant la syntaxe suivante :
      <example>
       <title>Exemple de nombres ‡ virgule flottante</title>
     <programlisting role="php">
<![CDATA[
<?php
  $a = 1.234;
  $a = 1.2e3;
?>
]]>
     </programlisting>
    </example>
   </para>
   <warning id="warn.float-precision">
    <title>Pr»cision des nombres ‡ virgule flottante</title>
    <para>
     Il est fr»quent que de simples fractions d»cimales telles que
     <literal>0.1</literal> ou <literal>0.7</literal> ne puissent
     Ítre converties au format interne binaire sans une l»gÀre perte
     de pr»cision. Cela peut conduire ‡ des r»sultats »tonnants :
     par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera
     <literal>7</literal> au lieu de <literal>8</literal>
     car le r»sultat de la repr»sentation interne est
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Tout ceci est li» au fait qu'il est impossible d'exprimer
     certaines fractions en un nombre fini de chiffres. Par exemple
     <literal>1/3</literal> s'»crira <literal>0.3333333...</literal>
     en mode d»cimal.
    </para>
    <para>
     Ne faites donc jamais confiance aux nombres ‡ virgule
     jusqu'‡ leur derniÀre d»cimale, et ne comparez
     jamais ces nombres avec l'op»rateur d'»galit».
     Si vous avez besoin d'une pr»cision particuliÀre,
     reportez-vous au traitement des nombres de grande taille avec les
     librairies <link linkend="ref.bc">BC</link> ou <link linkend="ref.gmp">GMP</link>.
    </para>
   </warning>
   <sect2 id="language.types.float.casting">
    <title>Conversion d'un nombre ‡ virgule flottante</title>
    
    <para>
     Pour savoir quand et comment des chaÓnes sont converties en
     nombre ‡ virgule flottante, voyez la section 
     <link linkend="language.types.string.conversion">Conversion de chaÓnes de caractÀres</link>. 
     Pour les valeurs d'autres types, la conversion est la mÍme
     que si la valeur »tait d'abord convertie en entier, puis en 
     nombre d»cimal. Voyez la section <link linkend="language.types.integer.casting">Conversion d'un entier</link>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.string">
   <title>Les chaÓnes de caractÀres</title>
   <para>
    Les chaÓnes de caractÀres sont des s»quences de caractÀres.
    En &php;, un caractÀre est un octet, et il y en 256 de possibles.
    &php; n'a pas (encore?) de support natif d'Unicode.
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     La taille n'est pas un problÀme majeur pour une chaÓne.
     Elle peut devenir trÀs grande sans problÀme. Il n'y a
     pas ‡ s'en faire pour cela.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Syntaxe</title>
    <para>
     Une chaÓne peut Ítre sp»cifi»e de trois maniÀres
     diff»rentes :
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">guillemets simples</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">guillemets doubles</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">syntaxe <literal>HereDoc</literal></link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Guillemets simples</title>
     <para>
      Le moyen le plus simple de sp»cifier une chaÓne de caractÀres
      est d'utiliser les guillemets simples : <literal>'</literal>.
     </para>
     <para>
      Pour sp»cifier un guillemet simple litt»ral, vous devez
      l'»chapper avec un anti-slash (<literal>\</literal>), comme dans de nombreux
      langages. Si un anti-slash doit apparaÓtre dans votre chaÓne ou bien
      en fin de chaÓne, il faudra le doubler. Notez que si vous essayez d'»chapper n'importe
      quel autre caractÀre, l'anti-slash sera conserv»! Il n'y a pas
      besoin d'»chapper d'autres caractÀres que le guillemet lui-mÍme.
      <note>
       <simpara>
        En &php; 3, une alerte sera affich»e si cela arrive avec un
        niveau de rapport d'erreur de <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        Contrairement aux autres syntaxes, les variables pr»sentes dans la
        chaÓne ne seront <emphasis>PAS</emphasis> remplac»es par leurs
        valeurs.
       </simpara>
      </note>
      <example>
       <title>Exemples d'interpolation des chaÓnes de caractÀres</title>
       <programlisting role="php">
<![CDATA[
<?php
  echo 'Ceci est une chaÓne simple';
  echo 'Vous pouvez inclure des nouvelles lignes dans une chaÓne,
  comme ceci.';
  echo 'Arnold a coutume de dire : "I\'ll be back"';
// affiche : ... "I'll be back"
  echo 'Etes vous s˚r de vouloir effacer le dossier C:\\*.*?';
// affiche : Etes vous s˚r de vouloir effacer le dossier C:\*.*?
  echo 'Etes vous s˚r de vouloir effacer le dossier C:\*.*?';
// affiche : Etes vous s˚r de vouloir effacer le dossier C:\*.*?
  echo 'Je suis en train de mettre une nouvelle ligne comme ceci : \n';
// affiche : Je suis en train de mettre une nouvelle ligne comme ceci : \n
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Guillemets doubles</title>
     <para>
      Si la chaÓne est entour»e de guillemets doubles, &php;
      va comprendre certaines s»quences de caractÀres :
     </para>
    <table>
     <title>Les caractÀres sp»ciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>S»quence</entry>
        <entry>Valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (linefeed, LF ou 0x0A (10) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour ‡ la ligne (<literal>carriage return</literal>, CR ou 0x0D (13) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale (HT ou 0x09 (9) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Anti-slash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>CaractÀre $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemets doubles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
          Une s»quence de caractÀres qui permet de
          rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
          Une s»quence de caractÀres qui permet de
          rechercher un nombre en notation hexad»cimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Si vous essayez d'utiliser l'anti-slash sur n'importe quelle
    autre s»quence, l'anti-slash sera affich» dans votre chaÓne.
   </para>
    <para>
     Le plus important pour les chaÓnes ‡ guillemets doubles est le fait
     que les variables qui s'y trouvent seront remplac»es par leur valeur. 
     Voir la section sur le <link linkend="language.types.string.parsing">traitement des
     variables dans les chaÓnes</link> pour plus de d»tails.
    </para>
   </sect3>
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Syntaxe <literal>Heredoc</literal></title>
   <para>
    Un autre moyen de d»limiter les chaÓnes est d'utiliser
    la syntaxe dite "<literal>Heredoc</literal>" 
    (en franÁais, documentation ici): &lt;&lt;&lt;,
    suivi d'un identifiant arbitraire, puis de la chaÓne. Cette
    s»quence se termine par l'identifiant initial, plac» en
    premier sur une nouvelle ligne.
   </para>
   <para>
    L'identifiant utilis» doit suivre
    les mÍmes rÀgles que les »tiquettes &php; : il ne
    doit contenir uniquement que des caractÀres alpha-num»riques,
    et des soulign»s ("_"), et enfin, commencer par un
    caractÀre alphab»tique ou un soulign».
   </para>
     <warning>
      <simpara>
       Il est trÀs important de noter que la ligne qui contient
       l'identifiant de fermeture ne doit contenir aucun autre
       caractÀre, hormis, »ventuellement, un point-virgule <literal>;</literal>.
       Cela signifie notamment que l'identifiant ne doit
       pas Ítre indent», et qu'il n'y a aucun caractÀre
       blanc entre le retour ‡ la ligne et l'identifiant,
       ou bien entre l'identifiant et le <literal>;</literal>.
      </simpara>
      <simpara>
       Le plus dur est peut Ítre qu'il ne faut pas qu'il y ait
       un retour ‡ la ligne ((<literal>\r</literal>) ‡ la fin de cette
       ligne, mais seulement un retour chariot (<literal>\n</literal>).
       Puisque Microsoft Windows utilise la s»quence
       <literal>\r\n</literal> comme terminaison de ligne,
       la syntaxe <literal>heredoc</literal> risque de ne pas fonctionner l‡. Cependant,
       la plupart des »diteurs &php; fournissent une sauvegarde
       au format UNIX.
       <!--
       FTP will sometimes automatically convert \r\n to \n while
       transferring your files to your webserver (which
       is *nix, of course)
       -->
      </simpara>
     </warning>
   <para>
    La syntaxe <literal>Heredoc</literal> se comporte exactement comme une chaÓne ‡
    guillemets doubles, sans les guillemets doubles. Cela signifie
    que vous n'avez pas ‡ »chapper les guillemets (simples ou doubles)
    dans cette syntaxe. Les variables sont remplac»es par leur valeur, et
    le mÍme soin doit leur Ítre apport» que dans les chaÓnes
    ‡ guillemets doubles.
    <example>
     <title>Exemple de chaÓne <literal>HereDoc</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
  $str = <<<EOD
  Exemple de chaÓne
  s'»talant sur
  plusieurs lignes
  avec la syntaxe heredoc
EOD;
/* Exemple plus complexe, avec des variables. */
  class foo {
    var $foo;
    var $bar;
    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
  }
  $foo = new foo();
  $name = 'MonNom';
  echo <<<EOT
  Mon nom est "$name". J'affiche des $foo->foo.
  Maintenant, j'affiche un {$foo->bar[1]}.
  Ceci se traduit par un 'A' majuscule: \x41
EOT;
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le support <literal>Here doc</literal> a »t» ajout» en &php; 4.
    </para>
   </note>
   </sect3>
   <sect3 id="language.types.string.parsing">
     <title>Traitement des variables dans les chaÓnes</title>
     <!-- Section originale par jeroen@a-es2.uu.nl -->
     <simpara>
      Lorsqu'une chaÓne est sp»cifi»e avec des guillemets doubles,
      ou en utilisant la syntaxe <literal>heredoc</literal>,
      les variables qu'elle contient sont remplac»es par leur valeur.
     </simpara>
     <simpara>
      Il y a deux types de syntaxe, une
      <link linkend="language.types.string.parsing.simple">simple</link>
      et une
      <link linkend="language.types.string.parsing.complex">complexe</link>.
      La syntaxe simple est la plus courante, et la plus pratique : elle fournit
      un moyen d'utiliser les variables, que ce soient des chaÓnes, des tableaux
      ou des membres d'objets.
     </simpara>
     <simpara>
      La syntaxe complexe a »t» introduite en &php; 4
      <!-- XXX was it? and starting with what version exactly? -->
      et peut Ítre reconnue gr‚ce aux accolades entourant les expressions.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Syntaxe simple</title>
      <simpara>
       DÀs qu'un signe dollar <literal>$</literal> est rencontr», l'analyseur
       &php; va lire autant de caractÀre qu'il peut pour former un nom de
       variable valide. Entourez le nom de la variable avec des accolades
       pour indiquer explicitement son nom.
      </simpara>
      <example>
      <title>Utilisation des accolades <literal>{}</literal> dans les chaÓnes</title>
       <programlisting role="php">
 <![CDATA[
<?php
  $boisson = 'vin';
  echo "Du $boisson, du pain et du fromage!";
 // OK, car "," n'est pas autoris» dans les noms de variables
  echo "Il a go˚t» plusieurs $boissons";
 // Pas OK, car 's' peut faire partie d'un nom de variable, et PHP recherchera alors $boissons
  echo "Il a go˚t» plusieurs ${boisson}s";
 // OK
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Similairement, vous pouvez aussi utiliser un »l»ment
       de tableau, ou un membre d'objet. Pour les »l»ments
       de tableau, le crochet fermant '<literal>]</literal>'
       marquera la fin du nom de la variable. Pour les
       membres d'objets, les mÍmes rÀgles que ci-dessus
       s'appliquent. Cependant, il n'existe pas de truc comme
       pour les variables simples.
       <!-- XXX isn't TRUE :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      </simpara>
      <example>
      <title>Utilisation des accolades <literal>{}</literal> dans les chaÓnes pour les tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ces exemples sont sp»cifiques ‡ l'utilisation de tableaux dans une chaÓne.
// Lorsque vous Ítes hors d'une chaÓne, utilisez toujours des guillemets
// autour des index de tableau, et n'utilisez pas d'{accolades}.

// Affichons toutes les erreurs
error_reporting(E_ALL);

$fruits = array('fraise' => 'rouge', 'banane' => 'jaune');

// Fonctionne mais notez que cela fonctionne pas comme 
// si cela »tait hors d'une chaÓne
echo "Une banane est $fruits[banane].";

// Fonctionne
echo "Une banane est {$fruits['banane']}.";

// Fonctionne mais PHP cherche une constante appel»e banane
// tel que d»crit ci-dessous
echo "Une banane est {$fruits[banane]}.";

// Ne fonctionne pas, il manque les accolades. Cela donne une erreur d'analyse
echo "Une banane est  $fruits['banane'].";

// Fonctionne
echo "Une banane est " . $fruits['banane'] . ".";

// Fonctionne
echo "Ce carr» a un cot» de $square->width mÀtres de large.";

// Ne fonctionne pas. Pour une solution, voyez la syntaxe complexe.
echo "Ce carr» a un cot» de $square->width00 centimÀtres.";
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Pour tout ce qui sera plus compliqu», voyez la syntaxe complexe.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Syntaxe complexe</title>
      <simpara>
       La syntaxe est dite "complexe" car elle permet l'utilisation d'
       expressions complexes, et non pas parcequ'elle serait obscure.
       Nuance.
     </simpara>
     <simpara>
      En fait, vous pouvez inclure n'importe quelle valeur qui est
      dans l'espace de nom avec cette syntaxe. Il suffit d'»crire une
      expression exactement comme si elle »tait hors de la chaÓne,
      puis de l'entourer d'accolades <literal>{}</literal>. Puisque
      vous ne pouvez pas »chapper les accolades, cette syntaxe ne commence
      qu'‡ partir du signe dollar, qui suit imm»diatement l'accolade
      ouvrante. Par exemple, vous pouvez utiliser <literal>"{\$"</literal>
      pour obtenir un <literal>"{$"</literal> litt»ral. Voici quelques
      exemples :
     </simpara>
     <example>
     <title>Syntaxe complexe de chaÓne</title>
      <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$super = 'fantastique';

// Ne fonctionne pas. Affiche : Ceci est { fantastique}
echo "Ceci est { $super}";

// Fonctionne. Affiche Ceci est fantastique
echo "This is {$super}";
echo "This is ${super}";

// Fonctionne
echo "Ce carr» a un cot» de {$square->width}00 centimÀtres."; 

// Fonctionne
echo "Ceci fonctionne : {$arr[4][3]}";

// Ceci est faut pour la mÍme raison que $foo[bar] est faux
// hors d'une chaÓne. En d'autres terme, cela va fonctionne
// car PHP recherche d'abord une constante appel»e foo, mais
// il g»n»rera une note E_NOTICE (undefined constant).
echo "Ceci est faux : {$arr[foo][3]}"; 

// Fonctionne. Lorsque vous utilisez un tableau multidimensionnel dans
// une chaÓne, n'oubliez jamais les accolades.
echo "Ceci fonctionne : {$arr['foo'][3]}";

// Fonctionne
echo "Ceci fonctionne : " . $arr['foo'][3];

echo "Vous pouvez mÍme »crire {$obj->values[3]->name}";

echo "Ceci est une valeur de variable variable : {${$name}}";
?>
]]>
       </programlisting>
      </example>
     </sect4>
    </sect3>
    <sect3 id="language.types.string.substr">
     <title>AccÀs et modification des caractÀres d'une chaÓne</title>
     <para>
      Les caractÀres d'une chaÓne sont accessibles et modifiables en sp»cifiant
      leur offset (le premier caractÀre est d'offset 0) entre
      accolade, aprÀs le nom de la variable.
     </para>
     <note>
      <simpara>
       Pour assurer la compatibilit» ascendante, vous pouvez
       toujours acc»der aux caractÀres avec des crochets.
       Mais cette syntaxe est obsolÀte en &php; 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Exemples de chaÓnes</title>
       <programlisting role="php">
<![CDATA[
<?php
// Lit le premier caractÀre de la chaÓne
$str = 'Ceci est un test.';
$first = $str{0};

// Lit le troisiÀme caractÀre de la chaÓne
$third = $str{2};

// Lit le dernier caractÀre de la chaÓne
$str = 'Ceci est un test.';
$last = $str{strlen($str)-1}; 

// Modifie le dernier caractÀre de la chaÓne
$str = 'Ceci est un test.';
$str{strlen($str)-1} = '!';

?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.string.useful-funcs">
    <title>Fonctions et op»rateurs pratiques</title><!-- and operators -->
    <para>
     Les chaÓnes peuvent Ítre concat»n»es avec l'op»rateur '.' (point).
     Notez que l'op»rateur d'addition '+' (plus) ne fonctionnera pas.
     Reportez-vous ‡ la section
     <link linkend="language.operators.string">op»rateurs de chaÓnes</link>.
    </para>
    <para>
     Il y a une grande quantit» de fonctions pratiques pour modifier
     les chaÓnes.
    </para>
    <simpara>
     Reportez-vous ‡ la section <link linkend="ref.strings">chaÓnes de caractÀres</link>
     pour les fonctions les plus g»n»rales, ‡ <link linkend="ref.pcre">Expressions
     r»guliÀres Perl</link> et <link linkend="ref.regex">Expressions r»guliÀres
     POSIX »tendues</link> pour les recherches et remplacements.
    </simpara>
    <simpara>
     Il y a aussi les fonctions sur les <link linkend="ref.url">URL</link>,
     ainsi que des fonctions de chiffrage (<link linkend="ref.mcrypt">mcrypt</link> et
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalement, si vous ne trouvez toujours pas votre bonheur, il y a les
     fonctions de <link linkend="ref.ctype">types de caractÀres</link>.
    </simpara>
   </sect2>
   <sect2 id="language.types.string.casting">
    <title>Conversion en une chaÓne de caractÀres</title>
    
    <para>
     Vous pouvez convertir une valeur en une chaÓne de caractÀres en utilisant l'op»rateur
     <literal>(string)</literal>, ou bien la fonction <function>strval</function>.
     La conversion en chaÓne de caractÀres est automatiquement faite dans
     toutes les situations qui n»cessitent une chaÓne de caractÀres.
     Cela arrive lorsque vous utilisez des fonctions comme <function>echo</function>
     ou <function>print</function>, ou encore lorsque vous comparez une valeur
     avec une chaÓne de caractÀres.
    </para>
    
    <para>
     Le bool»en &true; est converti en la chaÓne de caractÀres <literal>"1"</literal>,
     et le bool»en &false; est repr»sent» par la chaÓne de caractÀres vide 
     <literal>""</literal>. De cette faÁon, vous pouvez convertir des 
     bool»ens en chaÓne de caractÀres et vice-versa.
    </para>
    <para> 
     Un entier ou un nombre ‡ virgule flottante est converti en une
     chaÓne de caractÀres qui repr»sente ce nombre en d»cimal (y compris
     l'exposant des nombres ‡ virgule flottante).
    </para>
    <para>
     Les tableaux sont toujours convertis en la chaÓne de caractÀres <literal>"Array"</literal>,
     ce qui fait que vous ne pouvez pas afficher le contenu d'un tableau avec la fonction
     <function>echo</function> ou <function>print</function>. Voyez 
     les informations ci-dessous pour plus de conseils.
    </para>
    <para>
     Les objets sont automatiquement convertis en la chaÓne de caractÀres 
     <literal>"Object"</literal>. Si vous souhaitez afficher le membre
     d'un objet, lisez le paragraphe ci-dessous. Si vous voulez connaÓtre
     le nom de la classe de cet objet, utilisez la fonction
     <function>get_class</function>.  
    </para>
    <para>
     Les ressources sont toujours converties en chaÓne de caractÀres 
     <literal>"Resource id #1"</literal> o˘ <literal>1</literal> est
     le nombre unique repr»sentant la ressource, assign» par &php; au moment
     de l'ex»cution. Si vous souhaitez connaÓtre le type d'une ressource,
     utilisez <function>get_resource_type</function>.
    </para>
    <para>
     &null; est toujours converti en une chaÓne de caractÀres vide.
    </para>
    
    <para>
     Comme vous pouvez le voir, afficher des tableaux, des objets ou des ressources
     n'est pas pertinent par cette m»thode. Reportez-vous aux fonctions
     <function>print_r</function> et <function>var_dump</function> pour
     avoir des outils plus pratiques.
    </para>
    
    <para>
     Vous pouvez aussi convertir des valeurs &php; en chaÓnes pour les
     sauver dans un stockage. Cette m»thode est appel»e la lin»arisation,
     et peut Ítre exploit»e avec la fonction <function>serialize</function>. 
     Vous pouvez aussi lin»ariser des valeurs &php; en structure 
     XML si vous avez le support <link linkend="ref.wddx">WDDX</link>.
    </para>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>Conversion de chaÓnes de caractÀres</title>
    <simpara>
      Lorsqu'une chaÓne de caractÀre est
      »valu»e comme une valeur num»rique,
      le r»sultat et le type de la variable sont
      d»termin»s comme suit.
    </simpara>
    <simpara>
      La chaÓne de caractÀres est de type "double" si
      elle contient un des caractÀres '.', 'e' ou 'E'. Sinon,
      elle est de type entier (<literal>"integer"</literal>).
    </simpara>
    <para>
      La valeur est d»finie par la premiÀre partie
      de la chaÓne. Si la chaÓne de caractÀres
      d»bute par une valeur num»rique cette valeur
      sera celle utilis»e. Sinon, la valeur sera »gale
      ‡ 0 (z»ro).
    </para>
    <simpara>
      Lorsque la premiÀre expression est une chaÓne de
      caractÀres, le type de la variable d»pend de la
      seconde expression.
    </simpara>
      <example>
       <title>Exemples de conversions automatiques</title>
     <programlisting role="php">
<![CDATA[
<?php
  $foo = 1 + "10.5";              // $foo est du type  float (11.5)
  $foo = 1 + "-1.3e3";            // $foo est du type  float (-1299)
  $foo = 1 + "bob-1.3e3";         // $foo est du type  integer (1)
  $foo = 1 + "bob3";              // $foo est du type  integer (1)
  $foo = 1 + "10 petits cochons";     // $foo est du type  integer (11)
  $foo = 1 + "10 gros cochons"; // $foo est du type  integer (11)
  $foo = "10.0 cochons " + 1;        // $foo est du type  integer (11)
  $foo = "10.0 cochons " + 1.0;      // $foo est du type  float (11)
?>
]]>
     </programlisting>
    </example>
    <simpara>
      Pour plus d'informations sur les conversions de type, voir les
      pages de man ‡ propos de la fonction <literal>strtod(3)</literal>.
    </simpara>
    <para>
     Si vous voulez tester l'un des exemples de cette section,
     vous pouvez faire un copier/coller et l'ins»rer dans un script
     pour voir comment il se comporte.
      <example>
       <title>Exemples de conversions</title>
      <programlisting role="php">
<![CDATA[
<?php
  echo "\$foo==$foo; type is " . gettype( $foo ) . "<br>\n";
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.array">
   <title>Les tableaux</title>
   <para>
    Un tableau &php; est en fait une association ordonn»e (litt»ralement,
    une <literal>map</literal>). Une
    association est un type qui fait correspondre des valeurs
    ‡ des <emphasis>cl»s</emphasis>.  Ce type est optimis»
    de diverses faÁons, qui font que vous pouvez le manipuler comme
    un tableau ‡ indices r»els, une liste (vecteur), ou un table
    de hachage (qui est une impl»mentation d'association),
    dictionnaire, collection, pile, queue et encore d'autres.
    Comme une valeur peut elle-mÍme Ítre un tableau, vous pouvez
    simuler facilement un arbre.
   </para>
    <para>
     Les d»tails d'impl»mentation de ces structures sont hors du
     champs de ce manuel, mais vous trouverez ici un exemple
     de toutes ces structures.
    </para>
   <sect2 id="language.types.array.syntax">
    <title>Syntaxe</title>
    <sect3 id="language.types.array.syntax.array-func">
     <title>Cr»er un tableau <function>array</function></title>
     <para>
      Un tableau <type>array</type> peut Ítre cr»» avec la fonction
      <function>array</function>. Cette fonction prend en argument
      des structures <literal><replaceable>key</replaceable> =>
      <replaceable>value</replaceable></literal>, s»par»es par des virgules.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> 
<replaceable>value</replaceable> , ... )
// <replaceable>key</replaceable> est soit une <type>string</type> 
soit un <type>integer</type> positif
// <replaceable>value</replaceable> peut Ítre n'importe quoi
      </synopsis>
     </para>
     <para>
      <example>
       <title>Affectations de tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Une cl» <varname>key</varname> est soit un entier
      ou bien une chaÓne.
      Si une cl» est la repr»sentation standard d'un entier positif,
      elle sera interprÀt»e comme tel. (i.e. <literal>'8'</literal> sera
      interprÀt» comme <literal>8</literal>, tandis que <literal>'08'</literal>
      sera interprÀt» comme <literal>'08'</literal>).
     </para>
     <para>
      Une valeur peut Ítre n'importe quoi.
      <example>
       <title>Cr»ation d'un tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
  array("untableau" => array(6 => 5, 13 => 9, "a" => 43));

echo $arr["untableau"][6];    // 5
echo $arr["untableau"][13];   // 9
echo $arr["untableau"]["a"];  // 43
  
?>
]]>
       </programlisting>
      </example>
     </para>
      <para>
       Si vous omettez une cl» lors de la sp»cification d'un tableau,
       l'indice maximum + 1 sera utilis» comme cl» par d»faut. Si aucun
       indice num»rique n'a »t» g»n»r», ce sera 0. 
       Si vous en sp»cifiez une qui a d»j‡ »t» assign»e,
       la nouvelle valeur »crasera la pr»c»dente.
      <example>
       <title>Indexation automatique de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ce tableau est identique ‡ 
array(5 => 43, 32, 56, "b" => 12);

// Celui ci
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </example>
      </para>
     <para>
      Utiliser &true; comme cl» revient ‡ utiliser le type
      <type>integer</type> de valeur <literal>1</literal>.
      Utiliser &false; comme cl» revient ‡ utiliser le type
      <type>integer</type> de valeur <literal>0</literal>.
      Utiliser &null; comme cl» revient ‡ utiliser le type
      <type>string</type> de valeur <literal>""</literal>.
      Utiliser la chaÓne vide comme index va cr»er cet index,
      et ce n'est pas la mÍme chose que d'utiliser des 
      crochets vides.
     </para>
     <para>
      Il n'est pas possible d'utiliser des tableaux ou des objets comme
      cl»s. Ce faisant, vous g»n»reriez une alerte : 
      <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    <sect3 id="language.types.array.syntax.modifying">
     <title>La syntaxe ‡ crochets</title>
     <para>
      Vous pouvez aussi modifier un tableau existant en lui assignant
      simplement des valeurs.
     </para>
     <para>
      L'assignation de valeurs de tableau se fait en sp»cifiant la cl»
      entre crochets. Si vous omettez la cl» ("<literal>$tableau[]</literal>"),
      la valeur sera ajout»e ‡ la fin du tableau.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> est soit une chaÓne, soit un entier
// <replaceable>value</replaceable> peut Ítre n'importe quoi
      </synopsis>
      Si <varname>$arr</varname> n'existe pas, il sera cr»». Cela
      en fait une alternative pour cr»er un tableau. Pour modifier une
      valeur, assignez-lui une nouvelle valeur. Pour supprimer une
      valeur, utilisez la fonction <function>unset</function>.
      <example>
       <title>Manipuler des »l»ments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Ceci revient ‡ $arr[13] = 56;
                // ‡ ce moment du script

$arr["x"] = 42; // Ceci ajoute un nouvel »l»ment
                // avec l'index "x"
                
unset($arr[5]); // Ceci efface un »l»ment du tableau

unset($arr);    // Ceci efface tout le tableau
?>
]]> 
       </programlisting>
      </example>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.array.useful-funcs">
    <title>Fonctions pratiques</title>
    <para>
     Il y a toute une panoplie de fonctions pratiques pour travailler
     avec <link linkend="ref.array">les tableaux</link>.
    </para>
    <note>
     <para>
      La fonction <function>unset</function> permet d'effacer des 
      index dans un tableau. Sachez bien que le tableau ne sera PAS
      r»index». Si vous utilisez uniquement des index num»riques
      (commenÁant ‡ z»ro, et incr»ment»s de un), vous pouvez effectuer
      la r»indexation en utilisant <function>array_values</function>.
      <example>
       <title>Manipuler des »l»ments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'un', 2 => 'deux', 3 => 'trois');
unset($a[2]);
/* Cela va produire un tableau qui aurait »t» 
   $a = array(1 => 'un', 3 => 'trois');
   et non pas
   $a = array(1 => 'un', 2 =>'trois');
*/

$b = array_values($a);
// Maintenant b est le tableau array(1 => 'un', 2 =>'trois')
?>
]]>
      </programlisting>
     </example>
     </para>    
    </note> 
    <para>
     L'»l»ment de langage <link linkend="control-structures.foreach">foreach</link>
     est sp»cifiquement d»di» aux tableaux : il permet de passer en
     revue simplement les valeurs d'un tableau.
    </para>
   </sect2>
   <sect2 id="language.types.array.donts">
    <title>A faire et ‡ ne pas faire avec les tableaux</title>
    <sect3 id="language.types.array.foo-bar">
     <title>Pourquoi est-ce que <literal>$foo[bar]</literal> est invalide?</title>
     <para>
      Dans vos vieux scripts, vous pouvez avoir utilis» la syntaxe suivante :
      <example>
       <title>AccÀs aux index de tableaux, ancienne m»thode</title>
       <programlisting role="php">
<![CDATA[
<?php
  $foo[bar] = 'ennemi';
  echo $foo[bar];
?>
]]>
       </programlisting>
      </example>
      Cela est mauvais, mais ca marche. Pourquoi est-ce mauvais? La raison
      est que &php; attend une constante entre crochets (bar) plutÙt qu'une chaÓne
      ('bar', notez les guillemets). Or, &php; pourrait d»finir dans le futur des
      constantes qui, malheureusement pour votre code, auront ce nom. Actuellement,
      cela fonctionne car la constante ind»finie est transform»e en chaÓne ayant la
      mÍme valeur.
     </para>
     <para>
      D'autres exemples : 
      <example>
      <title>Exemples de conflits de constantes ind»finies</title>
       <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$arr = array('fruit' => 'pomme', 'l»gume' => 'carotte');

// Correct
print $arr['fruit'];  // pomme
print $arr['l»gume']; // carotte

// Incorrect.  Cela fonctionne mais PHP affiche une alerte car
// il y a utilisation d'une constante ind»finie appel»e fruit
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // pomme

// D»finissons une constante pour illustrer le problÀme.
// Nous cr»ons une constante appel»e fruit, qui vaut 'l»gume'.
define('fruit','l»gume');

// Notez la diff»rence
print $arr['fruit'];  // pomme
print $arr[fruit];    // carotte

// La suite est correcte si cela se passe dans une chaÓne. 
// Les constantes ne sont pas remplac»es par leur valeur dans une chaÓne
print "Bonjour $arr[fruit]";      // Bonjour pomme

// A une exception, les accolades entourant un tableau dans une chaÓne
// permettent d'utiliser les constantes
print "Bonjour {$arr[fruit]}";    // Bonjour carotte
print "Bonjour {$arr['fruit']}";  // Bonjour pomme

// Ceci ne fonctionnera pas, et donnera une erreur d'analyse
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Cela s'applique aussi aux autoglobales dans les chaÓnes
print "Bonjour $arr['fruit']";
print "Bonjour $_GET['foo']";

// La concatenation est une alternative
print "Bonjour " . $arr['fruit']; // Bonjour pomme
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Lorsque vous activez l'<function>error_reporting</function> pour afficher
      les erreurs de niveau <constant>E_NOTICE</constant> (en utilisant
      le niveau <constant>E_ALL</constant>) alors, vous verrez ces erreurs.
      Par d»faut, <link linkend="ini.error-reporting"><option>error_reporting</option></link> 
      est trop faible pour les afficher.
     </para>
     <para>
      Comme indiqu» dans la section <link linkend="language.types.array.syntax">syntaxe</link>,
      il doit y avoir une expression entre les crochets 
      ('<literal>[</literal>' et '<literal>]</literal>').
      Cela signifie que vous pouvez »crire ceci : 
      <example>
       <title>Utilisation d'une expression dans un index de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </example>
      Ceci est un exemple d'utilisation de retour de fonction comme
      index de tableau. &php; reconnaÓt aussi les constantes, comme
      la famille des <literal>E_*</literal>.
      <example>
       <title>Utilisation d'une constante dans un index de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Une erreur fatale est survenue";
$error_descriptions[E_WARNING] = "PHP »met une alerte";
$error_descriptions[E_NOTICE]  = "Ceci est juste une alerte informationnelle";
?>
]]>
       </programlisting>
      </example>
      Notez que <constant>E_ERROR</constant> est aussi un identifiant valide,
      tout comme <literal>bar</literal> dans le premier exemple. Mais le dernier
      exemple est identique ‡ ceci : 
      <example>
       <title>Utilisation d'une constante dans un index de tableau(2)</title>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Une erreur fatale est survenue";
$error_descriptions[2] = "PHP »met une alerte";
$error_descriptions[8] = "Ceci est juste une alerte informationnelle";
?>
]]>
       </programlisting>
      </example>
      car <literal>E_ERROR</literal> vaut <literal>1</literal>, etc...
     </para>
     <para>
      Comme nous l'avons d»j‡ expliqu» dans les exemples ci-dessus,
      <literal>$foo[bar]</literal> fonctionne mais est dangereux.
      Cela fonctionne car <literal>bar</literal> est identifi» comme une
      constante. Mais, si la constante n'existe pas, &php; suppose
      que vous souhaitez utiliser <literal>bar</literal> litt»ralement,
      sous la forme <literal>"bar"</literal>, mais que vous avez oubli» les
      guillemets.
     </para>
     <sect4>
      <title>Pourquoi est-ce aussi dangereux?</title>
      <para>
       A l'avenir, le groupe &php; peut d»cider d'ajouter une constante ou
       un autre mot cl», ou bien vous souhaiterez aussi ajouter une
       constante dans votre application, et vous serez bloqu». Par exemple,
       vous ne pouvez pas utiliser des mots comme <literal>empty</literal> et 
       <literal>default</literal> de cette maniÀre, car il sont d»j‡ 
       <link linkend="reserved">r»serv»s</link>.
      </para>
      <note>
       <simpara>
        Pour insister, ‡ l'int»rieur d'une chaÓne de caractÀres 
	(<type>string</type>) ‡ guillemets doubles, il est correct de ne pas utiliser
	les guillemets simples dans les index, et <literal>"$foo[bar]"</literal> est valide.
	Voyez les exemples ci-dessus pour plus de d»tails sur la syntaxe des
        <link linkend="language.types.string.parsing">variables dans les chaÓnes</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>
   <sect2 id="language.types.array.casting">
    <title>Conversion en tableau</title>
    
    <para>
     Pour les types scalaires (<type>integer</type>, <type>float</type>, 
     <type>string</type>, <type>boolean</type> et <type>resource</type>),
     convertir une valeur en tableau retourne un tableau qui contient un
     »l»ment (‡ l'index 0) qui est la valeur originale.
    </para>
    
    <para>
     Si vous convertissez un tableau en objet, vous obtiendrez des propri»t»s
     ou bien cet objet comme »l»ments de tableau. Les cl»s cr»»es sont les
     noms des membres.
    </para>
    
    <para>
     Si vous convertissez la valeur &null; en tableau, vous obtiendrez un
     tableau vide.
    </para>
   </sect2>
   <sect2 id="language.types.array.examples">
    <title>Exemples</title>
    <para>
     Le type tableau de &php; est trÀs souple. Voici quelques exemples d'utilisation :
    </para>
    <para>
      <example>
       <title>Utilisation des tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
// ceci
  $a = array( 'couleur' => 'rouge'
            , 'gout' => 'sucre'
            , 'forme' => 'rond'
            , 'nom'  => 'pomme'
            ,            4        // cette cl» sera 0
          );
// est compl»tement »quivalent ‡
  $a['couleur'] = 'rouge';
  $a['gout'] =    'sucre';
  $a['forme'] =   'rond';
  $a['nom'] =     'pomme';
  $a[]        = 4;        // cette cl» sera 0
  $b[] = 'a';
  $b[] = 'b';
  $b[] = 'c';
// va cr»er le tableau array( 0 => 'a' , 1 => 'b' , 2 => 'c' )
// ou plus simplement array('a' , 'b' , 'c' )
?>
]]>
       </programlisting>
      </example>
     </para>
    <example>
     <title>Utilisation de <function>array</function></title>
     <programlisting role="php">
<![CDATA[
<?php
// Array comme correspondance
  $map = array( 'version'    => 4
              , 'OS'         => 'Linux'
              , 'langue'       => 'franÁais'
              , 'short_tags' => TRUE             );
// valeur strictement num»riques
  $array = array( 7
                , 8
                , 0
                , 156
                , -10
                );
// ceci est la mÍme chose que array( 0 => 7, 1 => 8, ...)
  $switching = array(         10 // cl» = 0
                    , 5    =>  6
                    , 3    =>  7
                    , 'a'  =>  4
                    ,         11 // cl» = 6 (index maximum : 5)
                    , '8'  =>  2 // cl» = 8 (entier!)
                    , '02' => 77 // cl» = '02'
                    , 0    => 12 // la valeur de la cl» 10 sera remplac»e par 12
                    );
// empty array
$empty = array();
?>
]]>
     </programlisting>
    </example>
    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
<?php
  $couleurs = array('rouge','bleu','vert','jaune');
  foreach ( $couleurs as $couleur ){
    echo "Aimez-vous la couleur $couleur?\n";
  }
/* Affiche :
Aimez-vous la couleur rouge?
Aimez-vous la couleur bleu?
Aimez-vous la couleur vert?
Aimez-vous la couleur jaune?
*/
?>
]]>
     </programlisting>
    </example>
    <para>
     Notez qu'il n'est pas possible actuellement de modifier les
     valeurs d'un tableau avec une telle boucle.
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &amp;$color )
       See bug#3074
      -->
     Une solution pour cela est :
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
<?php
  foreach( $couleurs as $cle => $couleur ){
// ne marche pas
//$couleur = strtoupper($couleur);
//marche :
    $couleurs[$cle] = strtoupper($couleur);
  }
  print_r($couleur);
/* Affiche :
Array
(
    [0] => ROUGE
    [1] => BLEU
    [2] => VERT
    [3] => JAUNE
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Cet exemple cr»e un tableau d'index minimal 1.
     <example>
      <title>Tableau en 1</title>
      <programlisting role="php">
<![CDATA[
<?php
  $firstquarter  = array(1 => 'Janvier', 'F»vrier', 'Mars');
  print_r($firstquarter);
/* Affiche:
Array
(
    [1] => 'Janvier'
    [2] => 'F»vrier'
    [3] => 'Mars'
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <example>
     <title>Remplissage d'un tableau</title>
     <programlisting role="php">
<![CDATA[
<?php
// remplit un tableau avec les noms de fichiers d'un dossier
  $handle = opendir('.');
  while ( $file = readdir($handle) ){
    $files[] = $file;
  }
  closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     Les tableaux sont ordonn»s. Vous pouvez modifier l'ordre des
     valeurs avec de nombreuses fonctions de classement. Voyez les
     fonctions de <link linkend="ref.array">tableaux</link>.
    </para>
    <example>
     <title>Tri de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
  sort($files);
  print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Comme une valeur de tableau peut Ítre n'importe quoi, elle
     peut aussi Ítre un autre tableau. Comme cela, vous pouvez
     avoir des tableaux multi-dimensionnels, ou r»cursifs.
    </para>
    <example>
     <title>Tableaux multi-dimensionnels, et r»cursifs</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banane",
                                       "c" => "pomme"
                                     ),
                  "nombre" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "trou"   => array (      "premier",
                                       5 => "second",
                                            "troisiÀme"
                                     )
                );

// Exemples d'utilisations des tableaux ci-dessus 
echo $fruits["trou"][5];    // affiche "second"
echo $fruits["fruits"]["a"]; // affiche "orange"
unset($fruits["trou"][0]);  // supprime "premier"

// Cr»er un tableau multidimensionnel
$juices["pomme"]["vert"] = "bon"; 
?>
]]>
     </programlisting>
    </example>
   </sect2>
  </sect1>
  <sect1 id="language.types.object">
   <title>Les objets</title>
   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>
    <para>
      Pour initialiser un objet, vous devez utiliser la commande "new"
      afin de cr»er l'instance de l'objet.
      <example>
       <title>Cr»ation d'un objet</title>
       <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function faire_foo()
    {
        echo "Faisant foo."; 
    }
}

$bar = new foo;
$bar->faire_foo();
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 id="language.types.object.casting">
    <title>Conversion en objet</title>
    
    <para>
     Si un objet est converti en objet, il n'est pas modifi». Si une
     valeur d'un autre type est convertie en objet, une nouvelle instance
     de la classe <literal>stdClass</literal> sera cr»»e. Si la valeur
     »tait &null; la nouvelle instance sera vide. Pour les autres valeurs,
     un membre de l'objet appel» <literal>scalar</literal> contiendra la valeur.
      <example>
       <title>Transtypage</title>
      <programlisting role="php">
<![CDATA[
<?php
  $obj = (object) 'au revoir';
  echo $obj->scalar;  // affiche 'au revoir'
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.resource">
   <title>Ressources</title>
    <para>
     Une ressource (<literal>"resource"</literal> en anglais), est un type sp»cial,
     qui repr»sente une r»f»rence sur une ressource externe. Les
     ressources sont cr»»es par des fonctions d»di»es. Reportez
     vous ‡ l'annexe <link linkend="resource">Types des ressources &php;</link>
     pour une liste exhaustive des fonctions cr»ant et utilisant
     ces ressources.
    </para>
    <note>
     <simpara>
      Le type de donn»es <literal>"resource"</literal> a »t» introduit en &php; 4.
     </simpara>
    </note>
   <sect2 id="language.types.resource.casting">
    <title>Conversion en ressource</title>
    
    <para>
     Comme les ressources contiennent des valeurs trÀs sp»ciales,
     comme des fichiers ouverts, des connexions aux bases de donn»es,
     des images ou n'importe quoi d'autre, vous ne pouvez pas
     convertir une valeur en ressource.
    </para>
    </sect2>
    <sect2 id="language.types.resource.self-destruct">
     <title>Lib»rer des ressources</title>
    <para>
     Gr‚ce au systÀme de comptabilisation des r»f»rences
     introduit en &php; 4 (avec le moteur Zend), &php; d»tecte automatiquement
     qu'une ressource n'est plus utilis»e (comme Java). Dans ce cas,
     toutes les ressources systÀmes utilis»es par cette
     ressource sont lib»r»es automatiquement.
     <note>
      <simpara>
       Les connexions persistantes repr»sentent un cas
       particulier, elles ne seront <emphasis>PAS</emphasis>
       d»truites. Voyez
       <link linkend="features.persistent-connections">connexions persistantes</link>.
      </simpara>
     </note>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.null">
   <title>La valeur &null;</title>
   <para>
    La valeur sp»ciale &null; repr»sente
    l'absence de valeur. Une variable avec la valeur &null; n'a
    pas de valeur.
   </para>
   <sect2 id="language.types.null.syntax">
    <title>Syntaxe</title>
    <para>
     Il y a seulement une valeur de type &null;, et c'est la constante
     &null;, insensible ‡ la casse.
      <example>
       <title>La valeur &null;</title>
      <programlisting role="php">
<![CDATA[
<?php
  $var = Null;
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      La valeur &null; a »t» introduite en &php; 4.
     </simpara>
    </note>
   </sect2>
  </sect1>
  <sect1 id="language.pseudo-types">
   <title>Pseudo-types utilis»s dans cette documentation</title> 

   <sect2 id="language.types.mixed">
    <title><literal>mixed</literal></title>
    <para>
     <literal>mixed</literal> indique qu'un paramÀtre accepte
     plusieurs types, mais pas forc»ment tous les types.
    </para>
    <para>
     <function>gettype</function> par exemple, accepte tous les types de variables
     &php;, mais <function>str_replace</function> n'accepte que des
     &string; et des &array;.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title><literal>number</literal></title>
    <para>
     <literal>number</literal> indique qu'un paramÀtre peut Ítre du type
     &integer; ou &float;.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title><literal>callback</literal></title>
    <para>
     Certaines fonctions comme par exemple <function>call_user_function</function> 
     ou <function>usort</function> accepte une fonction d»finie par 
     l'utilisateur comme fonction de callback. Les fonctions de
     callback peuvent Ítre des fonctions simples, mais aussi des
     objets ou des m»thodes statiques de classe.
    </para>
    <para>
     Une fonction &php; est pass»e simplement en indiquant son nom, sous
     forme de chaÓne de caractÀres. Vous pouvez passer une fonction
     int»gr»e au langage, ou une fonction d»finie par vos soins, ‡
     l'exception de 
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> et
     <function>unset</function>.
    </para>
    <para>
     Une m»thode d'un objet instanci» est pass»e sous forme de &array;,
     contenant un objet comme »l»ment d'index 0, et un nom de m»thode comme
     »l»ment 1.
    </para>
    <para>
     Les m»thodes statiques de classe peuvent aussi Ítre pass»es dans l'objet
     instanci», mais en passant le nom de la classe comme valeur de 
     l'index 0.
    </para>

    <para>
     <example>
      <title>Exemple de fonction de callback</title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_function("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

$foo = new foo;

call_user_function(array($foo, "bar")); // object method call

call_user_function(array("foo", "bar")); // static class method call

?>
]]>
      </programlisting>
     </example>
    </para>  
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>D»finition du type</title>
   <simpara>
     &php; ne n»cessite pas de d»claration explicite
     du type d'une variable. Le type d'une variable est
     d»termin» par le contexte d'utilisation.
     Par exemple, si vous assignez une chaÓne de caractÀres
     ‡ la variable <parameter>var</parameter>, var devient une
     chaÓne de caractÀre. Si vous assignez un nombre
     entier ‡ <parameter>var</parameter>, elle devient un entier.
   </simpara>
   <para>
     Un exemple de convertisseur automatique de type est l'op»rateur
     '+'. Si un des op»randes est de type double, alors tous les
     op»randes sont »valu»s comme des variables de
     type double et le r»sultat est de type double. Sinon, tous
     les op»randes sont »valu»s comme des variables
     de type entier et le r»sultat sera du type entier. Il est
     ‡ noter que cela NE CHANGE PAS le type des op»randes.
     Le seul changement est la maniÀre dont les op»randes
     sont »valu»es.
      <example>
       <title>Conversion automatique</title>
     <programlisting role="php">
<![CDATA[
<?php
  $foo = "0";  // $foo est une chaÓne de caractÀres (ASCII 48)
  $foo += 2;   // $foo est maintenant du type entier (2)
  $foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
  $foo = 5 + "10 Petits cochons"; // $foo est du type entier (15)
  $foo = 5 + "10 cochonnets";     // $foo est du type entier (15)
?>
]]>
<!--
TODO: explain ++/- - behaviour with strings
examples:
 ++'001' = '002'
 ++'abc' = 'abd'
 ++'xyz' = 'xza'
 ++'9.9' = '9.0'
 ++'-3'  = '-4'
 - -'9'   = 8 (integer!)
 - -'5.5' = '5.5'
 - -'-9'  = -10 (integer)
 - -'09'  = 8 (integer)
 - -'abc' = 'abc'
-->
     </programlisting>
    </example>
   </para>
   <simpara>
     Si les deux derniers exemples vous semblent obscurs ou si vous
     voulez forcer une variable a Ítre »valu»e
     avec un certain type, reportez-vous au paragraphe Conversion de
     type ci-dessous. Si vous voulez changer le type d'une variable,
     int»ressez-vous ‡ aux fonctions de
     <link linkend="language.types.string.conversion">conversion de chaÓnes</link>.
   </simpara>
   <simpara>
	Si vous voulez forcer le type d'une variable, vous pouvez
	vous reporter ‡ la section
	<link linkend="language.types.typecasting">transtypage</link>. Si
	vous voulez changer le type d'une variable, utilisez
	<function>settype</function>.
   </simpara>
   <para>
    Pour tester les exemples de cette section, il suffit d'en faire
    un copier/coller, et d'ins»rer les lignes dans un script &php;.
      <example>
       <title>Exploitation des exemples</title>
     <programlisting role="php">
<![CDATA[
<?php
  echo "\$foo==$foo; le type est " . gettype( $foo ) . "<br>\n";
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le comportement de la conversion automatique est actuellement
     ind»finie.
    </para>
    <para>
      <example>
       <title>Conversion automatique ind»finie</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a est une chaÓne
$a[0] = "f";  // Mais que sont les index de chaÓne?
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Etant donn» que &php; supporte l'indexation de chaÓne avec des
     offsets identiques ‡ celles des tableaux, l'exemple ci-dessus
     conduit ‡ un problÀme : est ce que <varname>$a</varname> est un tableau,
     dont le premier »l»ment est "<literal>f</literal>", ou bien est ce que
     "f" est le premier »l»ment de la chaÓne de
     caractÀres <varname>$a</varname>?
    </para>
    <para>
     Les versions courantes de &php; interprÀte la seconde assignation
     comme un index de chaÓne, et donc <varname>$a</varname> devient 
     "<literal>f</literal>", et le
     r»sultat de cette conversion automatique doit Ítre consid»r» comme
     ind»fini. &php; 4 a introduit la syntaxe avec les accolades pour
     acc»der aux caractÀres d'une chaÓne. Utilisez plutÙt le code
     ci-dessous : 
      <example>
       <title>Conversion automatique ind»finie(2)</title>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a est une chaÓne
$a{1} = "f";   // $a vaut maintenant "afc"
?>
]]>
      </programlisting>
     </example>
     Voyez la section <link linkend="language.types.string.substr">AccÀs aux caractÀres d'une chaÓne</link>
     pour plus de d»tails.
    </para>
   </note>
   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>
    <para>
      La conversion de type en &php; fonctionne de la mÍme
      maniÀre qu'en C: le nom du type d»sir»
      est »crit entre parenthÀses devant la variable
      ‡ transtyper ("cast").
      <example>
       <title>Transtypage</title>
      <programlisting role="php">
<![CDATA[
<?php
  $foo = 10;   // $foo est un entier
  $bar = (double) $foo;   // $bar est un double
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Les conversions autoris»es sont:
     <itemizedlist>
      <listitem>
       <simpara><literal>(int)</literal>, <literal>(integer)</literal> - type entier</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(bool)</literal>, <literal>(boolean)</literal> - bool»en</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(real)</literal>, <literal>(double)</literal>, <literal>(float)</literal> - type double</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(string)</literal> - type chaÓne</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(array)</literal> - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(object)</literal> - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
      Il est ‡ noter que les tabulations et les espaces
      sont autoris»s ‡ l'int»rieur des
      parenthÀses, donc les lignes suivantes sont »quivalentes:
      <example>
       <title>Transtypage et espaces</title>
      <programlisting role="php">
<![CDATA[
<?php
  $foo = (int) $bar;
  $foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Au lieu de transtyper une variable en chaÓne, vous pouvez aussi
      l'ins»rer entre deux guillemets doubles : 
      <example>
       <title>Transtypage en chaÓne</title>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo est un entier
$str = "$foo";        // $str est une chaÓne
$fst = (string) $foo; // $fst est aussi une chaÓne

// Ceci affiche : "Identique"
if ($fst === $str) {
    echo "Identique";
}
?>
]]>
      </programlisting>
     </example>
     </para>
    </note>
    <para>
     Le transtypage n'a pas toujours de r»sultat pr»visible.
     Pour plus d'informations, voyez :
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Conversion en
        bool»en</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Conversion en
        entier</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Conversion en
        nombre ‡ virgule flottante</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Conversion en
        chaÓne de caractÀres</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Conversion en
        tableau</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Conversion en
        objet</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Conversion en
        ressource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Conversion en
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
