<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 2684871e4f3c75eadc3a39dc434161be83ae8b60 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="language.types.float">
 <title>Nombres décimaux</title>
 
 <para>
  Les nombres décimaux, (aussi connus comme 
  nombres à virgule flottante, 
  <literal>"floats"</literal>, <literal>"doubles"</literal>, ou 
  <literal>"real numbers"</literal>)
  peuvent être spécifiés en utilisant les syntaxes suivantes :
 </para>
 
 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>
]]>
  </programlisting>
 </informalexample>
 
 <para>
  Formellement :
 </para>
 
 <informalexample>
  <programlisting>
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
  </programlisting>
 </informalexample>
 
 <para>
  La taille d'un &float; est dépendant de la plate-forme, cependant,
  un nombre maximal de ~1.8e308 avec une précision sur 14 chiffres est
  une valeur commune (format 64 bits IEEE).
 </para>
 
 <warning xml:id="warn.float-precision">
  <title>Précision des nombres décimaux</title>
  
  <para>
   Les nombres décimaux ont une précision limitée. Même s'ils dépendent du système,
   PHP utilise le format de précision des décimaux IEEE 754, qui donnera une erreur
   maximale relative de l'ordre de 1.11e-16 (dûe aux arrondis). Les opérations
   arithmétiques non-élémentaires peuvent donner des erreurs plus importantes et
   bien sûr les erreurs doivent être prises en compte lorsque plusieurs opérations
   sont liées.
  </para>
  
  <para>
   Aussi, les nombres rationnels exactement représentables sous forme de nombre à virgule
   flottante en base 10, comme <literal>0.1</literal> ou <literal>0.7</literal>, n'ont pas
e
   de représentation exacte comme nombres à virgule flottante en base 2, utilisée en
   interne, et ce qu'elle que soit la taille de la mantisse. De ce fait, ils ne peuvent
   être convertis sans une petite perte de précision. Ceci peut mener à des résultats
   confus: par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera normalement
   <literal>7</literal> au lieu de <literal>8</literal> attendu, car la représentation
   interne sera quelque chose comme <literal>7.9999999999999991118...</literal>.
  </para>
  
  <para>
   Ainsi, ne faites jamais confiance aux derniers chiffres d'un nombre
   décimal, mais aussi, ne comparez jamais l'égalité de 2 nombres 
   décimaux. Si vous avez besoin d'une haute précision,
   les <link linkend="ref.bc">fonctions mathématiques de précision</link> et les
   <link linkend="ref.gmp">fonctions gmp</link> sont disponibles.
  </para>
 </warning>
 
 <sect2 xml:id="language.types.float.casting">
  <title>Conversion en un nombre décimal</title>
  
  <para>
   Pour plus d'informations sur la conversion de chaînes en nombres 
   décimaux, voir la section sur la
   <link linkend="language.types.string.conversion">conversion de chaînes en
   nombres décimaux</link>. Pour les valeurs d'autres types, la conversion
   est effectuée en convertissant tout d'abord la valeur en un entier, puis, en &float;.
   Voir la section sur la
   <link linkend="language.types.integer.casting">conversion en entier</link> pour plus
   d'informations. Une notice est émise si un &object; est converti en &float;.
  </para>
  
 </sect2>
 
 <sect2 xml:id="language.types.float.nan">
  <title>NaN</title>
  <para>
   Quelques opérations numériques peuvent donner comme résultat une valeur
   représentée par la constante <constant>NAN</constant>. Ce résultat représente
   une valeur indéfinie ou non représentable lors de calculs avec des nombres
   à virgule flottante. Toute comparaison, même stricte de cette valeur avec
   une autre valeur, y compris cette constante elle-même, donnera une valeur
   de &false;.
  </para>
  <para>
   En raison du fait que <constant>NAN</constant> représente tout nombre de valeur
   différente, <constant>NAN</constant> ne doit pas être comparé à d'autres valeurs,
   y compris cette constante elle-même, et à la place, elle doit être vérifiée
   en utilisant la fonction <function>is_nan</function>.
  </para>
 </sect2>
 
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->