<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 84b8fca68fc762fefe85acde180a38b2e77a28b9 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
  <title>Constructeurs et destructeurs</title>

  <sect2 xml:id="language.oop5.decon.constructor">
   <title>Constructeurs</title>
   <methodsynopsis xml:id="object.construct">
    <type>void</type><methodname>__construct</methodname>
    <methodparam choice="opt"><type>mixed</type><parameter>args</parameter></methodparam>
    <methodparam choice="opt"><parameter>...</parameter></methodparam>
   </methodsynopsis>
   <para>
    PHP permet aux développeurs de déclarer des constructeurs pour
    les classes. Les classes qui possèdent une méthode constructeur
    appellent cette méthode à chaque création d'une nouvelle instance
    de l'objet, ce qui est intéressant pour toutes les initialisations
    dont l'objet a besoin avant d'être utilisé.
   </para>
   <note>
    <simpara>
     Les constructeurs parents ne sont pas appelés implicitement
     si la classe enfant définit un constructeur. Si vous
     voulez utiliser un constructeur parent, il sera nécessaire de faire
     appel à <literal>parent::__construct()</literal>.
    </simpara>
   </note>
   <example>
    <title>Exemple d'utilisation des nouveaux constructeurs unifiés</title>
    <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
    function __construct() {
        print "In BaseClass constructor\n";
    }
}

class SubClass extends BaseClass {
    function __construct() {
        parent::__construct();
        print "In SubClass constructor\n";
    }
}

$obj = new BaseClass();
$obj = new SubClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    Pour des raisons de compatibilité ascendante, si PHP ne peut pas
    trouver une fonction <link linkend="object.construct">__construct()</link> pour une classe
    donnée, il cherchera une fonction constructeur représentée, comme dans
    l'ancien style (PHP &lt; 5), par le nom de la classe.
    Effectivement, cela signifie que le seul cas où il pourrait y avoir
    un problème de compatibilité est celui où votre classe contiendrait une
    méthode nommée <link linkend="object.construct">__construct()</link> et que vous en ayez un
    autre usage.
   </para>
   <para>
    A la différence des autres méthodes, PHP ne génèrera pas d'erreur de niveau
    <constant>E_STRICT</constant> lorsque <link linkend="object.construct">__construct()</link> est
    surchargé avec des paramètres différents du <link linkend="object.construct">__construct()</link> parent.
   </para>
   <para>
    Depuis PHP 5.3.3, les méthodes ayant le même nom que la classe dans laquelle
    elle se trouve ne sont plus traitées comme des constructeur, si la classe
    considérée se situe dans un espace de noms. Ceci n'affecte pas les classes
    sans espace de noms.
   </para>
   <example>
    <title>Constructeurs dans les classes dans des espaces de noms</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace Foo;
class Bar {
    public function Bar() {
        // Traitée comme un constructeur dans PHP 5.3.0-5.3.2
        // Traitée comme une méthode normale depuis PHP 5.3.3
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.decon.destructor">
   <title>Destructor</title>
   <methodsynopsis xml:id="object.destruct">
    <type>void</type><methodname>__destruct</methodname>
    <void />
   </methodsynopsis>
   <para>
    PHP 5 introduit un concept de destructeur similaire aux autres langages
    orientés objet, comme le <literal>C++</literal>. La méthode destructeur est appelée
    dès qu'il n'y a plus d'autres références sur des objets, ou dans n'importe quel
    ordre de la séquence d'arrêt.
   </para>
   <example>
    <title>Exemple avec un Destructeur</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyDestructableClass {
    function __construct() {
        print "In constructor\n";
        $this->name = "MyDestructableClass";
    }

    function __destruct() {
        print "Destruction de " . $this->name . "\n";
    }
}

$obj = new MyDestructableClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    Tout comme le constructeur, le destructeur parent n'est pas appelé
    implicitement par le moteur. Pour exécuter le destructeur parent, vous
    devez appeler explicitement la fonction
    <literal>parent::__destruct</literal> dans le corps du destructeur.
   </para>
   <para>
    Le destructeur sera appelé même si l'exécution du script est stoppé
    en utilisant la fonction <function>exit</function>.
    Appeler la fonction <function>exit</function>
    dans un destructeur permettra de ne pas exécuter les autres routines d'arrêt.
   </para>
   <note>
    <para>
     Les destructeurs appelées durant l'arrêt du script ont déjà envoyés
     les en-têtes HTTP. Le dossier de travail dans la phase du script d'arrêt
     peut être différent avec d'autres APIs (e.g. Apache).
    </para>
   </note>
   <note>
    <para>
     Tenter de lancer une exception depuis un destructeur (appelé à la fin du script)
     émet une erreur fatale.
    </para>
   </note>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->