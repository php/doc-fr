<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.26 $ -->
<!-- EN-Revision: 1.27 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.basic" xmlns="http://docbook.org/ns/docbook">
  <title>Syntaxe de base</title>
  <sect2 xml:id="language.oop5.basic.class">
   <title>class</title>
   <para>
    Chaque définition de classe commence par le mot-clé
    <literal>class</literal>, suivi par le nom de la classe, qui peut être
    quelconque à condition que ce ne soit pas un
    <link linkend="reserved">mot réservé</link> en PHP.
    Suivent une paire de parenthèses contenant la définition des membres et des
    méthodes. Une pseudo-variable <varname>$this</varname> est disponible
    lorsqu'une méthode est appelée depuis un contexte objet.
    <varname>$this</varname> est une référence à l'objet appelé (habituellement,
    l'objet auquel la méthode appartient, mais ce peut être un autre objet si
    la méthode est appelée de manière
    <link linkend="language.oop5.static">statique</link> depuis le
    contexte d'un autre objet). Ce comportement est illustré dans l'exemple
    suivant :
    <example>
     <title>La variable <varname>$this</varname> en programmation objet</title>
     <programlisting role="php">
<![CDATA[
<?php
class A
{
  function toto()
  {
    if (isset($this)) {
      echo '$this est définie (';
      echo get_class($this);
      echo ")\n";
    } else {
      echo "\$this n'est pas définie.\n";
    }
  }
}

class B
{
  function titi()
  {
    A::toto();
  }
}

$a = new A();
$a->toto();
A::toto();
$b = new B();
$b->titi();
B::titi();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
$this est définie (a)
$this n'est pas définie.
$this est définie (b)
$this n'est pas définie.
]]>
     </screen>
    </example>
   </para>
   <example>
    <title>Définition simple d'une classe</title>
    <programlisting role="php">
<![CDATA[
<?php
class SimpleClass
{
   // déclaration d'un membre
   public $var = 'une valeur par défaut';

   // déclaration de la méthode
   public function displayVar() {
     echo $this->var;
   }
}
?>
]]>
    </programlisting>
   </example>

   <para>
    La valeur par défaut doit être une expression, et non (par exemple)
    une variable, un membre d'une classe ou un appel à une fonction.
    <example>
     <title>Valeur par défaut des membres d'une classe</title>
     <programlisting role="php">
      <![CDATA[
<?php
     class SimpleClass
     {
     // Déclarations de membres non valides :
     public $var1 = 'hello '.'world';
     public $var2 = <<<EOD
Bonjour le monde !
EOD;
     public $var3 = 1+2;
     public $var4 = self::myStaticMethod();
     public $var5 = $myVar;

     // Déclarations de membres valides :
     public $var6 = myConstant;
     public $var7 = self::classConstant;
     public $var8 = array(true, false);
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
     Il y a plusieurs fonctions utiles pour gérer les classes et les objets. Vous devriez
     regarder du côté des <link linkend="ref.classobj">fonctions d'objets et de classes</link>.
    </para>
   </note>

   <para>
    Contrairement à heredocs, nowdocs peut être utilisé dans n'importe quel contexte de
    données statiques.
    <example>
     <title>Exemple avec des données statiques</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    // Depuis PHP 5.3.0
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le support de Nowdoc a été ajouté depuis PHP 5.3.0.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.basic.new">
   <title>Le mot-clé <literal>new</literal></title>
   <para>
    Pour créer une instance d'une classe, un nouvel objet doit être créé et
    assigné à une variable. Un objet doit toujours être assigné lors de la
    création d'un nouvel objet à moins qu'il ait un
    <link linkend="language.oop5.decon">constructeur</link>
    défini qui lance une  <link linkend="language.exceptions">exception</link>
    en cas d'erreur. Les classes doivent être définies avant l'instanciation (dans
    certains cas, c'est impératif).
   </para>
   <example>
    <title>Création d'une instance</title>
    <programlisting role="php">
<![CDATA[
<?php
$instance = new SimpleClass();

// Ceci peut également être réalisé avec une variable :
$className = 'Foo';
$instance = new $className(); // Foo()
?>
]]>
    </programlisting>
   </example>
   <para>
    Dans le contexte de la classe, il est possible de créer un nouvel objet
    avec <literal>new self</literal> et <literal>new parent</literal>.
   </para>
   <para>
    Lors de l'assignation d'une instance déjà créée d'une classe à une variable,
    la nouvelle variable accédera à la même instance de l'objet assigné.
    Ce comportement est le même que lors du passage d'une instance à une fonction.
    Une copie d'un objet déjà créé peut être effectuée par
    <link linkend="language.oop5.cloning">clonage</link>.
   </para>
   <example>
    <title>Assignation d'un objet</title>
    <programlisting role="php">
<![CDATA[
<?php
$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned aura cette valeur';

$instance = null; // $instance et $reference deviennent null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned aura cette valeur"
}
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.basic.extends">
   <title>Le mot-clé <literal>extends</literal></title>
   <para>
    Une classe peut hériter des méthodes et des membres d'une autre classe en
    utilisant le mot-clé <literal>extends</literal> dans la déclaration.
    Il n'est pas possible d'étendre de multiples classes : une classe peut
    uniquement hériter d'une seule classe de base.
   </para>
   <para>
    Les méthodes et membres hérités peuvent être surchargés, à moins que
    la classe parente ait défini une méthode comme
    <link linkend="language.oop5.final">final</link>. Pour surcharger, il suffit
    de déclarer à nouveau la méthode avec le même nom
    que celui défini dans la classe parente. Il est possible d'accéder à une
    méthode ou un membre statique avec l'opérateur
    <link linkend="language.oop5.paamayim-nekudotayim">parent::</link>
   </para>
   <example>
    <title>Héritage d'une classe simple</title>
    <programlisting role="php">
<![CDATA[
<?php
class ExtendClass extends SimpleClass
{
  // Redéfinition de la méthode parent
  function displayVar()
  {
    echo "Classe étendue\n";
    parent::displayVar();
  }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Classe étendue
une valeur par défaut
]]>
    </screen>
   </example>
  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->