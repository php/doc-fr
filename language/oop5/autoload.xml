<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 99b8716337e2c27b6addf7e184b8ac7a50bb38b0 Maintainer: jpauli Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.oop5.autoload" xmlns="http://docbook.org/ns/docbook">
 <title>Auto-chargement de classes</title>
 <para>
  De nombreux développeurs qui écrivent des applications orientées objet
  créent un fichier source par définition de classe. Un des plus gros inconvénients
  de cette méthode est d'avoir à écrire une longue liste d'inclusions de
  fichier de classes au début de chaque script : une inclusion par classe.
 </para>
 <para>
  La fonction <function>spl_autoload_register</function> enregistre un nombre quelconque de
  chargeurs automatiques, ce qui permet aux classes et aux interfaces d'être
  automatiquement chargées si elles ne sont pas définies actuellement.
  En enregistrant des autochargeurs, PHP donne une dernière chance d'inclure une
  définition de classe ou interface, avant que PHP n'échoue avec une erreur.
 </para>
 <tip>
  <para>
   Bien que la fonction <function>__autoload</function> puisse également être 
   utilisée pour le chargement automatique des classes et des interfaces, il 
   est préférable d'utiliser la fonction <function>spl_autoload_register</function>. 
   Cela est dû au fait qu'il s'agit d'une alternative plus flexible (permettant 
   de spécifier un nombre quelconque de chargeurs automatique dans l'application, 
   par exemple dans les bibliothèques tierces).
   Pour cette raison, l'utilisation de <function>__autoload</function> est
   découragée et est obsolète à partir de PHP 7.2.
  </para>
 </tip>
 <note>
  <para>
   Si le nom de la classe est utilisé par exemple dans la fonction
   <function>call_user_func</function>, alors il peut contenir des caractères
   dangereux comme <literal>../</literal>. Il est recommandé de ne pas utiliser
   d'entrées utilisateur dans de telles fonctions, ou, au moins, de vérifier l'entrée
   dans la fonction <function>__autoload</function>.
  </para>
 </note>
 <para>
  <example>
   <title>Exemple avec <function>__autoload</function></title>
   <para>
    Cet exemple tente de charger les classes <literal>MaClasse1</literal>
    et <literal>MaClasse2</literal>, respectivement depuis les fichiers
    <filename>MaClasse1.php</filename> et
    <filename>MaClasse2.php</filename>.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
spl_autoload_register(function ($class_name) {
    include $class_name . '.php';
});

$obj  = new MaClasse1();
$obj2 = new MaClasse2();
?>
]]>
   </programlisting>
  </example>
  <example>
   <title>Autre exemple d'auto-chargement</title>
   <para>
    Cet exemple tente de charger l'interface <literal>ITest</literal>.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

spl_autoload_register(function ($name) {
    var_dump($name);
});

class Foo implements ITest {
}

/*
string(5) "ITest"

Fatal error: Interface 'ITest' not found in ...
*/
?>
]]>
   </programlisting>
  </example>
  <example>
   <title>Auto-chargement avec gestion des exceptions</title>
   <para>
    Cet exemple lance une exception et montre comment la traiter avec
    un bloc try/catch.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
spl_autoload_register(function ($name) {
    echo "Tentative de chargement de $name.\n";
    throw new Exception("Impossible de charger $name.");
});

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Tentative de chargement de NonLoadableClass.
Impossible de charger NonLoadableClass.
]]>
   </screen>
  </example>
  <example>
   <title>Auto-chargement avec gestion des exceptions. Exception personnalisée manquante</title>
   <para>
    Cet exemple lance une exception personnalisée non-chargeable.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
spl_autoload_register(function ($name) {
    echo "Tentative de chargement de $name.\n";
    throw new MissingException("Impossible de charger $name.");
});

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Tentative de chargement de NonLoadableClass.
Tentative de chargement de MissingException.

Fatal error: Class 'MissingException' not found in testMissingException.php on line 4
]]>
   </screen>
  </example>
 </para>
 
 <simplesect role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
     <member><function>unserialize</function></member>
     <member><link linkend="ini.unserialize-callback-func">unserialize_callback_func</link></member>
     <member><function>spl_autoload_register</function></member>
     <member><function>spl_autoload</function></member>
     <member><function>__autoload</function></member>
    </simplelist>
  </para>
 </simplesect>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
