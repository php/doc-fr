<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 6f78fd028980bd883f3f0a670598f4e34c60e6e8 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.static" xmlns="http://docbook.org/ns/docbook">
  <title>Statique</title>

  <para>
   Le fait de déclarer des proriétés ou des méthodes comme statics vous
   permet d'y accéder sans avoir besoin d'instancier la classe. On ne peut
   accéder à une propriété déclarée comme statique avec l'objet instancié d'une
   classe (bien qu'une méthode statique le puisse).
  </para>

  <para>
   Si aucune déclaration de  <link linkend="language.oop5.visibility">visibilité</link>
   n'est spécifiée, alors la propriété ou la méthode sera automatiquement spécifiée
   comme <literal>public</literal>.
  </para>

  <para>
   Comme les méthodes statiques peuvent être appelées sans objet,
   la pseudo-variable <varname>$this</varname> n'est pas disponible
   dans la méthode déclarée en tant que statique.
  </para>

  <para>
   On ne peut pas accéder à des propriétés statiques à travers l'objet en utilisant
   l'opérateur <literal>-&gt;</literal>.
  </para>

  <para>
   L'appel statique de méthodes non-statiques génère une erreur de niveau
   <constant>E_STRICT</constant>.
  </para>

  <para>
   Comme n'importe quelle autre variable PHP statique, les propriétés statiques ne peuvent être
   initialisées qu'en utilisant un litéral ou une constante; les expressions ne sont pas 
   permises. Ainsi, vous pouvez initialiser une propriété statique avec un
   entier ou un tableau, mais ni avec une autre variable, ni avec une valeur de retour,
   ni avec un objet.
  </para>

  <para>
   Depuis PHP 5.3.0, il est possible de référencer la classe en utilisant
   une variable. La valeur de la variable ne peut être un mot-clé (e.g. <literal>self</literal>,
   <literal>parent</literal> et <literal>static</literal>).
  </para>

  <example>
   <title>Exemple avec une propriété statique</title>
   <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo
{

    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo->staticValue() . "\n";
print $foo->my_static . "\n";      // propriété my_static non définie

print $foo::$my_static . "\n";
$classname = 'Foo';
print $classname::$my_static . "\n"; // Depuis PHP 5.3.0

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar->fooStatic() . "\n";
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Exemple avec une méthode statique</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
$classname = 'Foo';
$classname::aStaticMethod(); // Depuis PHP 5.3.0
?>
]]>
    </programlisting>
  </example>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
