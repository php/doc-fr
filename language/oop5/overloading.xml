<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 96c9d88bad9a7d7d44bfb7f26c226df7ee9ddf26 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.overloading" xmlns="http://docbook.org/ns/docbook">
  <title>Surcharge</title>

  <para>
   La surcharge en PHP permet de créer dynamiquement des
   propriétés et des méthodes. Ces entités dynamiques sont
   traitées via mes méthodes magiques établies dans une
   classe pour diverses types d'actions.
  </para>

  <para>
   Les méthodes surchargées sont appelées lors de l'interaction
   avec les propriétés et les méthodes qui n'ont pas été déclarés
   ou ne sont pas <link linkend="language.oop5.visibility">visibles</link>
   dans le contexte courant. Le reste de cette section utilise
   les termes de <quote>propriétés inaccessibles</quote> et de
   <quote>méthodes inaccessibles</quote> pour se référer à cette
   combinaison de déclaration et de visibilité.
  </para>

  <para>
   Toutes les méthodes surchargées doivent être définies comme
   <literal>public</literal>.
  </para>

  <note>
   <para>
    Aucun des arguments de ces méthodes magiques ne peut être
    <link linkend="functions.arguments.by-reference">passé par
    référence</link>.
   </para>
  </note>

  <note>
   <para>
    L'interprétation PHP de la <quote>surcharge</quote> est
    différente de la plupart des langages orientés objet.
    La surcharge, habituellement, fournit la possibilité d'avoir
    plusieurs méthodes portant le même nom mais avec une quantité
    et des types différents d'arguments.
   </para>
  </note>


  <sect2 xml:id="language.oop5.overloading.changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>5.3.0</entry>
        <entry>
         Ajout de <function>__callStatic</function>.
         Ajout d'un avertissement pour forcer la visibilité <literal>public</literal>
         et la déclaration non <literal>static</literal>.
        </entry>
       </row>
       <row>
        <entry>5.1.0</entry>
        <entry>
         Ajout de <function>__isset</function> et de <function>__unset</function>.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>


  <sect2 xml:id="language.oop5.overloading.members">
   <title>Surcharge des propriétés</title>

   <methodsynopsis>
    <type>void</type><methodname>__set</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>mixed</type><parameter>value</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>mixed</type><methodname>__get</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>bool</type><methodname>__isset</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>void</type><methodname>__unset</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>

   <para>
    <function>__set</function> est sollicitée lors de l'écriture de données
    vers des propriétés inaccessibles.
   </para>

   <para>
    <function>__get</function> est sollicitée pour lire des données depuis des
    propriétés inaccessibles.
   </para>

   <para>
    <function>__isset</function> est sollicitée lorsque
    <function>isset</function> ou la fonction <function>empty</function>
    sont appelés avec des propriétés inaccessibles.
   </para>

   <para>
    <function>__unset()</function> est sollicitée lorsque
    <function>unset</function> est appelée avec des propriétés inaccessibles.
   </para>

   <para>
    L'argument <varname>$name</varname> est le nom du propriété qui interagit.
    L'argument <varname>$value</varname> de la méthode <function>__set</function>
    spécifie la valeur du propriété <varname>$name</varname> qui doit être définie.
   </para>

   <para>
    La surcharge des propriétés ne fonctionne que dans les contexte objet.
    Ces méthodes magiques ne seront pas lancées dans un contexte statique.
    Par conséquent, ces méthodes ne devraient pas être déclarées comme
    <link linkend="language.oop5.static">statiques</link>. Depuis PHP 5.3.0,
    une alerte est levée si une des méthodes magiques est déclarée statique.
   </para>

   <note>
    <para>
     La valeur retournée par <function>__set</function>
     est ignoré en raison de la façon dont le processus PHP
     assigne les opérateurs. De la même façon,
     <function>__get</function> n'est jamais appelé lors
     d'un enchaînement d'assignements, comme ceci :
     <literal><![CDATA[ $a = $obj->b = 8; ]]></literal>
    </para>
   </note>

   <example>
    <title>Exemple de surcharge de propriétés avec les méthodes
     <function>__get</function>, <function>__set</function>,
     <function>__isset</function> et <function>__unset</function>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
class PropertyTest {
    /**  Variable pour les données surchargées.  */
    private $data = array();

    /**  La surcharge n'est pas utilisée sur les propriétés déclarés.  */
    public $declared = 1;

    /**  La surcharge n'est lancée que lorsque l'on accède à la classe depuis l'extérieur.  */
    private $hidden = 2;

    public function __set($name, $value) {
        echo "Définition de '$name' à la valeur '$value'\n";
        $this->data[$name] = $value;
    }

    public function __get($name) {
        echo "Récupération de '$name'\n";
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

        $trace = debug_backtrace();
        trigger_error(
            'Propriété non-définie via __get(): ' . $name .
            ' dans ' . $trace[0]['file'] .
            ' à la ligne ' . $trace[0]['line'],
            E_USER_NOTICE);
        return null;
    }

    /**  Depuis PHP 5.1.0  */
    public function __isset($name) {
        echo "Est-ce que '$name' est défini ?\n";
        return isset($this->data[$name]);
    }

    /**  Depuis PHP 5.1.0  */
    public function __unset($name) {
        echo "Effacement de '$name'\n";
        unset($this->data[$name]);
    }

    /**  Ce n'est pas une méthode magique, nécessaire ici que pour l'exemple.  */
    public function getHidden() {
        return $this->hidden;
    }
}


echo "<pre>\n";

$obj = new PropertyTest;

$obj->a = 1;
echo $obj->a . "\n\n";

var_dump(isset($obj->a));
unset($obj->a);
var_dump(isset($obj->a));
echo "\n";

echo $obj->declared . "\n\n";

echo "Manipulons maintenant la propriété privée nommée 'hidden':\n";
echo "'hidden' est visible depuis la classe, donc __get() n'est pas utilisé...\n";
echo $obj->getHidden() . "\n";
echo "'hidden' n'est pas visible en dehors de la classe, donc __get() est utlisé...\n";
echo $obj->hidden . "\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen role="php">
<![CDATA[
Définition de 'a' à '1'
Récupération de 'a'
1

Est-ce que 'a' est défini ?
bool(true)
Effacement de 'a'
Est-ce que 'a' est défini ?
bool(false)

1

Manipulons maintenant la propriété privée nommée 'hidden':
'hidden' est visible depuis la classe, donc __get() n'est pas utilisé...
2
'hidden' n'est pas visible en dehors de la classe, donc __get() est utlisé...
Récupération de 'hidden'


Notice:  Propriété non-définie via __get(): hidden dans <file> à la ligne 64 dans <file> à la ligne 28
]]>
    </screen>

   </example>
  </sect2>

  <sect2 xml:id="language.oop5.overloading.methods">
   <title>Surcharge de méthode</title>

   <methodsynopsis>
    <type>mixed</type><methodname>__call</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>array</type><parameter>arguments</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>mixed</type><methodname>__callStatic</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>array</type><parameter>arguments</parameter></methodparam>
   </methodsynopsis>

   <para>
    <function>__call</function> est lancé lorsque l'on invoque des
    méthodes inaccessibles dans le contexte de l'objet.
   </para>

   <para>
    <function>__callStatic</function> est lancé lorsque l'on invoque
    des méthodes inaccessibles dans un contexte statique.
   </para>

   <para>
    L'argument <varname>$name</varname> est le nom de la méthode appelée.
    L'argument <varname>$arguments</varname> est un tableau contenant
    les paramètres passés à la méthode <varname>$name</varname>.
   </para>

   <example>
    <title>Surcharge de méthodes avec
     <function>__call</function> et
     <function>__callStatic</function></title>
    <programlisting role="php">
  <![CDATA[
<?php
class MethodTest {
    public function __call($name, $arguments) {
        // Note : la valeur de $name est sensible à la casse.
        echo "Appel de la méthode '$name' "
             . implode(', ', $arguments). "\n";
    }

    /**  Depuis PHP 5.3.0  */
    public static function __callStatic($name, $arguments) {
        // Note : la valeur de $name est sensible à la casse.
        echo "Appel de la méthode statique '$name' "
             . implode(', ', $arguments). "\n";
    }
}

$obj = new MethodTest;
$obj->runTest('dans un contexte objet');

MethodTest::runTest('dans un contexte statique');  // Depuis PHP 5.3.0
?>
]]>
    </programlisting>
    &example.outputs;
    <screen role="php">
<![CDATA[
Appel de la méthode 'runTest' dans un contexte objet
Appel de la méthode statique 'runTest' dans un contexte statique
]]>
    </screen>
   </example>

  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
