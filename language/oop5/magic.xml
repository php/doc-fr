<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 4f3e16d7854ee82114b8d849731fbd7de57cc627 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Méthodes magiques</title>
  <para>
   Les méthodes
   <link linkend="language.oop5.decon.constructor">__construct()</link>,
   <link linkend="language.oop5.decon.destructor">__destruct()</link>,
   <link linkend="language.oop5.overloading.methods">__call()</link>,
   <link linkend="language.oop5.overloading.methods">__callStatic()</link>,
   <link linkend="language.oop5.overloading.members">__get()</link>,
   <link linkend="language.oop5.overloading.members">__set()</link>,
   <link linkend="language.oop5.overloading.members">__isset()</link>,
   <link linkend="language.oop5.overloading.members">__unset()</link>,
   <link linkend="language.oop5.magic.sleep">__sleep()</link>,
   <link linkend="language.oop5.magic.sleep">__wakeup()</link>,
   <link linkend="language.oop5.magic.tostring">__toString()</link>,
   <link linkend="language.oop5.magic.invoke">__invoke()</link>,
   <link linkend="language.oop5.magic.set-state">__set_state()</link> et
   <link linkend="language.oop5.cloning">__clone()</link>
   sont magiques en PHP. Vous ne pouvez pas utiliser ces noms de méthode
   dans vos classes, sauf si vous voulez implémenter 
   le comportement associé à ces méthodes magiques.
  </para>

  <caution>
   <simpara>
    PHP réserve tous les noms de fonctions commençant par un double souligné
    <literal>__</literal> pour les méthodes magiques. Il est recommandé de
    ne pas utiliser de noms de fonctions commençant par <literal>__</literal>
    sauf si vous voulez des fonctionnalités magiques documentées.
   </simpara>
  </caution>

  <sect2 xml:id="language.oop5.magic.sleep">
   <title>
    <link linkend="language.oop5.magic.sleep">__sleep()</link> et
    <link linkend="language.oop5.magic.sleep">__wakeup()</link>
   </title>
   <para>
    La fonction <function>serialize</function> vérifie si votre classe a une méthode
    avec le nom magique <link linkend="language.oop5.magic.sleep">__sleep()</link>.
    Si c'est le cas, cette méthode sera exécutée avant toute linéarisation. Elle peut
    nettoyer l'objet et elle est supposée retourner un tableau avec les noms de toutes
    les variables de l'objet qui doivent être linéarisées.
    Si la méthode ne retourne rien, alors &null; est linéarisé et une alerte de type
    <constant>E_NOTICE</constant> est émise.
   </para>
   <note>
    <para>
     Il n'est pas possible pour <link linkend="language.oop5.magic.sleep">__sleep()</link> de retourner
     les noms des propriétés privées des classes parentes. Le faire
     résulte en une erreur de niveau <constant>E_NOTICE</constant>.
     À la place, vous devriez utiliser l'interface <classname>Serializable</classname>.
    </para>
   </note>
   <para>
    Le but avoué de <link linkend="language.oop5.magic.sleep">__sleep()</link> est de valider des données en attente
    ou d'effectuer les opérations de nettoyage.
    De plus, cette fonction est utile si vous avez de très gros objets
    qui n'ont pas besoin d'être sauvegardés en totalité.
   </para>
   <para>
    Réciproquement, la fonction <function>unserialize</function> vérifie
    la présence d'une méthode dont le nom est le nom magique
    <link linkend="language.oop5.magic.sleep">__wakeup()</link>. Si elle est présente, cette fonction
    peut reconstruire toute ressource que l'objet possède.
   </para>
   <para>
    Le but avoué de <link linkend="language.oop5.magic.sleep">__wakeup()</link> est de rétablir
    toute connexion de base de données qui aurait été perdue
    durant la linéarisation et d'effectuer des tâches de réinitialisation.
   </para>
   <example>
    <title>Utilisation de sleep() et wakeup()</title>
    <programlisting role="php">
<![CDATA[
<?php
class Connection
{
    protected $link;
    private $server, $username, $password, $db;

    public function __construct($server, $username, $password, $db)
    {
        $this->server = $server;
        $this->username = $username;
        $this->password = $password;
        $this->db = $db;
        $this->connect();
    }

    private function connect()
    {
        $this->link = mysql_connect($this->server, $this->username, $this->password);
        mysql_select_db($this->db, $this->link);
    }

    public function __sleep()
    {
        return array('server', 'username', 'password', 'db');
    }

    public function __wakeup()
    {
        $this->connect();
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><link linkend="language.oop5.magic.tostring">__toString()</link></title>
   <para>
    La méthode <link linkend="language.oop5.magic.tostring">__toString()</link> détermine comment l'objet
    doit réagir lorsqu'il est traité comme une chaîne de caractères.
    Par exemple, ce que <literal>echo $obj;</literal> affichera. Cette méthode doit
    retourner une chaine sinon une erreur <constant>E_RECOVERABLE_ERROR</constant>
    sera levée.
   </para>
   <example>
    <title>Exemple simple</title>
    <programlisting role="php">
<![CDATA[
<?php
// Déclaration d'une classe simple
class ClasseTest
{
    public $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    public function __toString()
    {
        return $this->foo;
    }
}

$class = new ClasseTest('Bonjour');
echo $class;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Bonjour
]]>
    </screen>
   </example>
   <para>
    Il est important de noter qu'avant PHP 5.2.0, la méthode
    <link linkend="language.oop5.magic.tostring">__toString()</link> n'était appelée que si elle était
    directement combinée avec <function>echo</function> ou
    <function>print</function>.
    Depuis PHP 5.2.0, elle est appelée dans tous les contextes de chaîne
    de caractères (e.g. dans <function>printf</function> avec
    le modificateur <literal>%s</literal>) mais pas dans les autres types
    de contextes (e.g. avec le modificateur <literal>%d</literal>).
    Depuis PHP 5.2.0, convertir un objet sans la méthode
    <link linkend="language.oop5.magic.tostring">__toString()</link> en &string; émettra une
    <constant>E_RECOVERABLE_ERROR</constant>.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.magic.invoke">
   <title><link linkend="language.oop5.magic.invoke">__invoke()</link></title>
   <para>
    La méthode <link linkend="language.oop5.magic.invoke">__invoke()</link> est appelée lorsque le script tente
    d'appeler un objet comme une fonction.
   </para>
   <note>
    <para>
     Cette fonctionnalité est disponible depuis PHP 5.3.0.
    </para>
   </note>
   <example>
    <title>Exemple avec <link linkend="language.oop5.magic.invoke">__invoke()</link></title>
    <programlisting role="php">
<![CDATA[
<?php
class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);
var_dump(is_callable($obj));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
int(5)
bool(true)
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><link linkend="language.oop5.magic.set-state">__set_state()</link></title>
   <para>
    Cette méthode <link linkend="language.oop5.static">statique</link> est appelée
    pour les classes exportées par la fonction <function>var_export</function>
    depuis PHP 5.1.0.
   </para>
   <para>
    Le seul paramètre de cette méthode est un tableau contenant les propriétés
    exportées sous la forme <literal>array('propriété' => valeur, ...)</literal>.
   </para>
   <example>
    <title>Utilisation de <link linkend="language.oop5.magic.set-state">__set_state()</link> (depuis PHP 5.1.0)</title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($an_array) // Depuis PHP 5.1.0
    {
        $obj = new A;
        $obj->var1 = $an_array['var1'];
        $obj->var2 = $an_array['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var1' => 5,
                                            //    'var2' => 'foo',
                                            // ));
var_dump($b);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
]]>
    </screen>
   </example>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->