<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: f6580b6a63f1a578a14de64ac6e4a34f56b7e9ec Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Patterns</title>
 <para>
  Les patterns sont un moyen de décrire les meilleures pratiques 
  et les bonnes conceptions. Ils proposent une solution flexible aux problèmes
  habituels de programmation.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Usine</title>
  <para>
   Le pattern d'usine (factory) permet l'instanciation d'objets durant l'exécution.
   Il est appelé "pattern d'usine" puisqu'il est responsable de la "fabrication" 
   d'un objet. Une méthode d'usine reçoit le nom de la classe pour l'instancier en tant
   qu'argument.
  </para>
  <example>
   <title>Méthode de paramètre d'usine</title>
   <programlisting role="php">
<![CDATA[
<?php
class Exemple
{
    // La méthode d'usine
    public static function factory($type)
    {
        if (include_once 'Drivers/' . $type . '.php') {
            $classname = 'Driver_' . $type;
            return new $classname;
        } else {
            throw new Exception('Driver non trouvé');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
    Définir cette méthode dans une classe permet de charger un pilote à la
    volée. Si la classe <literal>Example</literal> était une classe
    d'abstraction de base de données, le chargement des pilotes
    <literal>MySQL</literal> et <literal>SQLite</literal> pourrait être effectué
    comme ceci :
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Chargement du driver MySQL
$mysql = Exemple::factory('MySQL');

// Chargement du driver SQLite
$sqlite = Example::factory('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
   Le pattern singleton permet de s'assurer qu'il n'existe qu'une seule instance d'un objet, et propose
   un point d'accès global à cet objet. Il s'agit d'un pattern du "Gang of Four".
  </para>
   <para>
   Le pattern singleton est souvent implémenté pour des classes de bases de données, des journaliseurs, des objets
    de requête, de réponse ou encore des contrôleurs frontaux.
  </para>
  <example>
   <title xml:id="language.oop5.patterns.singleton.examples.basic">Exemple de Singleton</title>
   <programlisting role="php"><![CDATA[
<?php
class Example
{
    private static $instance;
    private $count = 0;

    private function __construct() 
    {
    }

    public static function singleton() 
    {
        if (!isset(self::$instance)) {
            echo "création de l'instance";
            $className = __CLASS__;
            self::$instance = new $className;
        }
        return self::$instance;
    }

    public function increment()
    {
        return $this->count++;
    }

    public function __wakeup()
    {
        trigger_error('Désérialiser est interdit.', E_USER_ERROR);
    }

    public function __clone()
    {
        trigger_error('Le clônage n\'est pas autorisé.', E_USER_ERROR);
    }
}
?>
]]>
   </programlisting>
   <para>Illustration du comportement du Singleton</para>
   <programlisting role="php"><![CDATA[
<?php
$singleton = Example::singleton(); // Affiche "création de l'instance."
echo $singleton->increment(); // 0
echo $singleton->increment(); // 1

$singleton = Example::singleton(); // Réutilise l'instance existante
echo $singleton->increment(); // 2
echo $singleton->increment(); // 3

// Tout cela lève des Fatal Error
$singleton2 = new Example;
$singleton3 = clone $singleton;
$singleton4 = unserialize(serialize($singleton));
?>
]]>
   </programlisting>
  </example>
  <warning xml:id="warn.singleton.controversy">
   <para>
    Le pattern Singleton est l'un des plus controversés. Les critiques indiquent que le singleton crée un
    contexte global dans l'application et couple fortement le singleton à d'autres classes. Ceci mène vers
    des dépendances cachées et des effets de bord désagréables, le code devient ainsi plus difficile à
    maintenir et à tester.
   </para>
   <para>
    Les critiques pointent aussi l'inutilité d'un singleton dans un environnement isolé comme PHP où les
    objets ne sont pas persistents entre les requêtes. Il est plus simple et propre de créer son graphe
    d'objets en utilisant des monteurs ou des fabriques, en début de requête.
   </para>
   <para>
    Les singletons violent aussi plusieurs principes "SOLID" et la loi de Demeter.
    Les singletons ne peuvent être sérialisés. Il ne peuvent être surchargés (avant PHP 5.3) et ne seront pas
    nettoyés par le collecteur car une instance est toujours présente en mémoire, dans le singleton lui-même.
   </para>   
  </warning>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->