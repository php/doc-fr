<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 31e56c25f90ebedf9aa4aa4877fbc859e1e0529c Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->
<refentry xml:id="closure.getcurrent" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <refnamediv>
  <refname>Closure::getCurrent</refname>
  <refpurpose>Retourne la closure en cours d'exécution</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis role="Closure">
   <modifier>public</modifier> <modifier>static</modifier> <type>Closure</type><methodname>Closure::getCurrent</methodname>
   <void/>
  </methodsynopsis>
  <para>
   Retourne la closure en cours d'exécution. Cette méthode est principalement
   utile pour implémenter des closures récursives sans avoir besoin de capturer
   une référence vers la variable de la closure en utilisant le mot-clé
   <literal>use</literal>.
  </para>
  <para>
   Cette méthode doit être appelée depuis une closure ; l'appeler en dehors
   d'un contexte de closure provoquera l'erreur <literal>Error: Current function is not a closure.</literal>
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  &no.function.parameters;
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne l'instance de <classname>Closure</classname> en cours d'exécution.
  </para>
 </refsect1>

 <refsect1 role="errors">
  &reftitle.errors;
  <para>
   Lance une <classname>Error</classname> si elle est appelée en dehors d'un
   contexte de closure.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example xml:id="closure.getcurrent.example.basic">
   <title>Exemple avec <methodname>Closure::getCurrent</methodname></title>
   <para>
    Utilisation de <methodname>Closure::getCurrent</methodname> pour implémenter
    une fonction de Fibonacci récursive :
   </para>
   <programlisting role="php">
<![CDATA[
<?php
$fibonacci = function (int $n) {
    if ($n === 0 || $n === 1) {
        return $n;
    }

    $fn = Closure::getCurrent();
    return $fn($n - 1) + $fn($n - 2);
};

echo $fibonacci(10); // Affiche : 55
?>
]]>
   </programlisting>
  </example>
  <example xml:id="closure.getcurrent.example.comparison">
   <title>Comparaison avec l'approche traditionnelle</title>
   <para>
    Avant PHP 8.5, implémenter des closures récursives nécessitait de capturer
    une référence vers la variable de la closure en utilisant le mot-clé
    <literal>use</literal> :
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Approche traditionnelle (fonctionne toujours en PHP 8.5)
$fibonacci = function (int $n) use (&$fibonacci) {
    if ($n === 0) return 0;
    if ($n === 1) return 1;
    return $fibonacci($n - 1) + $fibonacci($n - 2);
};

echo $fibonacci(10); // Affiche : 55
?>
]]>
   </programlisting>
   <para>
    L'approche avec <methodname>Closure::getCurrent</methodname> élimine le besoin
    de déclarer la variable avec une référence dans la clause <literal>use</literal>,
    rendant le code plus propre et moins sujet aux erreurs.
   </para>
  </example>
 </refsect1>

</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
