<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 4b4ae3e9937a6520b272d4fd794cd6670d47f9e0 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
 <title>Les opérateurs</title>
 <simpara>
  Un opérateur est quelque chose qui prend une ou plusieurs valeurs
  (ou expressions, dans le jargon de la programmation) et qui retourne une
  autre valeur (donc la construction elle-même devient une expression).
 </simpara>
 <para>
  Les opérateurs peuvent être regroupés en fonction du nombre de valeurs
  qu'ils acceptent. L'opérateur unaire n'opère que sur une seule valeur,
  par exemple <literal>!</literal>
  (l'<link linkend="language.operators.logical">opérateur de négation</link>)
  ou <literal>++</literal>
  (l'<link linkend="language.operators.increment">opérateur d'incrémentation</link>).
  Le second type, les opérateurs binaires (comme le très célèbre
  <link linkend="language.operators.arithmetic">opérateur mathématique</link>
  <literal>+</literal> ou <literal>-</literal>) contient la plupart des opérateurs
  supportés par PHP. Enfin,
  l'<link linkend="language.operators.comparison.ternary">opérateur ternaire</link>,
  <literal>? :</literal>, qui accepte trois valeurs (on peut aussi l'appeler l'opérateur
  conditionnel).
 </para>
 <para>
  Une liste complète des opérateurs se trouve dans la section
  <link linkend="language.operators.precedence">précédence des opérateurs</link>.
  Cette section explique aussi la précédence des opérateurs et l'associativité, c'est à dire
  les priorités d'exécution des opérateurs.
 </para>
 
 <sect1 xml:id="language.operators.precedence">
  <title>La précédence des opérateurs</title>
  <para>
   La priorité des opérateurs spécifie
   l'ordre dans lequel les valeurs doivent être analysées.
   Par exemple, dans l'expression <literal>1 + 5 * 3</literal>, le résultat est
   <literal>16</literal> et non <literal>18</literal>, car la multiplication
   ("*") a une priorité supérieure par rapport à l'addition ("+").
   Des parenthèses peuvent être utilisées pour forcer la priorité, si
   nécessaire. Par exemple : <literal>(1 + 5) * 3</literal> donnera
   <literal>18</literal>.
  </para>
  <para>
   Lorsque les opérateurs ont une précédence équivalente, c'est leur
   associativité qui détermine s'ils sont évalués de droite à gauche ou
   inversement. Voyez les exemples ci-après.
  </para>
  <para>
   Le tableau qui suit liste les opérateurs par ordre de précédence, avec la
   précédence la plus élevée en haut. Les opérateurs sur la même ligne ont
   une précédence équivalente (donc l'associativité décide de l'ordre de leur
   évaluation).
   <table>
    <title>Précédence des opérateurs</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Associativité</entry>
       <entry>Opérateurs</entry>
       <entry>Information additionnelle</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>non-associative</entry>
       <entry>clone new</entry>
       <entry><link linkend="language.oop5.cloning">clone</link> et <link linkend="language.oop5.basic.new">new</link></entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>[</entry>
       <entry><function>array</function></entry>
      </row>
      <row>
       <entry>droite</entry>
       <entry>++ -- ~ (int) (float) (string) (array) (object) (bool) @</entry>
       <entry>
        <link linkend="language.types">types</link> et <link linkend="language.operators.increment">incrément/décrément</link>
       </entry>
      </row>
      <row>
       <entry>non-associatif</entry>
       <entry>instanceof</entry>
       <entry>
        <link linkend="language.types">types</link>
       </entry>
      </row>
      <row>
       <entry>droite</entry>
       <entry>!</entry>
       <entry>
        <link linkend="language.operators.logical">logique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>* / %</entry>
       <entry>
        <link linkend="language.operators.arithmetic">arithmétique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>+ - .</entry>
       <entry>
        <link linkend="language.operators.arithmetic">arithmétique</link>&listendand;
        <link linkend="language.operators.string">chaîne de caractères</link></entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>&lt;&lt; &gt;&gt;</entry>
       <entry>
        <link linkend="language.operators.bitwise">bitwise</link>
       </entry>
      </row>
      <row>
       <entry>non-associatif</entry>
       <entry>&lt; &lt;= &gt; &gt;= &lt;&gt;</entry>
       <entry>
        <link linkend="language.operators.comparison">comparaison</link>
       </entry>
      </row>
      <row>
       <entry>non-associatif</entry>
       <entry>== != === !==</entry>
       <entry>
        <link linkend="language.operators.comparison">comparaison</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>&amp;</entry>
       <entry>
        <link linkend="language.operators.bitwise">bitwise</link>&listendand;
        <link linkend="language.references">références</link></entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>^</entry>
       <entry>
        <link linkend="language.operators.bitwise">bitwise</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>|</entry>
       <entry>
        <link linkend="language.operators.bitwise">bitwise</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>&amp;&amp;</entry>
       <entry>
        <link linkend="language.operators.logical">logique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>||</entry>
       <entry>
        <link linkend="language.operators.logical">logique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>? :</entry>
       <entry>
        <link linkend="language.operators.comparison.ternary">ternaire</link>
       </entry>
      </row>
      <row>
       <entry>droite</entry>
       <entry>
        = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= =&gt;
       </entry>
       <entry>
        <link linkend="language.operators.assignment">assignation</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>and</entry>
       <entry>
        <link linkend="language.operators.logical">logique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>xor</entry>
       <entry>
        <link linkend="language.operators.logical">logique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>or</entry>
       <entry>
        <link linkend="language.operators.logical">logique</link>
       </entry>
      </row>
      <row>
       <entry>gauche</entry>
       <entry>,</entry>
       <entry>plusieurs utilisations</entry>
      </row>
     </tbody>
    </tgroup>
    </table>
  </para>
  <para>
   Pour les opérateurs à précédence égale, l'associativité de gauche signifie que
   l'expression est évaluée de gauche à droite, l'associativité de droite, l'inverse.
   <example>
    <title>Associativité</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5

// Le fait de mélanger ++ et + produit un comportement indéfini
$a = 1;
echo ++$a + $a++; // peut afficher 4 ou 5
?>
]]>
    </programlisting>
   </example>
   Utiliser des parenthèses, même lorsque cela n'est pas requis, permet d'augmenter la lisibilité du code.
  </para>
  <note>
   <para>
    Bien que <literal>=</literal> soit prioritaire sur
    la plupart des opérateurs, PHP va tout de même exécuter des
    expressions comme : <literal>if (!$a = foo())</literal>.
    Dans cette situation, le résultat de <literal>foo()</literal>
    sera placé dans la variable <varname>$a</varname>.
   </para>
  </note>
 </sect1>
 
 <sect1 xml:id="language.operators.arithmetic">
  <title>Les opérateurs arithmétiques</title>
  <simpara>
   Vous rappelez-vous des opérations élémentaires
   apprises à l'école ? Les opérateurs arithmétiques fonctionnent comme elles.
  </simpara>
  <table>
   <title>Opérations élémentaires</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Exemple</entry>
      <entry>Nom</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-$a</entry>
      <entry>Négation</entry>
      <entry>Opposé de <varname>$a</varname>.</entry>
     </row>
     <row>
      <entry>$a + $b</entry>
      <entry>Addition</entry>
      <entry>Somme de <varname>$a</varname> et <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a - $b</entry>
      <entry>Soustraction</entry>
      <entry>
       Différence de <varname>$a</varname> et <varname>$b</varname>.
      </entry>
     </row>
     <row>
      <entry>$a * $b</entry>
      <entry>Multiplication</entry>
      <entry>Produit de <varname>$a</varname> et <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a / $b</entry>
      <entry>Division</entry>
      <entry>
       Quotient de <varname>$a</varname> et <varname>$b</varname>.
      </entry>
     </row>
     <row>
      <entry>$a % $b</entry>
      <entry>Modulo</entry>
      <entry>
       Reste de <varname>$a</varname> divisé par <varname>$b</varname>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   L'opérateur de division ("/") retourne une valeur à virgule flottante
   sauf si les 2 opérandes sont des entiers (ou une &string; qui a été convertie
   en entiers) et cette valeur est toujours divisible, auquel cas une valeur
   entière sera retournée.
  </simpara>
  <simpara>
   Les opérandes du modulo sont converties en entiers (en supprimant la partie
   décimale) avant exécution.
  </simpara>
  <para>
   Le résultat de l'opération modulo <literal>%</literal> a le même signe que
   le premier opérande, ansi le résultat de <literal>$a % $b</literal> aura le signe de
   <varname>$a</varname>. Par exemple:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // affiche 2
echo (5 % -3)."\n";          // affiche 2
echo (-5 % 3)."\n";          // affiche -2
echo (-5 % -3)."\n";         // affiche -2

?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Voir aussi le manuel sur les
   <link linkend="ref.math">fonctions mathématiques</link>.
  </simpara>
  
 </sect1>
 
 <sect1 xml:id="language.operators.assignment">
  <title>Les opérateurs d'assignation</title>
  <simpara>
   L'opérateur d'assignation le plus simple est le signe "=".
   Le premier réflexe est de penser que ce signe veut dire
   "égal à". Ce n'est pas le cas. Il signifie que
   l'opérande de gauche se voit affecter la valeur de
   l'expression qui est à droite du signe égal.
  </simpara>
  <para>
   La valeur d'une expression d'assignation est la valeur
   assignée. Par exemple, la valeur de l'expression
   '<literal>$a = 3</literal>' est la valeur 3. Cela permet d'utiliser
   des astuces telles que :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = ($b = 4) + 5;
// $a est maintenant égal à 9, et $b vaut 4.
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Pour les <type>arrays</type>, assigner une valeur à une clé donnée est effectué au moyen
   de l'opérateur "=&gt;". La <link linkend="language.operators.precedence">précédence</link>
   de cet opérateur est la même que celle des opérateurs d'assignation.
  </para>
  <para>
   En plus du simple opérateur d'assignation, il existe des
   "opérateurs combinés" pour tous les opérateurs
   <link linkend="language.operators">arithmétiques</link>,
   l'union de tableaux et pour les opérateurs sur les
   chaînes de caractères. Cela permet d'utiliser
   la valeur d'une variable dans une expression et d'affecter le
   résultat de cette expression à cette variable.
   Par exemple :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$a += 5; // affecte la valeur 8 à la variable $a correspond à l'instruction '$a = $a + 5';
$b = "Bonjour ";
$b .= " tout le monde!";  // affecte la valeur "Bonjour tout le monde!" à
                                    //  la variable $b
                                    //  identique à $b = $b." tout le monde!";

?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   On peut noter que l'assignation copie le contenu de la variable originale
   dans la nouvelle variable (assignation par valeur), ce qui fait que les
   changements de valeur d'une variable ne modifieront pas la valeur de
   l'autre. Cela peut se révéler important lors de la copie d'un grand tableau
   durant une boucle.
  </para>
  <para>
   Une exception au comportement d'assignation par valeur en PHP est le type
   <type>object</type>, ceux-ci sont assignés par référence dans PHP 5.
   La copie d'objet doit être explicitement demandée grâce au mot-clé
   <link linkend="language.oop5.cloning">clone</link>.
  </para>
  
  <sect2 xml:id="language.operators.assignment.reference">
   <title>Assignation par référence</title>
   <para>
    L'assignation par référence est aussi supportée, au moyen de la syntaxe
    "<computeroutput>$var = &amp;$othervar;</computeroutput>". L'assignation par
    référence signifie que les deux variables pointent vers le même conteneur de
    donnée, rien n'est copié nul part.
   </para>
   <para>
    <example>
     <title>Assignation par référence</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b est une référence à $a

print "$a\n"; // affiche 3
print "$b\n"; // affiche 3

$a = 4; // change $a

print "$a\n"; // affiche 4
print "$b\n"; // affiche 4 aussi, car $b est une référence à $a, qui a été
              // changée
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Depuis PHP 5, l'opérateur <link linkend="language.oop5.basic.new">new</link>
     retourne une référence automatiquement, donc assigner le résultat de
     <link linkend="language.oop5.basic.new">new</link> par référence retournera une
     erreur <constant>E_DEPRECATED</constant> depuis PHP 5.3, et une erreur de niveau
     <constant>E_STRICT</constant> avant PHP 5.3.
    </para>
    <para>
     Par exemple, ce code génère un message d'erreur:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* La ligne suivante génère une erreur dont le message est:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Plus d'informations sur le références et leurs utilisations possibles peuvent être
     trouvées dans la section du manuel <link linkend="language.references">Les références
     expliquées</link>.
    </para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="language.operators.bitwise">
  <title>Opérateurs sur les bits</title>
  <simpara>
   Les opérateurs sur les bits vous permettent de
   manipuler les bits dans un entier. 
  </simpara>
  <table>
   <title>Les opérateurs sur les bits</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Exemple</entry>
      <entry>Nom</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><userinput>$a &amp; $b</userinput></entry>
      <entry>And (Et)</entry>
      <entry>
       Les bits positionnés à 1 dans <varname>$a</varname> ET dans
       <varname>$b</varname> sont positionnés à 1.
      </entry>
     </row>
     <row>
      <entry><userinput>$a | $b</userinput></entry>
      <entry>Or (Ou)</entry>
      <entry>
       Les bits positionnés à 1 dans <varname>$a</varname> OU <varname>$b</varname>
       sont positionnés à 1.
      </entry>
     </row>
     <row>
      <entry><userinput>$a ^ $b</userinput></entry>
      <entry>Xor (ou exclusif)</entry>
      <entry>
       Les bits positionnés à 1 dans <varname>$a</varname> OU dans
       <varname>$b</varname> mais pas dans les deux sont positionnés à 1.
      </entry>
     </row>
     <row>
      <entry><userinput>~ $a</userinput></entry>
      <entry>Not (Non)</entry>
      <entry>
       Les bits qui sont positionnés à 1 dans <varname>$a</varname>
       sont positionnés à 0, et vice-versa.
      </entry>
     </row>
     <row>
      <entry><userinput>$a &lt;&lt; $b</userinput></entry>
      <entry>Décalage à gauche</entry>
      <entry>
       Décale les bits de <varname>$a</varname>, <varname>$b</varname> fois
       sur la gauche (chaque décalage équivaut à une multiplication par 2).
      </entry>
     </row>
     <row>
      <entry><userinput>$a &gt;&gt; $b</userinput></entry>
      <entry>Décalage à droite</entry>
      <entry>
       Décalage les bits de <varname>$a</varname>, <varname>$b</varname> fois
       par la droite (chaque décalage équivaut à une division par 2).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Le décalage de bits en PHP est arithmétique.
   Les bits qui sont décalés hors de l'entier sont perdus.
   Les décalages à gauche font apparaître des zéros à droite,
   tandis que le bit de signe est décalé à gauche, ce qui signifie
   que le signe de l'entier n'est pas préservé.
   Les décalages à droite décalent aussi le bit de signe sur la
   droite, ce qui signifie que le signe est préservé.
  </para>
  
  <para>
   Utilisez des parenthèses pour vous assurer que la 
   <link linkend="language.operators.precedence">précédence</link>
   voulue est bien appliquée. Par exemple, 
   <literal>$a &amp; $b == true</literal> applique d'abord 
   l'égalité, et ensuite le ET logique, alors que 
   <literal>($a &amp; $b) == true</literal> applique d'abord le
   ET logique, puis l'égalité.
  </para>
  
  <para>
   Prenez garde aux transtypages. Si les deux paramètres,
   de chaque coté de l'opérateur, sont des chaînes, l'opérateur
   de bit va opérer sur les valeurs ASCII des chaînes.
  </para>
  
  <para>
   <informalexample>
    <para>
     <literallayout>
      Le rapport d'erreur de PHP utilise des champs de bits,
      qui sont une illustration de l'extinction des bits.
      Pour afficher les erreurs, sauf les notices, les
      instructions du php.ini sont : 
      <userinput>E_ALL &amp; ~E_NOTICE</userinput>
     </literallayout>
    </para>
    <para>
     <literallayout>
      Cela se comprend en comparant avec E_ALL :
      <computeroutput>00000000000000000111011111111111</computeroutput>
      Puis en éteignant la valeur de E_NOTICE...
      <computeroutput>00000000000000000000000000001000</computeroutput>
      ... et en l'inversant via <literal>~</literal>:
      <computeroutput>11111111111111111111111111110111</computeroutput>
      Finalement, on utilise le ET logique (&amp;) pour lire les bits activés
      dans les deux valeurs : 
      <computeroutput>00000000000000000111011111110111</computeroutput>
     </literallayout>
    </para>
    <para>
     <literallayout>
      Un autre moyen d'arriver à ce résultat est d'utiliser 
      le OU exclusif (<literal>^</literal>), qui cherche
      les bits qui ne sont activés que dans l'une ou l'autre des
      valeurs, exclusivement : 
      <userinput>E_ALL ^ E_NOTICE</userinput>
     </literallayout>
    </para>
   </informalexample>
  </para>
  <para>
   <informalexample>
    <para>
     <literallayout>
      error_reporting peut aussi être utilisé pour 
      illustrer l'activation de bits. Pour afficher
      uniquement les erreurs et les erreurs recouvrables,
      on utilise :
      <userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
     </literallayout>
    </para>
    <para>
     <literallayout>
      Cette approche combine E_ERROR
      <computeroutput>00000000000000000000000000000001</computeroutput>
      et E_RECOVERABLE_ERROR
      <computeroutput>00000000000000000001000000000000</computeroutput>
      Avec l'opérateur OR (<literal>|</literal>) pour s'assurer que
      les bits sont activés dans l'une ou l'autre valeur : 
      <computeroutput>00000000000000000001000000000001</computeroutput>
     </literallayout>
    </para>
   </informalexample>
  </para>
  <para>
   <example>
    <title>Opérations sur les bits et les entiers</title>
    <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignorez cette partie,
 * c'est juste du formatage pour clarifier les résultats
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 resultat       valeur        test
 ---------     ---------  -- ---------
EOH;


/*
 * Voici les exemples
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
---------     ---------  -- ---------
 resultat       valeur        test
 ---------     ---------  -- ---------
 Bitwise AND 
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR 
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR) 
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Opération sur les bits et les chaînes</title>
    <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Affiche '5'

echo "12" ^ "9"; // Affiche le caractère d'effacement (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Affiche les valeurs ASCII #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Affiche 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Affiche 1
              // ((int)"2") ^ 3 == 1
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Décalage de bits sur les entiers</title>
    <programlisting role="php">
<![CDATA[
<?php
/*
 * Voici quelques exemples
 */

echo "\n--- Décalages à droite sur des entiers positifs ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copie du bit de signe maintenant à gauche');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'des bits sont sortis par la droite');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'même résultat que ci-dessus : pas de décalage au dela de 0');


echo "\n--- Décalages à droite sur des entiers négatifs ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copie du bit de signe maintenant à gauche');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'des bits sont sortis par la droite');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'même résultat que ci-dessus : pas de décalage au dela de -1');


echo "\n--- Décalages à gauche sur des entiers positifs ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'complément de zéros à droite');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'le bit de signe est sorti');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'des bits sont sortis à gauche');


echo "\n--- Décalages à gauche sur des entiers négatifs ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'complément de zéros à droite');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'des bits sont sortis à gauche, y compris le bit de signe');


/*
 * Ignorez cette section
 * Elle contient du code pour le formatage de cet exemple
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression : %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Décimal :\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binaire :\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " Note : $note\n";
    }

    echo "\n";
}
?>
]]>
    </programlisting>
    &example.outputs.32bit;
    <screen>
<![CDATA[

--- Décalages à droite sur des entiers positifs ---
Expression : 2 = 4 >> 1
 Décimal :
  val=4
  res=2
 Binaire :
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 Note : copie du bit de signe maintenant à gauche

Expression : 1 = 4 >> 2
 Décimal :
  val=4
  res=1
 Binaire :
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression : 0 = 4 >> 3
 Décimal :
  val=4
  res=0
 Binaire :
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 Note : des bits sont sortis par la droite

Expression : 0 = 4 >> 4
 Décimal :
  val=4
  res=0
 Binaire :
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 Note : même résultat que ci-dessus : pas de décalage au dela de 0


--- Décalages à droite sur des entiers négatifs ---
Expression : -2 = -4 >> 1
 Décimal :
  val=-4
  res=-2
 Binaire :
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 Note : copie du bit de signe à gauche

Expression : -1 = -4 >> 2
 Décimal :
  val=-4
  res=-1
 Binaire :
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 Note : des bits sont sortis par la droite

Expression : -1 = -4 >> 3
 Décimal :
  val=-4
  res=-1
 Binaire :
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 Note : même résultat que ci-dessus : pas de décalage au dela de -1


--- Décalages à gauche sur des entiers positifs ---
Expression : 8 = 4 << 1
 Décimal :
  val=4
  res=8
 Binaire :
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 Note : complément de zéros à droite

Expression : 1073741824 = 4 << 28
 Décimal :
  val=4
  res=1073741824
 Binaire :
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression : -2147483648 = 4 << 29
 Décimal :
  val=4
  res=-2147483648
 Binaire :
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 Note : le bit de signe est sorti

Expression : 0 = 4 << 30
 Décimal :
  val=4
  res=0
 Binaire :
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 Note : des bits sont sortis à gauche


--- Décalages à gauche sur des entiers négatifs ---
Expression : -8 = -4 << 1
 Décimal :
  val=-4
  res=-8
 Binaire :
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 Note : complément de zéros à droite

Expression : -2147483648 = -4 << 29
 Décimal :
  val=-4
  res=-2147483648
 Binaire :
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression : 0 = -4 << 30
 Décimal :
  val=-4
  res=0
 Binaire :
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 Note : des bits sont sortis à gauche, y compris le bit de signe
]]>
    </screen>
    &example.outputs.64bit;
    <screen>
<![CDATA[

--- Décalages à droite sur des entiers positifs ---
Expression : 2 = 4 >> 1
 Décimal :
  val=4
  res=2
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 Note : copie du bit de signe maintenant à gauche

Expression : 1 = 4 >> 2
 Décimal :
  val=4
  res=1
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression : 0 = 4 >> 3
 Décimal :
  val=4
  res=0
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 Note : des bits sont sortis par la droite

Expression : 0 = 4 >> 4
 Décimal :
  val=4
  res=0
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 Note : même résultat que ci-dessus : pas de décalage au dela de 0


--- Décalages à droite sur des entiers négatifs ---
Expression : -2 = -4 >> 1
 Décimal :
  val=-4
  res=-2
 Binaire :
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 Note : copie du bit de signe maintenant à gauche

Expression : -1 = -4 >> 2
 Décimal :
  val=-4
  res=-1
 Binaire :
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 Note : des bits sont sortis par la droite

Expression : -1 = -4 >> 3
 Décimal :
  val=-4
  res=-1
 Binaire :
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 Note : même résultat que ci-dessus : pas de décalage au dela de -1


--- Décalage à gauche sur les entiers négatifs ---
Expression : 8 = 4 << 1
 Décimal :
  val=4
  res=8
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 Note : complément de zéros à droite

Expression : 4611686018427387904 = 4 << 60
 Décimal :
  val=4
  res=4611686018427387904
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression : -9223372036854775808 = 4 << 61
 Décimal :
  val=4
  res=-9223372036854775808
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 Note : le bit de signe est sorti

Expression : 0 = 4 << 62
 Décimal :
  val=4
  res=0
 Binaire :
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 Note : des bits sont sortis à gauche


--- Décalage à gauche sur les entiers négatifs ---
Expression : -8 = -4 << 1
 Décimal :
  val=-4
  res=-8
 Binaire :
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 Note : complément de zéros à droite

Expression : -9223372036854775808 = -4 << 61
 Décimal :
  val=-4
  res=-9223372036854775808
 Binaire :
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression : 0 = -4 << 62
 Décimal :
  val=-4
  res=0
 Binaire :
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 Note : des bits sont sortis à gauche, y compris le bit de signe
]]>
    </screen>
   </example>
  </para>
  <warning>
   <para>
    N'effectuez pas de décalage à droite de plus de 32 bits sur les systèmes
    32 bits. N'effectuez pas de décalage à gauche dans le cas où le résultat
    est un nombre plus long que 32 bits.
    Utilisez les fonctions de l'extension gmp pour les manipulations
    sur les bits, lorsque les entiers dépassent PHP_INT_MAX.
   </para>
  </warning>
  <para>
   Voyez aussi
   <function>pack</function>,
   <function>unpack</function>,
   <function>gmp_and</function>,
   <function>gmp_or</function>,
   <function>gmp_xor</function>,
   <function>gmp_testbit</function>,
   <function>gmp_clrbit</function>
  </para>
 </sect1>
 
 <sect1 xml:id="language.operators.comparison">
  <title>Opérateurs de comparaison</title>
  <simpara>
   Les opérateurs de comparaison, comme leur nom l'indique,
   vous permettent de comparer deux valeurs. Vous devriez également être
   intéressés par les
   <link linkend="types.comparisons">tables de comparaisons de types</link>,
   car ils montrent des exemples de beaucoup de types de comparaisons.
  </simpara>
  <table>
   <title>Opérateurs de comparaison</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Exemple</entry>
      <entry>Nom</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>$a == $b</entry>
      <entry>Egal</entry>
      <entry>&true; si <varname>$a</varname> est égal à
       <varname>$b</varname> après le transtypage.</entry>
     </row>
     <row>
      <entry>$a === $b</entry>
      <entry>Identique</entry>
      <entry>
       &true; si <varname>$a</varname> est égal à <varname>$b</varname> et
       qu'ils sont de même type.
      </entry>
     </row>
     <row>
      <entry>$a != $b</entry>
      <entry>Différent</entry>
      <entry>&true; si <varname>$a</varname> est différent de
       <varname>$b</varname> après le transtypage.</entry>
     </row>
     <row>
      <entry>$a &lt;&gt; $b</entry>
      <entry>Différent</entry>
      <entry>&true; si <varname>$a</varname> est différent de
       <varname>$b</varname> après le transtypage.</entry>
     </row>
     <row>
      <entry>$a !== $b</entry>
      <entry>Différent</entry>
      <entry>
       &true; si <varname>$a</varname> est différent de <varname>$b</varname>
       ou bien s'ils ne sont pas du même type.
      </entry>
     </row>
     <row>
      <entry>$a &lt; $b</entry>
      <entry>Plus petit que</entry>
      <entry>&true; si <varname>$a</varname> est strictement plus petit que
       <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &gt; $b</entry>
      <entry>Plus grand</entry>
      <entry>&true; si <varname>$a</varname> est strictement plus grand que
       <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &lt;= $b</entry>
      <entry>Inférieur ou égal</entry>
      <entry>&true; si <varname>$a</varname> est plus petit ou égal à
       <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &gt;= $b</entry>
      <entry>Supérieur ou égal</entry>
      <entry>&true; si <varname>$a</varname> est plus grand ou égal à
       <varname>$b</varname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Si vous comparez un nombre avec une chaîne ou bien que la comparaison
   implique des chaînes numériques, alors chaque chaîne sera
   <link linkend="language.types.string.conversion">convertie en un nombre</link>
   et la comparaison sera effectuée numériquement. Ces règles s'appliquent également
   à l'instruction <link linkend="control-structures.switch">switch</link>.
   La comparaison de type n'a pas de place lorsque la comparaison est === ou !==
   vu que ceci engendre aussi bien une comparaison de type que de valeur.
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // jamais évalué parce que "a" est déjà trouvé avec 0
    echo "a";
    break;
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  
  <para>
   Pour les différents types, la comparaison est faite en suivant
   la table suivante (dans l'ordre).
  </para>
  <table xml:id="language.operators.comparison.types">
   <title>Comparaison avec plusieurs types</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Type de l'opérande 1</entry>
      <entry>Type de l'opérande 2</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><type>null</type> ou <type>chaîne de caractères</type></entry>
      <entry><type>string</type></entry>
      <entry>Convertit &null; en "", comparaison numérique ou lexicale</entry>
     </row>
     <row>
      <entry><type>booléen</type> ou <type>null</type></entry>
      <entry>N'importe quoi</entry>
      <entry>Convertit en <type>booléen</type>, &false; &lt; &true;</entry>
     </row>
     <row>
      <entry><type>objet</type></entry>
      <entry><type>objet</type></entry>
      <entry>Les classes internes peuvent définir leur propre méthode de
       comparaison; différentes classes ne sont pas comparables; entre objets
       de même classe, PHP a son propre
       <link linkend="language.oop5.object-comparison">comportement</link></entry>
     </row>
     <row>
      <entry>
       <type>chaîne de caractères</type>, <type>ressource</type> ou
       <type>nombre</type>
      </entry>
      <entry>
       <type>chaîne de caractères</type>, <type>ressource</type> ou
       <type>nombre</type>
      </entry>
      <entry>
       Transforme les chaînes de caractères et les ressources en nombres
      </entry>
     </row>
     <row>
      <entry><type>tableaux</type></entry>
      <entry><type>tableaux</type></entry>
      <entry>Le tableau avec le moins de membres est plus petit, si la clé de
       l'opérande 1 n'est pas trouvée dans l'opérande 2, alors les tableaux ne
       sont pas comparables, sinon la comparaison se fait valeur par valeur
       (voir l'exemple suivant)
      </entry>
     </row>
     <row>
      <entry><type>tableau</type></entry>
      <entry>N'importe quoi</entry>
      <entry>Le <type>tableau</type> est toujours plus grand</entry>
     </row>
     <row>
      <entry><type>objet</type></entry>
      <entry>N'importe quoi</entry>
      <entry>L'<type>objet</type> est toujours plus grand</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   <example>
    <title>Transcription des comparaisons standards des tableaux</title>
    <programlisting role="php">
<![CDATA[
<?php
// Les tableaux sont comparés comme ceci avec les opérateurs standards de comparaison
function standard_array_compare($op1, $op2)
{
   if (count($op1) < count($op2)) {
      return -1; // $op1 < $op2
   } elseif (count($op1) > count($op2)) {
      return 1; // $op1 > $op2
   }
   foreach ($op1 as $key => $val) {
      if (!array_key_exists($key, $op2)) {
         return null; // incomparable
      } elseif ($val < $op2[$key]) {
         return -1;
      } elseif ($val > $op2[$key]) {
         return 1;
      }
   }
   return 0; // $op1 == $op2
}
?>
  ]]>
    </programlisting>
   </example>
  </para>
  
  <para>
   Voir aussi
   <function>strcasecmp</function>,
   <function>strcmp</function>
   <link linkend="language.operators.array">les opérateurs de tableaux</link>,
   et le chapitre sur les <link linkend="language.types">types</link>.
  </para>
  
  <warning>
   <title>Comparaison de nombre à virgule flottante</title>
   
   <para>
    A cause de la façon dont les nombres à virgule flottante sont représentés
    en interne, vous ne devriez pas tester l'égalité entre deux nombres
    de type <type>float</type>.
   </para>
   
   <para>
    Voyez la documentation de <type>float</type> pour plus d'informations.
   </para>
  </warning>
  
  <sect2 xml:id="language.operators.comparison.ternary">
   <title>L'opérateur ternaire</title>
   <para>
    Un autre opérateur conditionnel est l'opérateur
    ternaire (":?").
    <example>
     <title>Assignation d'une valeur par défaut</title>
     <programlisting role="php">
<![CDATA[
<?php
// Exemple d'utilisation pour l'opérateur ternaire
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// La ligne ci-dessus est identique à la condition suivante :
if (empty($_POST['action'])) {
   $action = 'default';
} else {
   $action = $_POST['action'];
}

?>
]]>
     </programlisting>
    </example>
    L'expression <literal>(expr1) ? (expr2) : (expr3)</literal>
    est évaluée à <replaceable>expr2</replaceable> si
    <replaceable>expr1</replaceable> est évaluée à &true;, et
    <replaceable>expr3</replaceable> si
    <replaceable>expr1</replaceable> est évaluée à &false;.
   </para>
   <para>
    Depuis PHP 5.3, il est possible d'omettre la partie centrale de l'opérateur
    ternaire. L'expression <literal>expr1 ?: expr3</literal> retourne
    <replaceable>expr1</replaceable> si <replaceable>expr1</replaceable>
    vaut &true;, et <replaceable>expr3</replaceable> sinon.
   </para>
   <note>
    <simpara>
     Notez que l'opérateur ternaire est une instruction, et il n'est pas
     évalué en tant que variable, mais en tant que résultat de l'instruction.
     Il est important de savoir si vous voulez retourner une variable
     par référence. L'instruction
     <literal>return $var == 42 ? $a : $b;</literal>
     dans une fonction retournée par référence ne fonctionnera donc pas et une
     alerte est émise.
    </simpara>
   </note>
   <note>
    <para>
     Il est recommandé de ne pas "empiler" les expressions ternaires.
     Le comportement de PHP lors de l'utilisation de plus d'un opérateur
     ternaire dans une seule instruction n'est pas évident :
     <example>
      <title>Comportement de PHP</title>
      <programlisting role="php">
<![CDATA[
<?php
// A première vue, ce qui suit devrait retourner 'true'
echo (true?'true':false?'t':'f');

// cependant, l'expression ci-dessus retournera 't'
// car l'expression ternaire est évaluée de gauche à droite

// l'expression suivante est une version plus évidente du même code
echo ((true ? 'true' : false) ? 't' : 'f');

// ici, vous pouvez voir que la première expression est évaluée à 'true',
// ce qui fait qu'elle est évaluée à (bool)true, ce qui retourne la branche
// 'vraie' de la seconde expression ternaire.
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
  </sect2>
 </sect1>
 
 <sect1 xml:id="language.operators.errorcontrol">
  <title>Opérateur de contrôle d'erreur</title>
  <simpara>
   PHP supporte un opérateur de contrôle d'erreur : c'est @.
   Lorsque cet opérateur est ajouté en préfixe d'une
   expression PHP, les messages d'erreur qui peuvent être
   générés par cette expression seront ignorés.
  </simpara>
  <simpara>
   Si vous avez défini un gestionnaire d'erreurs personnalisé
   avec la fonction <function>set_error_handler</function>,
   alors il sera toujours appelé, mais ce gestionnaire d'erreurs
   peut (et doit) appeler la fonction <function>error_reporting</function>
   qui devra retourner 0 lorsque l'appel qui a émis l'erreur
   était précédé d'un @.
  </simpara>
  <simpara>
   Si l'option
   <link linkend="ini.track-errors"><option>track_errors</option></link>
   est activée, les messages d'erreurs générés
   par une expression seront sauvés dans la variable globale
   <varname>$php_errormsg</varname>.
   Cette variable sera écrasée à chaque erreur.
   Il faut alors la surveiller souvent pour pouvoir l'utiliser.
  </simpara>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
/* Erreur intentionnelle (le fichier n'existe pas): */
$mon_fichier = @file ('non_persistent_file') or
    die ("Impossible d'ouvrir le fichier : L'erreur est : '$php_errormsg'");

// Cela fonctionne avec n'importe quelle expression, pas seulement les fonctions
  $value = @$cache[$key];
// la ligne ci-dessus n'affichera pas d'alerte si la clé $key du tableau n'existe pas

?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <note>
   <simpara>
    L'opérateur @ ne fonctionne qu'avec les
    <link linkend="language.expressions">expressions</link>. La règle
    générale de fonctionnement est la suivante : si vous pouvez prendre
    la valeur de quelque chose, vous pouvez le préfixer avec @. Par exemple,
    vous pouvez ajouter @ aux variables, fonctions, à
    <function>include</function>,
    aux constantes, etc. Vous ne pourrez pas le faire avec des éléments de
    langage tels que les classes, <literal>if</literal> et &foreach;, etc.
   </simpara>
  </note>
  <simpara>
   Voir aussi
   <function>error_reporting</function> et la section sur la
   <link linkend="ref.errorfunc">gestion d'erreurs</link>.
  </simpara>
  <warning>
   <para>
    En fait, l'opérateur "@" va aussi désactiver les rapports
    d'erreurs critiques, qui stoppent l'exécution du script. Entre autres,
    si vous utilisez "@" pour supprimer les erreurs de certaines
    fonctions, et que cette fonction n'existe pas, ou qu'elle
    a été mal orthographiée, vous n'aurez aucune indication.
   </para>
  </warning>
 </sect1>
 
 <sect1 xml:id="language.operators.execution">
  <title>Opérateur d'exécution</title>
  <para>
   PHP supporte un opérateur d'exécution : guillemets obliques
   ("``"). Notez bien qu'il ne s'agit pas de guillemets simples. PHP
   essaie d'exécuter le contenu de ces guillemets obliques comme une commande
   shell. Le résultat sera retourné (i.e. : il ne sera pas simplement envoyé
   à la sortie standard, il peut être assigné à une variable). Utilisez les
   guillemets obliques revient à utiliser la fonction
   <function>shell_exec</function>.
   <example>
    <title>Opérateur d'exécution</title>
    <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
    </programlisting>
   </example>
  </para>
  <note>
   <para>
    Cet opérateur est désactivé lorsque le
    &safemode; est activé ou bien que la fonction
    <function>shell_exec</function> est désactivée.
   </para>
  </note>
  <note>
   <para>
    Contrairement à d'autres langages, les guillemets obliques
    ne peuvent pas être utilisés dans une chaîne entourée de
    guillemets doubles.
   </para>
  </note>
  <para>
   Voir aussi le manuel à la section sur les
   <link linkend="ref.exec">fonctions d'exécution système</link>,
   <function>popen</function>,
   <function>proc_open</function> et
   <link linkend="features.commandline">l'utilisation de PHP en ligne de commande</link>.
  </para>
 </sect1>
 
 <sect1 xml:id="language.operators.increment">
  <title>Opérateurs d'incrémentation et décrémentation</title>
  <para>
   PHP supporte les opérateurs de pre- et post-incrémentation et
   décrémentation, comme en langage C.
  </para>
  <note>
   <simpara>
    Les opérateurs d'incrémentation/décrémentation n'affectent pas les valeurs
    booléennes. La décrémentation des valeurs &null; n'a également aucun effet,
    mais leur incrémentation donnera comme résultat <literal>1</literal>.
   </simpara>
  </note>
  <table>
   <title>Opérateurs d'incrémentation et décrémentation</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Exemple</entry>
      <entry>Nom</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>++$a</entry>
      <entry>Pre-incrémente</entry>
      <entry>
       Incrémente <varname>$a</varname> de 1, puis retourne
       <varname>$a</varname>.
      </entry>
     </row>
     <row>
      <entry>$a++</entry>
      <entry>Post-incrémente</entry>
      <entry>Retourne <varname>$a</varname>, puis incrémente <varname>$a</varname> de 1.</entry>
     </row>
     <row>
      <entry>--$a</entry>
      <entry>Pré-décrémente</entry>
      <entry>
       Décrémente <varname>$a</varname> de 1, puis retourne
       <varname>$a</varname>.
      </entry>
     </row>
     <row>
      <entry>$a--</entry>
      <entry>Post-décrémente</entry>
      <entry>
       Retourne <varname>$a</varname>, puis décrémente
       <varname>$a</varname> de 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Voici un exemple simple :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo '<h3>Post-incrémentation</h3>';
$a = 5;
echo "Devrait valoir  5: " . $a++ . "<br />\n";
echo "Devrait valoir  6: " . $a . "<br />\n";
echo '<h3>Pre-incrémentation</h3>';
$a = 5;
echo "Devrait valoir  6: " . ++$a . "<br />\n";
echo "Devrait valoir  6: " . $a . "<br />\n";
echo '<h3>Post-décrémentation</h3>';
$a = 5;
echo "Devrait valoir  5: " . $a-- . "<br />\n";
echo "Devrait valoir  4: " . $a . "<br />\n";
echo '<h3>Pre-décrémentation</h3>';
$a = 5;
echo "Devrait valoir  4: " . --$a . "<br />\n";
echo "Devrait valoir  4: " . $a . "<br />\n";
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   PHP suit les conventions de Perl pour la gestion des opérateurs
   arithmétiques sur les variables de caractères et non pas celle du C.
   Par exemple, en PHP et en Perl, <literal>$a = 'Z'; $a++;</literal>
   transforme <literal>$a</literal> en <literal>'AA'</literal>,
   alors qu'en C, <literal>a = 'Z'; a++;</literal> transforme
   <literal>a</literal> en <literal>'['</literal> (la valeur ASCII de
   <literal>'Z'</literal> est 90, la valeur ASCII de <literal>'['</literal>
   est 91). Notez que les variables de caractères peuvent être incrémentées
   mais pas décrémentées, mais aussi que seuls les caractères ASCII pleins
   (a-z et A-Z) sont supportés.
   L'incrémentation/décrémentation d'autres variables de caractères n'a
   aucun effet, la chaîne originale n'est pas modifiée.
   <example>
    <title>Opérations arithmétiques sur un caractère</title>
    <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++) {
  echo ++$i . "\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
    </screen>
   </example>
  </para>
  <para>
   L'incrémentation ou la décrémentation d'un booléen n'a aucun effet.
  </para>
 </sect1>
 
 <sect1 xml:id="language.operators.logical">
  <title>Les opérateurs logiques</title>
  
  <table>
   <title>Les opérateurs logiques</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Exemple</entry>
      <entry>Nom</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>$a and $b</entry>
      <entry>And (Et)</entry>
      <entry>&true; si <varname>$a</varname> ET <varname>$b</varname> valent &true;.</entry>
     </row>
     <row>
      <entry>$a or $b</entry>
      <entry>Or (Ou)</entry>
      <entry>&true; si <varname>$a</varname> OU <varname>$b</varname> valent &true;.</entry>
     </row>
     <row>
      <entry>$a xor $b</entry>
      <entry>XOR</entry>
      <entry>
       &true; si <varname>$a</varname> OU <varname>$b</varname> est &true;,
       mais pas les deux en même temps.
      </entry>
     </row>
     <row>
      <entry>! $a</entry>
      <entry>Not (Non)</entry>
      <entry>&true; si <varname>$a</varname> n'est pas &true;.</entry>
     </row>
     <row>
      <entry>$a &amp;&amp; $b</entry>
      <entry>And (Et)</entry>
      <entry>&true; si <varname>$a</varname> ET <varname>$b</varname> sont &true;.</entry>
     </row>
     <row>
      <entry>$a || $b</entry>
      <entry>Or (Ou)</entry>
      <entry>&true; si <varname>$a</varname> OU <varname>$b</varname> est &true;.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   La raison pour laquelle il existe deux types de "ET" et de "OU"
   est qu'ils ont des priorités différentes. Voir le
   paragraphe
   <link linkend="language.operators.precedence">précédence d'opérateurs</link>.
  </simpara>
  <example>
   <title>Illustration des opérateurs logiques</title>
   <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() ne sera jamais appelée car ces opérateurs s'annulent

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" a un précédence supérieure à "or"

// Le résultat de l'expression (false || true) est assigné à $e
// Agit comme : ($e = (false || true))
$e = false || true;

// La constante false est assignée à $f, puis, true est ignoré
// Agit comme : (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" a un précédence supérieure à "and"

// Le résultat de l'expression (true && false) est assigné à $g
// Agit comme : ($g = (true && false))
$g = true && false;

// La constante true est assignée à $h, puis, false est ignoré
// Agit comme : (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
   </screen>
  </example>
 </sect1>
 
 <sect1 xml:id="language.operators.string">
  <title>Opérateurs de chaînes</title>
  <simpara>
   Il y a deux opérateurs de chaînes de caractères <type>string</type>.
   Le premier est l'opérateur de concaténation ('.'), qui
   retourne la concaténation de ses deux arguments.
   Le second est l'opérateur d'assignation
   concaténant (<literal>.=</literal>). Reportez-vous à
   <link linkend="language.operators.assignment">opérateurs d'assignation</link>
   pour plus de détails.
  </simpara>
  
  <para>
   <example>
    <title>Opérateur de concaténation</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = "Bonjour ";
$b = $a . "Monde !"; // $b contient "Bonjour Monde !"

$a = "Bonjour ";
$a = $a . "Monde !"; // $a contient "Bonjour Monde !"
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Voir aussi les sections du manuel sur
   <link linkend="language.types.string">les types de chaînes de caractères</link> et
   <link linkend="ref.strings">les chaînes de caractères</link>.
  </para>
 </sect1>
 
 <sect1 xml:id="language.operators.array">
  <title>Opérateurs de tableaux</title>
  <table>
   <title>Opérateurs de tableaux</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Exemple</entry>
      <entry>Nom</entry>
      <entry>Résultat</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>$a + $b</entry>
      <entry>Union</entry>
      <entry>Union de <varname>$a</varname> et <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a == $b</entry>
      <entry>Egalité</entry>
      <entry>&true; si <varname>$a</varname> et <varname>$b</varname> contiennent les mêmes paires clés/valeurs.</entry>
     </row>
     <row>
      <entry>$a === $b</entry>
      <entry>Identique</entry>
      <entry>&true; si <varname>$a</varname> et <varname>$b</varname> contiennent les mêmes paires clés/valeurs dans le même ordre et du même type.</entry>
     </row>
     <row>
      <entry>$a != $b</entry>
      <entry>Inégalité</entry>
      <entry>&true; si <varname>$a</varname> n'est pas égal à <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &lt;&gt; $b</entry>
      <entry>Inégalité</entry>
      <entry>&true; si <varname>$a</varname> n'est pas égal à <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a !== $b</entry>
      <entry>Non-identique</entry>
      <entry>&true; si <varname>$a</varname> n'est pas identique à <varname>$b</varname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   L'opérateur <literal>+</literal> retourne le tableau de gauche auquel sont
   ajoutés les éléments du tableau de droite. Pour les clés présentes dans les
   2 tableaux, les éléments du tableau de gauche seront utilisés alors que les
   éléments correspondants dans le tableau de droite seront ignorés.
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "pomme", "b" => "banane");
$b = array("a" =>"poire", "b" => "fraise", "c" => "cerise");

$c = $a + $b; // Union de $a et $b
echo "Union de \$a et \$b : \n";
var_dump($c);

$c = $b + $a; // Union de $b et $a
echo "Union de \$b et \$a : \n";
var_dump($c);
?>
]]>
    </programlisting>
   </informalexample>
   À l'exécution, le script affichera :
   <screen role="php">
<![CDATA[
Union de $a et $b :
array(3) {
  ["a"]=>
  string(5) "pomme"
  ["b"]=>
  string(6) "banane"
  ["c"]=>
  string(6) "cerise"
}
Union de $b et $a :
array(3) {
  ["a"]=>
  string(5) "poire"
  ["b"]=>
  string(6) "fraise"
  ["c"]=>
  string(6) "cerise"
}
]]>
   </screen>
  </para>
  <para>
   Les éléments d'un tableau sont égaux en terme
   de comparaison s'ils ont la même clé et la même valeur.
  </para>
  <para>
   <example>
    <title>Comparer des tableaux</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = array("pomme", "banane");
$b = array(1 => "banane", "0" => "pomme");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Voyez aussi le manuel aux sections
   <link linkend="language.types.array">Tableaux</link> et
   <link linkend="ref.array">fonctions de tableaux</link>.
  </para>
 </sect1>
 
 <sect1 xml:id="language.operators.type">
  <title>Opérateurs de types</title>
  <para>
   <literal>instanceof</literal> est utilisé pour déterminer si une variable PHP
   est un objet instancié d'une certaine
   <link linkend="language.oop5.basic.class">classe</link> :
   <example>
    <title>Utilisation de <literal>instanceof</literal> avec des classes</title>
    <programlisting role="php">
<![CDATA[
<?php
class MaClasse
{
}
class PasMaClasse
{
}
$a = new MaClasse;

var_dump($a instanceof MaClasse);
var_dump($a instanceof PasMaClasse);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(false)
]]>
    </screen>
   </example>
  </para>
  <para>
   <literal>instanceof</literal> peut également être utilisé pour déterminer
   si une variable est un objet instancié d'une classe qui hérite d'une classe parente :
   <example>
    <title>Utilisation de <literal>instanceof</literal> avec des classes héritées</title>
    <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}
class MyClass extends ParentClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
    </screen>
   </example>
  </para>
  <para>
   Pour vérifier si un objet <emphasis>n'est pas</emphasis> une instance d'une classe,
   l'<link linkend="language.operators.logical">opérateur logique <literal>not</literal></link>
   peut être utilisé.
   <example>
    <title>Utilisation de <literal>instanceof</literal> pour vérifier que l'objet
     <emphasis>n'est pas</emphasis> une instance de la classe</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}
$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
    </screen>
   </example>
  </para>
  <para>
   Et finalement, <literal>instanceof</literal> peut être utilisé pour déterminer
   si une variable est un objet instancié d'une classe qui implémente une
   <link linkend="language.oop5.interfaces">interface</link> :
   <example>
    <title>Utilisation de <literal>instanceof</literal> pour une interface</title>
    <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}
class MyClass implements MyInterface
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
    </screen>
   </example>
  </para>
  <para>
   Bien que <literal>instanceof</literal> soit habituellement utilisé avec un nom
   de classe littéral, il peut également être utilisé avec un autre objet ou une chaîne
   représentant une variable :
   <example>
    <title>Utilisation de <literal>instanceof</literal> avec d'autres variables</title>
    <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}
class MyClass implements MyInterface
{
}
$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';
var_dump($a instanceof $b); // $b est un objet de la classe MyClass
var_dump($a instanceof $c); // $c est une chaîne 'MyClass'
var_dump($a instanceof $d); // $d est une chaîne 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
    </screen>
   </example>
  </para>
  <para>
   Il y a quelques pièges à éviter. Avant PHP version 5.1.0,
   <literal>instanceof</literal> appellera <function>__autoload</function>
   si le nom de la classe n'existe pas. De plus, si la classe n'a pas été chargée,
   une erreur fatale sera émise. Ceci peut fonctionner en utilisant une référence
   de classe dynamique, ou une chaîne représentant une variable contenant le nom
   de la classe :
   <example>
    <title>Pas de recherche sur le nom de la classe et une erreur fatale avec
     <literal>instanceof</literal> en PHP 5.0</title>
    <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // no fatal error here
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
    </screen>
   </example>
  </para>
  <simpara>
   L'opérateur <literal>instanceof</literal> a été introduit en PHP 5.
   Avant cette version, <function>is_a</function> était utilisée mais
   <function>is_a</function> est depuis devenue obsolète, en faveur de
   <literal>instanceof</literal>. Notez que depuis PHP 5.3.0, 
   <function>is_a</function> n'est de nouveau plus obsolète.
  </simpara>
  <para>
   Voir aussi
   <function>get_class</function> et
   <function>is_a</function>.
  </para>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
