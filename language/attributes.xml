<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: $ -->
<!-- EN-Revision: 7104ee97ced1768a3231588dfc0bc0d7eb1117ad Maintainer: Serge Status: wip -->
<!-- Reviewed: no -->

<chapter xml:id="language.attributes" xmlns="http://docbook.org/ns/docbook">
 <title>Les attributs</title>
 <sect1 xml:id="language.attributes.overview">
  <title>Introduction</title>
  <?phpdoc print-version-for="attributes"?>

  <para>
   Les attributs permettent d'ajouter des métadonnées sur la déclaration
   des classes, des méthodes, des fonctions, des paramètres,
   des propriétés et des constantes de classe.
    
   Les métadonnées définies par les attributs peuvent être traitées à
   l'exécution grâce à l'<link linkend="book.reflection">API de réflexion</link>.
   Les attributs pourraient donc être considérés comme un langage
   de configuration intégré directement au code. 
  </para>

  <para>
   Avec les attributs, l'implémentation générique d'une fonctionnalité et
   son utilisation concrète dans une application peuvent être découplées.
   D'une certaine manière, il est comparable aux interfaces et à leurs implémentations.
   Mais là où les interfaces et les implémentations concernent le code,
   les attributs concernent les métadonnées.
   Les interfaces peuvent être implémentées par des classes,
   mais les attributs peuvent également être déclarés sur des méthodes,
   des fonctions, des paramètres, des propriétés et des constantes de classe.
   En tant que tels, ils sont plus flexibles que les interfaces. 
  </para>

  <para>
   Un exemple simple consiste à remplacer
   des méthodes facultatives d'une interface par l'utilisation d'attributs.
   Supposons une interface <literal>ActionHandler</literal>
   représentant une opération dans une application, où certaines
   implémentations nécessitent une configuration et d'autres non.
   Au lieu d'exiger l'implémentation d'une méthode <literal>setUp ()</literal>
   de toutes les classes, un attribut peut être utilisé. Un avantage
   de cette approche est que nous pouvons utiliser l'attribut plusieurs fois. 
  </para>

  <example>
   <title>Implémentation de méthodes optionnelles d'une interface avec des attributs</title>
   <programlisting role="php">
<![CDATA[
<?php
interface ActionHandler
{
    public function execute();
}

#[Attribute]
class SetUp {}

class CopyFile implements ActionHandler
{
    public string $fileName;
    public string $targetDirectory;

    #[SetUp]
    public function fileExists()
    {
        if (!file_exists($this->fileName)) {
            throw new RuntimeException("Le fichier n'existe pas");
        }
    }

    #[SetUp]
    public function targetDirectoryExists()
    {
        mkdir($this->targetDirectory);
    }

    public function execute()
    {
        copy($this->fileName, $this->targetDirectory . '/' . basename($this->fileName));
    }
}

function executeAction(ActionHandler $actionHandler)
{
    $reflection = new ReflectionObject($actionHandler);

    foreach ($reflection->getMethods() as $method) {
        $attributes = $method->getAttributes(SetUp::class);

        if (count($attributes) > 0) {
            $methodName = $method->getName();

            $actionHandler->$methodName();
        }
    }

    $actionHandler->execute();
}

$copyAction = new CopyFile();
$copyAction->fileName = "/tmp/foo.jpg";
$copyAction->targetDirectory = "/home/user";

executeAction($copyAction);
]]>
   </programlisting>
  </example>
 </sect1>

 <sect1 xml:id="language.attributes.syntax">
  <title>Syntaxe des attributs</title>

  <para>
   La syntaxe des attributs comporte plusieurs parties. 
   Tout d'abord, une déclaration d'attribut est toujours entourée d'un
   <literal>#[</literal> de début et d'une fin correspondante <literal>]</literal>.
   À l'intérieur, un ou plusieurs attributs sont répertoriés, séparés par des
   virgules. Le nom de l'attribut est un nom non qualifié, qualifié ou complet,
   comme décrit dans
   <link linkend = "language.namespaces.basics">Utilisation des espaces de noms : introduction</link>.
   Les arguments d'attribut sont encadrés par les habituelles parenthèses
   <literal>()</literal> mais sont facultatifs.
   Les arguments des attributs ne peuvent être que des valeurs littérales ou
   des expressions constantes. La syntaxe des arguments positionnels et nommés
   peut être utilisée.
  </para>

  <para>
   Les noms d'attribut et leurs arguments sont résolus en une classe et
   les arguments sont passés à son constructeur, lorsqu'une instance de l'attribut
   est demandée via l'API de réflexion.
   En tant que telle, une classe doit être introduite pour chaque attribut. 
  </para>

  <example>
   <title>Syntaxe de l'attribut</title>

   <programlisting role="php">
<![CDATA[
<?php
// a.php
namespace MyExample;

use Attribute;

#[Attribute]
class MyAttribute
{
    const VALUE = 'value';

    private $value;

    public function __construct($value = null)
    {
        $this->value = $value;
    }
}

// b.php

namespace Another;

use MyExample\MyAttribute;

#[MyAttribute]
#[\MyExample\MyAttribute]
#[MyAttribute(1234)]
#[MyAttribute(value: 1234)]
#[MyAttribute(MyAttribute::VALUE)]
#[MyAttribute(array("key" => "value"))]
#[MyAttribute(100 + 200)]
class Thing
{
}

#[MyAttribute(1234), MyAttribute(5678)]
class AnotherThing
{
}
]]>
   </programlisting>
  </example>
 </sect1>


 <sect1 xml:id="language.attributes.reflection">
  <title>Accès aux attributs avec l'API de réflexion</title>

  <para>
   Pour accéder aux attributs des classes, méthodes, fonctions, paramètres,
   propriétés et constantes de classe, l'API de réflexion fournit la méthode
   <function>getAttributes</function> sur chacun des objets de réflexion
   correspondants. Cette méthode renvoie un tableau d'instances de
   <classname>ReflectionAttribute</classname> qui peuvent être sollicité
   pour obtenir le nom d'attribut, les arguments et pour instancier une représentation
   de l'attribut.
  </para>

  <para>
   La séparation entre l'instance réelle d'attribut et sa représentation reflétée
   améliore la gestion des erreurs concernant
   les classes d'attributs manquants et les arguments mal saisis ou manquants. 
   Ce n'est qu'après avoir appelé <function>newInstance</function> que les objets
   de la classe d'attribut sont instanciés et que la correspondance correcte
   des arguments est validée, pas plus tôt.
  </para>

  <example>
   <title>Accès aux attributs via l'API de réflexion</title>

   <programlisting role="php">
<![CDATA[
<?php

#[Attribute]
class MyAttribute
{
    public $value;

    public function __construct($value)
    {
        $this->value = $value;
    }
}

#[MyAttribute(value: 1234)]
class Thing
{
}

function dumpAttributeData($reflection) {
    $attributes = $reflection->getAttributes();

    foreach ($attributes as $attribute) {
       var_dump($attribute->getName());
       var_dump($attribute->getArguments());
       var_dump($attribute->newInstance());
    }
}

dumpAttributeData(new ReflectionClass(Thing::class));
/*
string(11) "MyAttribute"
array(1) {
  ["value"]=>
  int(1234)
}
object(MyAttribute)#3 (1) {
  ["value"]=>
  int(1234)
}
*/

]]>
   </programlisting>
  </example>

  <para>
   Au lieu de parcourir tous les attributs sur l'instance de réflexion,
   seuls ceux d'une classe d'attributs spécifiques peuvent être récupérés
   en passant le nom de la classe d'attributs recherchés comme argument. 
  </para>

  <example>
   <title>Accès aux attributs spécifique via l'API de réflexion</title>

   <programlisting role="php">
<![CDATA[
<?php

function dumpMyAttributeData($reflection) {
    $attributes = $reflection->getAttributes(MyAttribute::class);

    foreach ($attributes as $attribute) {
       var_dump($attribute->getName());
       var_dump($attribute->getArguments());
       var_dump($attribute->newInstance());
    }
}

dumpAttributeData(new ReflectionClass(Thing::class));
]]>
   </programlisting>
  </example>
 </sect1>

 <sect1 xml:id="language.attributes.classes">
  <title>Déclaration des classes d'attributs</title>

  <para>
   Bien que cela ne soit pas strictement requis, il est recommandé de créer une
   classe réelle pour chaque attribut. Dans le cas le plus simple,
   seule une classe vide est nécessaire avec l'attribut
   <literal>#[Attribute]</literal> déclaré qui peut-être importé depuis l'espace
   de noms globaux avec une instruction use. 
  </para>

  <example>
   <title>Utilisation de la spécification TARGET pour restreindre l'utilisation des attributs</title>

   <programlisting role="php">
<![CDATA[
<?php

namespace Example;

use Attribute;

#[Attribute]
class MyAttribute
{
}
]]>
   </programlisting>
  </example>

  <para>
   Pour restreindre le type de déclaration auquel un attribut peut être affecté,
   un masque peut être passé comme premier argument à la déclaration
   <literal>#[Attribute]</literal>. 
  </para>

  <example>
   <title>Classe d'attribut simple</title>

   <programlisting role="php">
<![CDATA[
<?php

namespace Example;

use Attribute;

#[Attribute(Attribute::TARGET_METHOD | Attribute::TARGET_FUNCTION)]
class MyAttribute
{
}
]]>
   </programlisting>

   <para>
    Déclarer <classname>MyAttribute</classname> sur un autre type lèvera désormais
    une exception lors de l'appel à <function>ReflectionAttribute::newInstance</function>
   </para>
  </example>

  <para>
   Par défaut, un attribut ne peut être utilisé qu'une seule fois par déclaration.
   Si l'attribut doit être répétable sur les déclarations, il doit être spécifié
   dans le masque de la déclaration <literal>#[Attribute]</literal>.
  </para>

  <example>
   <title>Utiliser IS_REPEATABLE pour autoriser plusieurs déclarations de l'attribut</title>

   <programlisting role="php">
<![CDATA[
<?php

namespace Example;

use Attribute;

#[Attribute(Attribute::TARGET_METHOD | Attribute::TARGET_FUNCTION | Attribute::IS_REPEATABLE)]
class MyAttribute
{
}
]]>
   </programlisting>

  </example>
 </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
