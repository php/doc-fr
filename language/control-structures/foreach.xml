<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 64d777f39e3dcefcc3a65032221cf4863f9db663 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="control-structures.foreach" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title><literal>foreach</literal></title>
 <?phpdoc print-version-for="foreach"?>
 <para>
  La structure de langage <literal>foreach</literal> fournit une façon simple de
  parcourir des tableaux. <literal>foreach</literal> ne fonctionne que pour les tableaux
  et les objets, et émettra une erreur si vous tentez de l'utiliser sur une
  variable de type différent ou une variable non initialisée. Il existe
  deux syntaxes :
  <informalexample>
   <programlisting>
<![CDATA[
foreach (array_expression as $value)
    commandes
foreach (array_expression as $key => $value)
    commandes
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  La première forme passe en revue le tableau
  <literal>array_expression</literal>. À chaque itération, la valeur de
  l'élément courant est assignée à <literal>$value</literal> et le pointeur
  interne de tableau est avancé d'un élément (ce qui fait qu'à la prochaine
  itération, on accédera à l'élément suivant).
 </simpara>
 <simpara>
  La seconde forme assignera en plus la clé de l'élément courant
  à la variable <literal>$key</literal> à chaque itération.
 </simpara>
 <simpara>
  Il est possible de personnaliser
  <link linkend="language.oop5.iterations">l'itération sur des objets</link>.
 </simpara>
 <para>
  <note>
   <para>
    Lorsque <literal>foreach</literal> démarre, le pointeur interne
    du tableau est automatiquement ramené au premier
    élément du tableau. Cela signifie que vous n'aurez
    pas à faire appel à <function>reset</function> avant
    <literal>foreach</literal>.
   </para>
   <para>
    Vu que <literal>foreach</literal> utilise le pointeur interne
    du tableau à chaque itération, il conviendra d'en tenir compte
    lors d'une utilisation future du tableau dans votre code.
   </para>
  </note>
 </para>
 <para>
  Vous pouvez modifier facilement les éléments d'un tableau en
  précédent <literal>$value</literal> d'un &amp;. Ceci assignera une
  <link linkend="language.references">référence</link> au lieu de copier la
  valeur.
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr vaut maintenant array(2, 4, 6, 8)
unset($value); // Détruit la référence sur le dernier élément
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <para>
  Le référencement de <literal>$value</literal> est seulement possible si
  le tableau parcouru peut être référencé (i.e. si c'est une variable).
  Le code suivant ne fonctionnera pas :
  <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
foreach (array(1, 2, 3, 4) as &$value) {
    $value = $value * 2;
}
?>
]]>
  </programlisting>
  </informalexample>
 </para>
 <warning>
  <para>
   La référence de <literal>$value</literal> et le dernier élément du tableau
   sont conservés après l'exécution de la boucle <literal>foreach</literal>.
   Il est recommandé de les détruire en utilisant la fonction
   <function>unset</function>.
  </para>
 </warning>
 <para>
  <note>
   <para>
    <literal>foreach</literal> n'accepte pas l'opérateur de suppression
    des erreurs <literal>@</literal>.
   </para>
  </note>
 </para>
 <para>
  Vous pouvez remarquer que les exemples suivants fonctionnent de
  manière identique :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Valeur : $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valeur : $value<br />\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <para>
  Les exemples suivants sont aussi fonctionnellement identiques :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Clé : $key; Valeur : $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Clé : $key; Valeur : $value<br />\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <para>
  Voici quelques exemples de plus :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
/* exemple foreach 1 : la valeur seulement */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
    echo "Valeur courante de \$a: $v.\n";
}

/* exemple foreach 2 : la valeur et sa clé d'index */

$a = array(1, 2, 3, 17);

$i = 0; /* uniquement pour l'illustration */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* exemple foreach 3 : la clé et la valeur */

$a = array(
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* exemple foreach 4 : tableaux multidimensionnels */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* exemple foreach 5 : tableaux dynamiques */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
