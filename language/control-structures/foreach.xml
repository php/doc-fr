<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: af4410a7e15898c3dbe83d6ea38246745ed9c6fb Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="control-structures.foreach" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title><literal>foreach</literal></title>
 <para>
  La commande <literal>foreach</literal>,
  comme en Perl ou dans d'autres langages, est un moyen simple de passer
  en revue un tableau. <literal>foreach</literal> fonctionne uniquement sur les tableaux et
  les objets, elle retournera une erreur si vous tentez de l'utiliser sur une variable d'un autre type ou non initialisée.
  Il y a deux syntaxes possibles : la seconde est une extension mineure mais pratique de la première.
  <informalexample>
   <programlisting>
<![CDATA[
foreach (array_expression as $value)
    commandes
foreach (array_expression as $key => $value)
    commandes
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  La première forme passe en revue le tableau
  <literal>array_expression</literal>. À chaque itération, la valeur de
  l'élément courant est assignée à <literal>$value</literal> et le pointeur
  interne de tableau est avancé d'un élément (ce qui fait qu'à la prochaine
  itération, on accédera à l'élément suivant).
 </simpara>
 <simpara>
  La deuxième forme fait exactement la même chose, mais
  c'est la clé de l'élément courant qui est
  assigné à la variable <literal>$key</literal>.
 </simpara>
 <simpara>
  Il est possible d'
  <link linkend="language.oop5.iterations">itérer également sur des objets</link>.
 </simpara>
 <para>
  <note>
   <para>
    Lorsque <literal>foreach</literal> démarre, le pointeur interne
    du tableau est automatiquement ramené au premier
    élément du tableau. Cela signifie que vous n'aurez
    pas à faire appel à <function>reset</function> avant
    <literal>foreach</literal>.
   </para>
  </note>
 </para>
 <para>
  <note>
   <para>
    A moins que le tableau soit une
    <link linkend="language.references">référence</link>,
    <literal>foreach</literal> opère sur une copie des valeurs du tableau spécifié et non
    sur les valeurs elles-mêmes. <literal>foreach</literal> affecte le pointeur
    interne du tableau. Ne l'utilisez pas sans le remettre à zéro avant.
   </para>
  </note>
 </para>
 <para>
  Vous pouvez modifier facilement les éléments d'un tableau en
  précédent <literal>$value</literal> d'un &amp;. Ceci assignera une
  <link linkend="language.references">référence</link> au lieu de copier la
  valeur.
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr vaut maintenant array(2, 4, 6, 8)
unset($value); // Détruit la référence sur le dernier élément
?>
]]>
   </programlisting>
  </informalexample>
  Ceci n'est possible que si le tableau itéré peut être référencé (i.e. est
  une variable), ce qui signifie que le code suivant ne fonctionne pas :
  <programlisting role="php">
<![CDATA[
<?php
foreach (array(1, 2, 3, 4) as &$value) {
    $value = $value * 2;
}

?>
]]>
  </programlisting>
 </para>
 <warning>
  <para>
   La référence de <literal>$value</literal> et le dernier élément du tableau
   sont conservés après l'exécution de la boucle <literal>foreach</literal>.
   Il est recommandé de les détruire en utilisant la fonction
   <function>unset</function>.
  </para>
 </warning>
 <para>
  <note>
   <para>
    <literal>foreach</literal> n'accepte pas l'opérateur de suppression
    des erreurs <literal>@</literal>.
   </para>
  </note>
 </para>
 <para>
  Vous pouvez remarquer que les exemples suivants fonctionnent de
  manière identique :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Valeur : $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valeur : $value<br />\n";
}
?>
]]>
   </programlisting>
  </informalexample>
  Les exemples suivants sont aussi fonctionnellement identiques :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Clé : $key; Valeur : $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Clé : $key; Valeur : $value<br />\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <para>
  Voici quelques exemples de plus :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
/* exemple foreach 1 : la valeur seulement */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
    echo "Valeur courante de \$a: $v.\n";
}

/* exemple foreach 2 : la valeur et sa clé d'index */

$a = array(1, 2, 3, 17);

$i = 0; /* uniquement pour l'illustration */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* exemple foreach 3 : la clé et la valeur */

$a = array(
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* exemple foreach 4 : tableaux multidimensionnels */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* exemple foreach 5 : tableaux dynamiques */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
