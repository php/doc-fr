<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: c7aca484fd1d7eaccd03f0e011f858fa93d105b9 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="function.include" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title><function>include</function></title>
 <?phpdoc print-version-for="include"?>
 <simpara>
  L'instruction de langage <function>include</function> inclut et exécute
  le fichier spécifié en argument.
 </simpara>
 <simpara>
  Cette documentation s'applique aussi à l'instruction de langage
  <function>require</function>.
 </simpara>
 <simpara>
  Les fichiers sont inclus suivant le chemin du fichier fourni ; si aucun
  n'est fourni, l'<link linkend="ini.include-path">include_path</link>
  sera vérifié. Si le fichier n'est pas trouvé dans l'
  <link linkend="ini.include-path">include_path</link>,
  <function>include</function> vérifiera dans le dossier du script appelant
  et dans le dossier de travail courant avant d'échouer. L'instruction
  <function>include</function> enverra une erreur de type
  <link linkend="errorfunc.constants.errorlevels.e-warning">warning</link> si elle
  ne peut trouver le fichier; ce comportement est différent de
  <function>require</function>, qui enverra une erreur de type
  <link linkend="errorfunc.constants.errorlevels.e-error">fatal</link>.
 </simpara>
 <simpara>
  Si un chemin est défini, absolu ou relatif (commençant par une lettre de lecteur
  suivie de <literal>\</literal> pour Windows, ou <literal>/</literal> pour Unix/Linux),
  l'<link linkend="ini.include-path">include_path</link> sera ignoré. Par exemple,
  si un nom de fichier commence par <literal>../</literal>, PHP cherchera dans le
  dossier parent pour y trouver le fichier spécifié.
 </simpara>
 <simpara>
  Pour plus d'informations sur la façon dont PHP gère les fichiers inclus ainsi
  que le chemin d'inclusion, repportez-vous à la documentation relative
  à l'<link linkend="ini.include-path">include_path</link>.
 </simpara>
 <simpara>
  Lorsqu'un fichier est inclus, le code le composant hérite de la
  <link linkend="language.variables.scope">portée des variables</link>
  de la ligne où l'inclusion apparaît. Toutes les variables disponibles à cette
  ligne dans le fichier appelant seront disponibles dans le fichier appelé, à
  partir de ce point. Cependant, toutes les fonctions et classes définies dans
  le fichier inclus ont une portée globale.
 </simpara>
 <para>
  <example>
   <title>Exemple avec <function>include</function></title>
   <programlisting role="php">
<![CDATA[
vars.php
<?php

$couleur = 'verte';
$fruit = 'pomme';

?>

test.php
<?php

echo "Une $fruit $couleur"; // Une

include 'vars.php';

echo "Une $fruit $couleur"; // Une pomme verte

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Si l'inclusion intervient à l'intérieur d'une fonction,
  le code inclus sera alors considéré comme faisant partie de la
  fonction. Cela modifie donc le contexte de variables accessibles.
  Une exception à cette règle : les <link
  linkend="language.constants.predefined">constantes magiques</link> sont analysées
  par l'analyseur avant que l'inclusion n'intervienne.
 </simpara>
 <para>
  <example>
   <title>Inclusion de fichiers dans une fonction</title>
   <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $couleur;

    include 'vars.php';

    echo "Une $fruit $couleur";
}

/* vars.php est dans le contexte de foo()     *
 * donc $fruit n'est pas disponible hors de   *
 * cette fonction. $couleur l'est, car c'est  *
 * une variable globale                       */

foo();                      // Une pomme verte
echo "Une $fruit $couleur"; // Une  verte

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Il est important de noter que lorsqu'un fichier est
  <function>include</function> ou <function>require</function>,
  les erreurs d'analyse apparaîtront en HTML tout
  au début du fichier, et l'analyse du fichier
  parent ne sera pas interrompue. Pour cette raison, le code
  qui est dans le fichier doit être placé entre
  <link linkend="language.basic-syntax.phpmode">les balises
  habituelles de PHP</link>.
 </simpara>
 <simpara>
  Si les <link linkend="ini.allow-url-fopen">Gestionnaires d'URL</link>
  sont activés dans PHP (ce qui est le cas par défaut),
  vous pouvez localiser le fichier avec une URL (via HTTP ou
  bien avec un gestionnaire adapté : voir <xref linkend="wrappers"/>
  pour une liste des protocoles), au lieu d'un simple chemin
  local. Si le serveur distant interprète le fichier comme du code
  PHP, des variables peuvent être transmises au serveur distant
  via l'URL et la méthode GET. Ce n'est pas, à strictement
  parler, la même chose que d'hériter du contexte de variable.
  Le fichier inclus est en fait un script exécuté à distance,
  et son résultat est inclus dans le code courant.
 </simpara>
 &warn.no-win32-fopen-wrapper;
 <para>
  <example>
   <title>Utiliser <function>include</function> via HTTP</title>
   <programlisting role="php">
<![CDATA[
<?php

/* Cet exemple suppose que www.example.com est configuré pour traiter
 * les fichiers .php et non pas les fichiers .txt. De plus,
 * 'Work' signifie ici que les variables
 * $foo et $bar sont disponibles dans le fichier inclus
 */

// Ne fonctionne pas : file.txt n'a pas été traité par www.example.com comme du PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Ne fonctionne pas : le script cherche un fichier nommé
// 'file.php?foo=1&bar=2' sur le système local
include 'file.php?foo=1&bar=2';

// Réussi
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Ok.
include 'file.php';  // Ok.

?>
]]>
   </programlisting>
  </example>
 </para>
 <warning>
  <title>Alerte de sécurité</title>
  <para>
   Un fichier distant peut être traité sur le serveur distant
   (dépendamment de l'extension du fichier et si le serveur distant
   exécute PHP ou non) mais il doit toujours produire un script PHP valide
   parce qu'il sera traité sur le serveur local. Si le fichier du serveur
   distant doit être traité sur place et affiché seulement,
   <function>readfile</function> est une fonction beaucoup plus appropriée.
   Autrement, vous devriez bien faire attention à sécuriser le script distant
   afin qu'il produise un code valide et désiré.
   </para>
 </warning>
 <para>
  Voir aussi
  <link linkend="features.remote-files">travailler avec les fichiers distants</link>,
  <function>fopen</function> et
  <function>file</function> pour des informations relatives.
 </para>
 <simpara>
  Gestion du retour : il est possible d'exécuter une commande
  <function>return</function> dans un fichier inclus pour en
  terminer le traitement et retourner au fichier appelant. De plus,
  il est possible de retourner des valeurs des fichiers inclus.
  Vous pouvez prendre et traiter la valeur retournée par la
  fonction, comme toute autre fonction. Ce n'est cependant pas possible
  lors de l'inclusion de fichier distant à moins que le fichier distant
  ait des <link linkend="language.basic-syntax.phpmode">balises valides de
  début et de fin de script PHP</link> (comme avec les fichiers locaux).
  Vous pouvez déclarer les variables nécessaires dans ces tags et elles seront
  introduites à l'endroit où le fichier a été inclus.
 </simpara>
 <para>
  Comme <function>include</function> est une structure de langage particulière,
  les parenthèses ne sont pas nécessaires autour de l'argument. Faites attention
  lorsque vous comparez la valeur retournée.
  <example>
   <title>Comparaison de la valeur de retour d'une inclusion</title>
   <programlisting role="php">
<![CDATA[
<?php
// Ne fonctionne pas, évalué comme include(('vars.php') == 'OK'), i.e. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// Fonctionne
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title><function>include</function> et <function>return</function></title>
   <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // affiche 'PHP'

$bar = include 'noreturn.php';

echo $bar; // affiche 1

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  <literal>$bar</literal> a la valeur de &one; car
  l'inclusion était réussie. Notez la différence entre les deux
  exemples ci-dessus. Le premier utilise la commande <function>return</function>
  dans le fichier inclus, alors que le second ne le fait pas.
  Si le fichier ne peut être inclus, &false; est retourné et une erreur
  de niveau <constant>E_WARNING</constant> est envoyée.
 </simpara>
 <para>
  S'il y a des fonctions définies dans le fichier inclus, elles peuvent être
  utilisées dans le fichier principal si elles sont avant le
  <function>return</function> ou après. Si le fichier est inclus deux fois,
  PHP enverra une erreur fatale car les fonctions seront déjà déclarées. Il est
  recommandé d'utiliser <function>include_once</function> au lieu de vérifier
  si le fichier a déjà été inclus et donc de retourner conditionnellement l'inclusion du fichier.
 </para>
 <simpara>
  Une autre façon d'inclure un fichier PHP dans une variable est de capturer
  la sortie en utilisant les fonctions de
  <link linkend="ref.outcontrol">contrôle de sortie</link> avec
  <function>include</function>. Par exemple :
 </simpara>
 <para>
  <example>
   <title>Utilisation de la sortie du buffer pour inclure un fichier PHP dans
   une chaîne</title>
   <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        return ob_get_clean();
    }
    return false;
}

?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Pour automatiquement inclure des fichiers dans vos scripts, voyez également
  les options de configuration
  <link linkend="ini.auto-prepend-file">auto_prepend_file</link> et
  <link linkend="ini.auto-append-file">auto_append_file</link>
  du &php.ini;.
 </para>

 &note.language-construct;

 <simpara>
  Voir aussi
  <function>require</function>, <function>require_once</function>,
  <function>include_once</function>, <function>get_included_files</function>,
  <function>readfile</function>, <function>virtual</function>, et
  <link linkend="ini.include-path">include_path</link>.
 </simpara>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
