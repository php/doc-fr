<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.101 $ -->
<!-- EN-Revision: 1.173 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

 <chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Les structures de contrôle</title>

  <sect1 xml:id="control-structures.intro">
   <title>Introduction</title>
   <simpara>
    Tous les scripts PHP sont une suite d'instructions. Une instruction
    peut être une assignation, un appel de fonction, une instruction
    conditionnelle ou bien une instruction qui ne fait rien (une instruction
    vide). Une instruction se termine habituellement par un point virgule
    ("<literal>;</literal>"). De plus, plusieurs instructions peuvent être
    regroupées en bloc, délimité par des
    accolades ("<literal>{}</literal>"). Un bloc est considéré
    comme une instruction. Les différents types d'instructions sont
    décrits dans ce chapitre.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    L'instruction <literal>if</literal> est une des plus importantes
    instructions de tous les langages, PHP inclus. Elle permet
    l'exécution conditionnelle d'une partie de code. Les
    fonctionnalités de l'instruction <literal>if</literal>
    sont les mêmes en PHP qu'en C :
    <informalexample>
     <programlisting>
<![CDATA[
if (expression)
    commandes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Comme nous l'avons vu dans le paragraphe consacré aux
    <link linkend="language.expressions">expressions</link>,
    <replaceable>expression</replaceable> est convertie en sa valeur
    booléenne. Si l'<replaceable>expression</replaceable> vaut
    &true;, PHP exécutera l'<replaceable>instruction</replaceable> et
    si elle vaut &false;, l'instruction sera ignorée. Plus de détails sur les valeurs
    qui valent &false; sont disponibles dans la section
    <link linkend="language.types.boolean.casting">Conversion en booléen</link>.
   </simpara>
   <para>
    L'exemple suivant affiche la phrase <computeroutput>a est plus grand
    que b</computeroutput> si <varname>$a</varname> est plus grand
    que <varname>$b</varname> :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    print "a est plus grand que b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Souvent, vous voulez que plusieurs instructions soient
    exécutées après un branchement conditionnel. Bien
    évidemment, il n'est pas obligatoire de répéter
    l'instruction conditionnelle autant de fois que vous avez d'instructions
    à exécuter. À la place, vous pouvez rassembler toutes les
    instructions dans un bloc. L'exemple suivant affiche <computeroutput>a
    est plus grand que b</computeroutput>, et assigne la valeur de la
    variable <varname>$a</varname> à la variable
    <varname>$b</varname> :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a est plus grand que b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Vous pouvez imbriquer indéfiniment des instructions
    <literal>if</literal> les unes dans les autres, ce qui permet
    une grande flexibilité dans l'exécution d'une
    partie de code suivant un grand nombre de conditions.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Souvent, vous voulez exécuter une instruction si une
    condition est remplie, et une autre instruction si cette condition
    n'est pas remplie. C'est à cela que sert <literal>else</literal>.
    <literal>else</literal> fonctionne après un
    <literal>if</literal> et exécute les instructions
    correspondantes au cas o&uacute; l'expression du <literal>if</literal>
    est &false;. Dans l'exemple suivant, ce bout de code
    affiche <computeroutput>a est plus grand que b</computeroutput> si la
    variable <varname>$a</varname> est plus grande que la variable
    <varname>$a</varname>, et <computeroutput>a est plus petit que b</computeroutput>
    sinon :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a est plus grand que b";
} else {
    echo "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </informalexample>

    Les instructions après le <literal>else</literal> ne sont
    exécutées que si l'expression du <literal>if</literal>
    est &false;, et si elle n'est pas suivi par l'expression
    <literal>elseif</literal> - uniquement si elles sont évaluées à &false; (voir <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><literal>elseif</literal>/<literal>else if</literal></title>
   <para>
    <literal>elseif</literal>, comme son nom l'indique, est une combinaison
    de <literal>if</literal> et de <literal>else</literal>. Comme l'expression
    <literal>else</literal>, il permet d'exécuter une instruction
    après un <literal>if</literal> dans le cas où le "premier"
    if est évalué comme &false;. Mais,
    à la différence de l'expression <literal>else</literal>,
    il n'exécutera l'instruction que si l'expression conditionnelle
    <literal>elseif</literal> est évaluée comme
    &true;. L'exemple suivant affichera
    <computeroutput>a est plus grand que b</computeroutput>,
    <computeroutput>a est égal à b</computeroutput> ou
    <computeroutput>a est plus petit que b</computeroutput> :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a est plus grand que b";
} elseif ($a == $b) {
    echo "a est égal à b";
} else {
    echo "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Vous pouvez avoir plusieurs <literal>elseif</literal> qui se suivent
    les uns après les autres, après un <literal>if</literal> initial.
    Le premier <literal>elseif</literal> qui sera évalué
    à &true; sera exécuté. En PHP, vous
    pouvez aussi écrire "<literal>else if</literal>" en deux mots et
    son comportement sera identique à la version en un seul mot.
    La sémantique des deux expressions est légèrement
    différente, mais au bout du compte, le résultat sera
    exactement le même.
   </simpara>
   <simpara>
    L'expression <literal>elseif</literal> est exécutée
    seulement si le <literal>if</literal> précédent et tout
    autre <literal>elseif</literal> précédent sont
    évalués comme &false;, et que
    votre <literal>elseif</literal> est évalué à
    &true;.
   </simpara>
   <note>
    <simpara>
     A noter que <literal>elseif</literal> et <literal>else if</literal>
     sont traités de la même façon seulement quand des accolades sont utilisées,
     comme dans l'exemple ci-dessus. Quand vous utilisez ":" pour définir votre condition
     <literal>if</literal>/<literal>elseif</literal>, vous ne devez 
     pas séparer <literal>else if</literal> en deux mots, sans quoi PHP soulèvera 
     une erreur d'interprétation.
    </simpara>
   </note>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

/* Mauvaise méthode : */
if($a > $b):
    echo $a." est plus grand que ".$b;
else if($a == $b): // ne compilera pas
    echo "La ligne ci-dessus provoque une erreur d'interprétation";
endif;


/* Bonne méthode : */
if($a > $b):
    echo $a." est plus grand que ".$b;
elseif($a == $b): // Les deux mots sont collés
    echo $a." égal ".$b;
else:
    echo $a." est plus grand ou égal à ".$b;
endif;

?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>Syntaxe alternative</title>
   <para>
    PHP propose une autre manière de rassembler des
    instructions à l'intérieur d'un bloc, pour les
    fonctions de contrôle <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> et <literal>switch</literal>.
    Dans chaque cas, le principe
    est de remplacer l'accolade d'ouverture par deux points (:)
    et l'accolade de fermeture par, respectivement,
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal> ou <literal>endswitch;</literal>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A égal 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Dans l'exemple ci-dessus, le bloc HTML "A égal 5" est inclus
    à l'intérieur d'un <literal>if</literal> en
    utilisant cette nouvelle syntaxe. Ce code HTML ne sera
    affiché que si la variable <varname>$a</varname> est égale à 5.
   </simpara>
   <para>
    Cette autre syntaxe fonctionne aussi avec le <literal>else</literal> et
    <literal>elseif</literal>. L'exemple suivant montre une structure avec un
    <literal>if</literal>, un <literal>elsif</literal> et un
    <literal>else</literal> utilisant cette autre syntaxe :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a égal 5";
    echo "...";
elseif ($a == 6):
    echo "a égal 6";
    echo "!!!";
else:
    echo "a ne vaut ni 5 ni 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voir aussi
    <link linkend="control-structures.while"><literal>while</literal></link>,
    <link linkend="control-structures.for"><literal>for</literal></link>, et
    <link linkend="control-structures.if">if</link> pour d'autres exemples.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    La boucle <literal>while</literal> est le moyen le plus
    simple d'implémenter une boucle en PHP. Cette boucle
    se comporte de la même manière qu'en C.
    L'exemple le plus simple d'une boucle <literal>while</literal>
    est le suivant :
    <informalexample>
     <programlisting>
<![CDATA[
while (expression)
  commandes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La signification d'une boucle <literal>while</literal> est
    très simple. PHP exécute l'instruction tant
    que l'expression de la boucle <literal>while</literal> est
    évaluée comme &true;. La valeur
    de l'expression est vérifiée à chaque
    début de boucle, et, si la valeur change durant
    l'exécution de l'instruction, l'exécution ne
    s'arrêtera qu'à la fin de l'itération
    (chaque fois que PHP exécute l'instruction, on appelle
    cela une itération). De temps en temps, si l'expression du
    <literal>while</literal> est &false; avant la
    première itération, l'instruction ne sera jamais
    exécutée.
   </simpara>
   <para>
    Comme avec le <literal>if</literal>, vous pouvez regrouper
    plusieurs instructions dans la même boucle
    <literal>while</literal> en les regroupant à l'intérieur
    de parenthèses ou en utilisant la syntaxe suivante :
    <informalexample>
     <programlisting>
<![CDATA[
while (expression):
    commandes
    ...
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Les exemples suivants sont identiques et affichent tous les nombres
    de 1 jusqu'à 10 :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* exemple 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* La valeur affiche est $i avant l'incrémentation
                     (post-incrémentation)  */
}

/* exemple 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    Les boucles <literal>do-while</literal> ressemblent beaucoup
    aux boucles <literal>while</literal>, mais l'expression est
    testée à la fin de chaque itération plutôt
    qu'au début. La principale différence par rapport
    à la boucle <literal>while</literal> est que la
    première itération de la boucle
    <literal>do-while</literal> est toujours exécutée
    (l'expression n'est testée qu'à la fin de
    l'itération), ce qui n'est pas le cas lorsque vous
    utilisez une boucle <literal>while</literal> (l'expression
    est vérifiée au début de chaque itération).
   </simpara>
   <para>
    Il n'y a qu'une syntaxe possible pour les boucles <literal>do-while</literal> :

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     La boucle ci-dessus ne va être exécutée
     qu'une seule fois, car lorsque l'expression est
     évaluée, elle vaut &false; (car
     la variable <varname>$i</varname> n'est pas plus grande que 0) et l'exécution
     de la boucle s'arrête.
   </simpara>
   <para>
    Les utilisateurs familiers du C sont habitués à
    une utilisation différente des boucles
    <literal>do-while</literal> , qui permet de stopper
    l'exécution de la boucle au milieu des instructions, en
    l'encapsulant dans un <literal>do-while</literal>(0) la
    fonction <link linkend="control-structures.break"><literal>break</literal></link>.
    Le code suivant montre une utilisation possible :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i n'est pas suffisamment grand";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "i est bon";

    /* ...traitement de i... */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Ne vous inquiétez pas si vous ne comprenez
    pas tout correctement. Vous pouvez écrire des scripts
    très très puissants sans utiliser
    cette fonctionnalité.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Les boucles <literal>for</literal> sont les boucles les plus complexes en PHP.
    Elles fonctionnent comme les boucles <literal>for</literal> du langage C.
    La syntaxe des boucles <literal>for</literal> est la suivante :
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3)
  commandes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La première expression (<varname>expr1</varname>) est
    évaluée (exécutée), quoi qu'il arrive au
    début de la boucle.
   </simpara>
   <simpara>
    Au début de chaque itération, l'expression
    <varname>expr2</varname> est évaluée.
    Si l'évaluation vaut &true;, la boucle
    continue et l'instruction est exécutée. Si
    l'évaluation vaut &false;,
    l'exécution de la boucle s'arrête.
   </simpara>
   <simpara>
    À la fin de chaque itération, l'expression
    <varname>expr3</varname> est évaluée
    (exécutée).
   </simpara>
   <simpara>
    Les expressions peuvent éventuellement être
    laissées vides ou peuvent contenir plusieurs expressions séparées par des virgules.
    Dans <varname>expr2</varname>, toutes les expressions séparées par une virgule
    sont évaluées mais le résultat est obtenu depuis la dernière partie.
    Si l'expression <varname>expr2</varname>
    est laissée vide, cela signifie que c'est une boucle infinie
    (PHP considère implicitement qu'elle vaut &true;,
    comme en C). Cela n'est pas vraiment très utile, à moins que vous
    souhaitiez terminer votre boucle par l'instruction conditionnelle
    <link linkend="control-structures.break"><literal>break</literal></link>.
   </simpara>
   <para>
    Considérons les exemples suivants. Tous affichent les chiffres de
    1 jusqu'à 10 :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* exemple 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* exemple 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* exemple 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* exemple 4 */

for ($i = 1, $j = 0; $i <= 10; $j += $i, print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Bien évidemment, le premier exemple est le plus simple
    de tous (ou peut être le quatrième), mais vous
    pouvez aussi pensez qu'utiliser une expression vide dans une
    boucle <literal>for</literal> peut être utile parfois.
   </simpara>
   <para>
    PHP supporte aussi la syntaxe alternative suivante pour les boucles
    <literal>for</literal> :
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3):
  commandes
  ...
endfor;
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Beaucoup de personnes ont l'habitude d'itérer grâce à des tableaux, comme dans 
    l'exemple ci dessous.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ceci est un tableau avec des données que nous voulons modifier
 * au long de la boucle
 */
$people = Array(
        Array('name' => 'Kalle', 'salt' => 856412), 
        Array('name' => 'Pierre', 'salt' => 215863)
        );

for($i = 0; $i < sizeof($people); ++$i)
{
    $people[$i]['salt'] = rand(000000, 999999);
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Le problème se situe dans le deuxième argument de l'expression for. Ce code peut être lent
    parce qu'il doit caclculer la taille du tableau à chaque itération.
    Etant donné que la taille ne change jamais, il peut facilement être optimisé en utilisant
    une variable intermédiaire pour stocker la taille et en l'utilisant dans la boucle à la place
    de sizeof. L'exemple ci-dessous illustre ce cas :
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$people = Array(
        Array('name' => 'Kalle', 'salt' => 856412), 
        Array('name' => 'Pierre', 'salt' => 215863)
        );

for($i = 0, $size = sizeof($people); $i < $size; ++$i)
{
    $people[$i]['salt'] = rand(000000, 999999);
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 introduit une commande <literal>foreach</literal>,
    comme en Perl ou d'autres langages. C'est un moyen simple de passer
    en revue un tableau. <literal>foreach</literal> fonctionne uniquement sur les tableaux, et
    retournera une erreur si vous tentez de l'utiliser sur une variable d'un autre type ou non initialisée.
    Il y a deux syntaxes possibles : la seconde est
    une extension mineure mais pratique de la première.
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value)
    commandes
foreach (array_expression as $key => $value)
    commandes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La première forme passe en revue le tableau
    <literal>array_expression</literal>. À chaque itération,
    la valeur de l'élément courant est assignée à
    <literal>$value</literal> et le pointeur interne de tableau est
    avancé d'un élément (ce qui fait qu'à
    la prochaine itération, on accédera à
    l'élément suivant).
   </simpara>
   <simpara>
    La deuxième forme fait exactement la même chose, mais
    c'est la clé de l'élément courant qui est
    assigné à la variable <literal>$key</literal>.
   </simpara>
   <simpara>
    Depuis PHP 5, il est possible d'
    <link linkend="language.oop5.iterations">itérer également des objets</link>.
   </simpara>
   <para>
    <note>
     <para>
      Lorsque <literal>foreach</literal> démarre, le pointeur interne
      de fichier est automatiquement ramené au premier
      élément du tableau. Cela signifie que vous n'aurez
      pas à faire appel à <function>reset</function> avant
      <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      A moins que le tableau soit une <link linkend="language.references">référence</link>,
      <literal>foreach</literal> opère sur une copie du tableau spécifié et non sur le tableau
      lui-même. <literal>foreach</literal> affecte le pointeur interne du tableau. Ne l'utilisez
      pas sans le remettre à zéro avant.
     </para>
    </note>
   </para>
   <para>
    Depuis PHP 5, vous pouvez modifier facilement les éléments d'un tableau en
    précédent <literal>$value</literal> d'un &amp;. Ceci assignera une
    <link linkend="language.references">référence</link> au lieu de copier la valeur.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr vaut maintenant array(2, 4, 6, 8)
unset($value); // Stop la référence sur le dernier élément
?>
]]>
     </programlisting>
    </informalexample>
    Ceci n'est possible que si le tableau itéré peut être référencé (i.e. est une variable).
   </para>
   <warning>
    <para>
     La référence de <literal>$value</literal> et le dernier élément du tableau
     sont conservés après l'exécution de la boucle <literal>foreach</literal>.
     Il est recommandé de les détruire en utilisant la fonction <function>unset</function>.
    </para>
   </warning>
   <para>
    <note>
     <para>
      <literal>foreach</literal> n'accepte pas l'opérateur de suppression
      des erreurs <literal>@</literal>.
     </para>
    </note>
   </para>
   <para>
    Vous pouvez remarquer que les exemples suivants fonctionnent de
    manière identique :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Valeur : $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valeur : $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Les exemples suivants sont aussi fonctionnellement identiques :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Clé : $key; Valeur : $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Clé : $key; Valeur : $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voici quelques exemples de plus :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* exemple foreach 1 : la valeur seulement */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "Current value of \$a : $v.\n";
}

/* exemple foreach 2 : la valeur et sa clé d'index */

$a = array(1, 2, 3, 17);

$i = 0; /* uniquement pour l'illustration */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* exemple foreach 3 : la clé et la valeur */

$a = array(
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* exemple foreach 4 : tableaux multi-dimensionnels */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* exemple foreach 5 : tableaux dynamiques */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    L'instruction <literal>break</literal> permet de sortir d'une structure
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal>
    ou <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accepte un argument numérique optionnel
    qui vous indiquera combien de structures emboîtées ont
    été interrompues.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('un', 'deux', 'trois', 'quatre', 'stop', 'cinq');
while (list(, $val) = each($arr)) {
    if ($val == 'stop') {
        break;    /* Vous pourriez aussi utiliser 'break 1;' ici. */
    }
    echo "$val<br />\n";
}

/* Utilisation de l'argument optionnel. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "A 5<br />\n";
        break 1;  /* Termine uniquement le switch. */
    case 10:
        echo "A 10; quitter<br />\n";
        break 2;  /* Termine le switch et la boucle while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    L'instruction <literal>continue</literal> est utilisée
    dans une boucle afin d'éluder les instructions de
    l'itération courante et de continuer l'exécution à la condition de l'évaluation
    et donc, de commencer la prochaine itération.
   </simpara>
   <note>
    <simpara>
    Notez qu'en PHP, la structure
    <link linkend="control-structures.switch"><literal>switch</literal></link>
     est considérée comme une boucle par <literal>continue</literal>.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> accepte un argument numérique
    optionnel qui vous indiquera combien de structures
    emboîtées ont été ignorées.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($cle, $valeur) = each($arr)) {
    if (!($cle % 2)) { // évite les membres impairs
        continue;
    }
    fonction_quelconque($valeur);
}

$i = 0;
while ($i++ < 5) {
    echo "Dehors<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Milieu<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Intérieur<br />\n";
            continue 3;
        }
        echo "Ceci n'est jamais atteint.<br />\n";
    }
    echo "Ceci non plus.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
     Oublier le point virgule après <literal>continue</literal> peut porter
     à confusion. Voici un exemple de ce que vous ne devez pas faire :
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       On peut s'attendre à ce que le résultat soit :
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       mais ce script affichera :
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       car la valeur de retour de l'appel à <function>print</function>
       est <literal>int(1)</literal>, et cela se comportera alors comme si
       on avait fournit l'argument optionnel mentionné plus haut.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    L'instruction <literal>switch</literal> équivaut
    à une série d'instructions <literal>if</literal>.
    En de nombreuses occasions, vous aurez besoin de comparer
    la même variable (ou expression) avec un grand nombre
    de valeurs différentes, et d'exécuter
    différentes parties de code suivant la valeur
    à laquelle elle est égale. C'est exactement
    à cela que sert l'instruction <literal>switch</literal>.
   </simpara>
   <note>
    <simpara>
     Notez que contrairement à d'autres langages, la structure
     <link linkend="control-structures.continue">continue</link> s'applique
     aux structures <literal>switch</literal> et se comporte de la même manière que
     <literal>break</literal>.
     Si vous avez un <literal>switch</literal> dans une boucle, et que vous
     souhaitez continuer jusqu'à la prochaine itération de la boucle
     extérieure, vous vous devez utiliser <literal>continue 2</literal>.
    </simpara>
   </note>
   <note>
    <para>
     Notez que switch/case provoque une
     <link linkend="types.comparisions-loose">perte de comparaison</link>.
    </para>
   </note>
   <para>
    Les deux exemples suivants sont deux manières
    différentes d'écrire la même chose,
    l'une en utilisant une séries de <literal>if</literal>,
    et l'autre en utilisant l'instruction <literal>switch</literal> :
    <example>
     <title>Instruction <literal>switch</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i égal 0";
} elseif ($i == 1) {
    echo "i égal 1";
} elseif ($i == 2) {
    echo "i égal 2";
}

switch ($i) {
case 0:
    echo "i égal 0";
    break;
case 1:
    echo "i égal 1";
    break;
case 2:
    echo "i égal 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Instruction <literal>switch</literal> utilisant une chaîne de caractères</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "tarte":
    echo "i est une tarte";
    break;
case "barre":
    echo "i est une barre";
    break;
case "gateau":
    echo "i est un gateau";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Il est important de comprendre que l'instruction
    <literal>switch</literal> exécute chacune des
    clauses dans l'ordre. L'instruction <literal>switch</literal>
    est exécutée ligne par ligne. Au début,
    aucun code n'est exécuté. Seulement
    lorsqu'un <literal>case</literal> est vérifié,
    PHP exécute alors les instructions correspondantes.
    PHP continue d'exécuter les instructions jusqu'à
    la fin du bloc d'instructions du <literal>switch</literal>,
    ou bien dès qu'il trouve l'instruction <literal>break</literal>.
    Si vous ne pouvez pas utiliser l'instruction
    <literal>break</literal> à la fin de l'instruction
    <literal>case</literal>, PHP continuera à exécuter
    toutes les instructions qui suivent. Par exemple :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i égal 0";
case 1:
    echo "i égal 1";
case 2:
    echo "i égal 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Dans cet exemple, si <varname>$i</varname> est égal à 0, PHP va
    exécuter quand même toutes les instructions qui
    suivent! Si <varname>$i</varname> est égal à 1, PHP exécutera
    les deux dernières instructions. Et seulement si <varname>$i</varname> est
    égal à 2, vous obtiendrez le résultat
    escompté, c'est-à-dire, l'affiche de
    "i égal 2". Donc, l'important est de ne pas oublier
    l'instruction <literal>break</literal> (même s'il est
    possible que vous l'omettiez dans certaines circonstances).
   </simpara>
   <simpara>
    Dans une commande <literal>switch</literal>, une condition n'est
    évaluée qu'une fois, et le résultat est
    comparé à chaque <literal>case</literal>.
    Dans une structure <literal>elseif</literal>, les conditions sont
    évaluées à chaque comparaison. Si votre
    condition est plus compliquée qu'une simple
    comparaison, ou bien fait partie d'une boucle,
    <literal>switch</literal> sera plus rapide.
   </simpara>
   <para>
    La liste de commandes d'un <literal>case</literal> peut
    être vide, auquel cas PHP utilisera la liste de
    commandes du cas suivant.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i est plus petit que 3 mais n'est pas négatif";
    break;
case 3:
    echo "i égal 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Un cas spécial est <literal>default</literal>. Ce cas est utilisé lorsque tous
    les autres cas ont échoués. Par exemple :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i égal 0";
    break;
case 1:
    echo "i égal 1";
    break;
case 2:
    echo "i égal 2";
    break;
default:
    echo "i n'est ni égal à 2, ni à 1, ni à 0.";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Une autre chose à mentionner est que la valeur du
    <literal>case</literal> peut être toute expression de
    type scalaire, c'est-à-dire nombre entier, nombre
    à virgule flottante et chaîne de caractères.
    Les tableaux sont sans intérêt dans ce contexte-là.
   </para>
   <para>
    La syntaxe alternative pour cette structure de contrôle est
    la suivante : (pour plus d'informations, voir
    <link linkend="control-structures.alternative-syntax">syntaxes alternatives</link>).
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i égal 0";
    break;
case 1:
    echo "i égal 1";
    break;
case 2:
    echo "i égal 2";
    break;
default:
    echo "i n'est ni égal à 2, ni à 1, ni à 0";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Il est possible d'utiliser un point-virgule plutôt que deux points après un case, comme ceci :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch($biere)
{
    case 'leffe';
    case 'grimbergen';
    case 'guinness';
        echo 'Bon choix';
    break;
    default;
        echo 'Merci de faire un choix...';
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    L'élément de langage <literal>declare</literal> sert à ajouter des
    directives d'exécutions dans un bloc de code. La syntaxe de
    <literal>declare</literal> est similaire à la syntaxe des autres
    fonctions de contrôle :
    <informalexample>
     <programlisting>
<![CDATA[
declare (directive)
    commandes
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'expression <literal>directive</literal> permet de contrôler 
    l'intervention du bloc <literal>declare</literal>. 
    Actuellement, seulement deux directives sont reconnues : la directive 
    <literal>ticks</literal> (Voir plus bas pour plus
    de détails sur les 
    <link linkend="control-structures.declare.ticks">ticks</link>
    ) et la directive d'encodage <literal>encoding</literal> (Voir plus bas pour plus
    de détails sur la directive
    <link linkend="control-structures.declare.encoding">encoding</link>
    ).
   </para>
   <note>
    <simpara>
     La directive <literal>encoding</literal> a été ajoutée en PHP 5.3.0.
    </simpara>
   </note>
   <para>
    L'expression <literal>commandes</literal> du bloc de
    <literal>declare</literal> sera exécutée. Comment elle sera exécutée,
    et quels effets cela aura dépend de la directive utilisée dans le bloc
    <literal>directive</literal>.
   </para>
   <para>
    La structure <literal>declare</literal> peut aussi être utilisée
    dans le contexte global. Elle affecte alors tout le code qui la suit (même si le fichier avec
    <literal>declare</literal> a été inclus après, ça n'affecte pas le fichier 
    parent).
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Ces déclaration sont identiques.

// Vous pouvez utiliser ceci
declare(ticks=1) {
    // script entier ici
}

// ou ceci
declare(ticks=1);
// script entier ici
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title>Ticks</title>
    <caution>
     <simpara>
      A partir de PHP 5.3.0, les ticks sont dépréciés et seront supprimés
      en PHP 6.0.0.
     </simpara>
    </caution>
    <para>Un tick est un événement qui intervient toutes les
    <varname>N</varname> commandes bas niveau, exécutées par l'analyseur
    dans le bloc de <literal>declare</literal>.
    La valeur de <varname>N</varname> est spécifiée avec la syntaxe
    <code>ticks=<varname>N</varname></code>
    dans le bloc de directive 
    <literal>declare</literal>.
   </para>
   <para>
    Un événement qui intervient à chaque tick est spécifié avec la fonction
    <function>register_tick_function</function>. Reportez-vous à l'exemple
    ci-dessous pour plus de détails. Notez que plus d'un événement peut
    intervenir par tick.
   </para>
   <para>
    <example>
     <title>Profiler une section de code PHP</title>
     <programlisting role="php">
<![CDATA[
<?php
// Une fonction qui enregistre l'heure à laquelle elle est appelée
function profile($dump = FALSE)
{
    static $profile;

    // Retourne les horaires stockés dans le profile, et l'efface
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// Enregistre un gestionnaire de tick
register_tick_function("profile");

// Initialise la fonction avant le bloc de déclaration
profile();

// Exécute un bloc de code, et appele un tick toutes les deux secondes
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Affiche les données de la variable $profile
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
    Cet exemple profile le code PHP dans le bloc de déclaration,
    et enregistre l'heure de chaque commande bas niveau. Cette
    information peut être réutilisée pour débusquer les segments
    de code lents. Vous pouvez implémenter d'autres méthodes, mais
    les ticks sont plus rapides et plus efficaces.
   </para>
   <simpara>
    Les ticks sont bien pratiques pour déboguer, pour implémenter un
    système multi-tâches simple, pour gérer des entrées sorties en tâche de
    fond, ou bien d'autres choses, avec PHP.
   </simpara>
   <simpara>
    Voir aussi <function>register_tick_function</function> et
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
   <sect2 xml:id="control-structures.declare.encoding">
    <title>L'encodage: encoding</title>
    <para>
      L'encodage d'un script peut être spécifié par script en utilisant la directive <literal>encoding</literal>.
    <example>
     <title>Déclaration d'un encodage pour un script</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(encoding='ISO-8859-1');
// le code
?>
]]>
      </programlisting>
     </example>
    </para>

    <caution>
     <simpara>
      Combinée avec les espaces de nommage, la seule syntaxe valable pour declare
      est <literal>declare(encoding='...');</literal> où <literal>...</literal>
      est la valeur de l'encodage.  <literal>declare(encoding='...') {}</literal>
      soulèvera une erreur d'interprétation dans le cas des espaces de nommage.
     </simpara>
    </caution>
    <para>
     La valeur d'encodage est ignorée en PHP 5.3 à moins que PHP soit compilé avec
     <literal>--enable-zend-multibyte</literal>.  En PHP 6.0, la directive <literal>encoding</literal>
     sera utilisée pour dire au scanner dans quel encodage le fichier a été créé. Les valeurs
     valables sont des noms d'encodage tels que <literal>UTF-8</literal>.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
    Si appelée depuis une fonction, la commande <function>return</function>
    termine immédiatement la fonction, et retourne l'argument qui lui
    est passé. <function>return</function> interrompt aussi l'exécution
    de commande <function>eval</function> ou de scripts.
   </simpara>
   <simpara>
    Si appelée depuis l'environnement global, l'exécution du script
    est interrompue. Si le script courant était
    <function>include</function> ou <function>require</function>,
    alors le contrôle est rendu au script appelant, et la valeur
    retournée sera utilisée comme résultat de la fonction
    <function>include</function>. Si <function>return</function> est
    appelée depuis le script principal, alors l'exécution du script
    s'arrête. Si le script courant est
    <link linkend="ini.auto-prepend-file"><option>auto_prepend_file</option></link> ou
    <link linkend="ini.auto-append-file"><option>auto_append_file</option></link>
    dans le fichier &php.ini;, alors l'exécution du script
    s'arrête.
   </simpara>
   <simpara>
    Pour plus d'informations, voyez
    <link linkend="functions.returning-values">retourner des valeurs</link>.
   </simpara>
   <para>
    <note>
     <simpara>
      Notez que puisque <function>return</function> est une structure de langage,
      et non une fonction, les parenthèses entourant les arguments ne sont pas nécessaires.
      Il est classique de les oublier et vous devriez le faire car PHP travaillera moins dans ce
      cas.
     </simpara>
    </note>
    <note>
     <simpara>
      Vous ne devriez <emphasis>jamais</emphasis> utiliser les parenthèses autour
      de la variable retournée lorsque vous la retournez pas référence, car cela ne
      fonctionnera pas. Vous ne pouvez retourner que les variables par référence, et
      non le résultat du traitement. Si vous utilisez <literal>return ($a);</literal>, alors
      vous ne retournez pas une variable mais le résultat de l'expression
      <literal>($a)</literal> (qui est, bien sûr, la valeur de <varname>$a</varname>).
     </simpara>
     </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function> inclut et exécute un
    fichier PHP.
   </simpara>
   <simpara>
    La commande <function>require</function> se remplace elle-même
    par le contenu du fichier spécifié, tel que
    décrit dans la documentation de la fonction <function>include</function>.
   </simpara>
   <simpara>
    <function>require</function> et <function>include</function>
    sont identiques, sauf dans leur façon de gérer les erreurs.
    Ils produisent tous les deux une <link linkend="errorfunc.constants.errorlevels.e-warning">Alerte</link>
    mais <function>require</function> génère une
    <link linkend="errorfunc.constants.errorlevels.e-error">erreur fatale</link>. En
    d'autres termes, n'hésitez pas à utiliser
    <function>require</function> si vous voulez qu'un fichier
    d'inclusion manquant interrompe votre script.
    <function>include</function> ne se comporte pas de cette façon,
    et le script continuera son exécution. Assurez-vous d'avoir
    bien configuré le
    <link linkend="ini.include-path"><option>include_path</option></link> aussi.
   </simpara>
   <para>
    <example>
     <title>Exemples avec <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $un_fichier;

require ('un_fichier.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Voyez la documentation de la fonction <function>include</function> pour plus
    d'exemples.
   </simpara>
   <para>
    <note>
     <simpara>
      Avant PHP 4.0.2, ceci s'appliquait : <function>require</function> tentait
      de lire le fichier cible, même si les lignes n'étaient pas utilisées.
      Une condition if n'avait aucun effet sur <function>require</function>. Cependant,
      si la ligne du <function>require</function> n'est jamais utilisée,
      le code inclus ne le sera pas non plus. De même, les boucles n'ont pas
      d'effet sur le comportement de <function>require</function>. Bien que le
      code contenu dans le fichier subit la boucle, la fonction elle même
      <function>require</function> n'est appelée qu'une fois.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
    Voir aussi
    <function>include</function>,
    <function>require_once</function>,
    <function>include_once</function>,
    <function>get_included_files</function>,
    <function>eval</function>,
    <function>file</function>,
    <function>readfile</function>,
    <function>virtual</function> et <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><function>include</function></title>
   <simpara>
    La fonction <function>include</function> inclut et exécute
    le fichier spécifié en argument.
   </simpara>
   <simpara>
    Cette documentation s'applique aussi à la fonction
    <function>require</function>. Les deux structures de
    langage sont identiques, hormis dans leur gestion des
    erreurs. Ils produisent tous les deux un
    <link linkend="errorfunc.constants.errorlevels.e-warning">Alerte</link> mais
    <function>require</function> génère une
    <link linkend="errorfunc.constants.errorlevels.e-error">erreur fatale</link>. En
    d'autres termes, n'hésitez pas à utiliser
    <function>require</function> si vous voulez qu'un fichier
    d'inclusion manquant interrompe votre script.
    <function>include</function> ne se comporte pas de cette façon,
    et le script continuera son exécution. Assurez-vous d'avoir
    bien configuré le <link linkend="ini.include-path"><option>include_path</option></link>
    aussi. Soyez prévenus qu'une erreur d'analyse dans un fichier
    inclut ne cause pas l'arrêt du script en PHP dans les versions antérieures à 4.3.5. Depuis ces versions,
    il le peut.
   </simpara>
   <simpara>
    Les fichiers à inclure sont d'abord recherchés dans chaque dossier de
    <option>include_path</option>, relativement au dossier
    courant, puis dans le dossier de travail du script. Par exemple, si
    <option>include_path</option>
    est <literal>.</literal>, que le dossier de travail est
    <filename class="directory">/www/</filename>, et que vous incluez le fichier
    <filename>include/a.php</filename> et qu'il y a une instruction
    <literal>include "b.php"</literal> dans ce fichier, alors
    <filename>b.php</filename> est d'abord recherché dans
    <filename class="directory">/www/libraries/</filename>, puis dans
    <filename class="directory">/www/include/</filename>.
    Si le nom du fichier commence par <literal>./</literal> ou <literal>../</literal>,
    il est cherché uniquement dans le dossier courant d'exécution.
   </simpara>
   <simpara>
    Lorsqu'un fichier est inclus, le code le composant hérite de la
    <link linkend="language.variables.scope">portée des variables</link>
    de la ligne où l'inclusion apparaît. Toutes les variables disponibles à cette ligne
    dans le fichier appelant seront disponibles dans le fichier appelé, à partir
    de ce point.
    Cependant, toutes les fonctions et classes définies dans le fichier inclus ont
    une portée globale.
   </simpara>
   <para>
     <example>
      <title>Exemple avec <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$couleur = 'verte';
$fruit = 'pomme';

?>

test.php
<?php

echo "Une $couleur $fruit"; // Une

include 'vars.php';

echo "Une $couleur $fruit"; // Une verte pomme

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
    Si l'inclusion intervient à l'intérieure d'une fonction,
    le code inclus sera alors considéré comme faisant partie de la
    fonction. Cela modifie donc le contexte de variables accessibles.
    Une exception à cette règle : les <link
    linkend="language.constants.predefined">constantes magiques</link> sont analysées
    par l'analyseur avant que l'inclusion n'intervienne.
   </simpara>
   <para>
     <example>
     <title>Inclusion de fichiers dans une fonction</title>
     <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $couleur;

    include 'vars.php';

    echo "Une $couleur $fruit";
}

/* vars.php est dans le contexte de foo()    *
 * donc $fruit n'est pas disponibles hors de  *
 * cette fonction. $couleur l'est, car c'est *
 * une variable globale                      */

foo();                      // Une verte pomme
echo "Une $couleur $fruit"; // Une verte

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Il est important de noter que lorsqu'un fichier est
    <function>include</function> ou <function>require</function>,
    les erreurs d'analyse apparaîtront en HTML tout
    au début du fichier, et l'analyse du fichier
    parent ne sera pas interrompue. Pour cette raison, le code
    qui est dans le fichier doit être placé entre
    <link linkend="language.basic-syntax.phpmode">les balises
    habituelles de PHP</link>.
   </simpara>
   <simpara>
    Si les <link linkend="ini.allow-url-fopen">Gestionnaires d'URL</link>
    sont activés dans PHP (ce qui est le cas par défaut),
    vous pouvez localiser le fichier avec une URL (via HTTP ou
    bien avec un gestionnaire adapté : voir <xref linkend="wrappers"/>
    pour une liste des protocoles), au lieu d'un simple chemin
    local. Si le serveur distant interprète le fichier comme du code
    PHP, des variables peuvent être transmises au serveur distant
    via l'URL et la méthode GET. Ce n'est pas, à strictement
    parler, la même chose que d'hériter du contexte de variable.
    Le fichier inclus est en fait un script exécuté à distance,
    et son résultat est inclus dans le code courant.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>Utiliser <function>include</function> via HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Cet exemple suppose que www.example.com est configuré pour traiter
 * les fichiers .php et non pas les fichiers .txt. De plus,
 * 'Work' signifie ici que les variables
 * $foo et $bar sont disponibles dans le fichier inclus
 */

// Ne fonctionne pas : file.txt n'a pas été traité par www.example.com comme du PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Ne fonctionne pas : le script cherche un fichier nommé
// 'file.php?foo=1&bar=2' sur le système local
include 'file.php?foo=1&bar=2';

// Réussi
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // OK.
include 'file.php';  // OK.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Alerte de sécurité</title>
    <para>
     Un fichier distant peut être traité sur le serveur distant
     (dépendemment de l'extension du fichier et si le serveur distant
     exécute PHP ou non) mais il doit toujours produire un script PHP valide
     parce qu'il sera traité sur le serveur local. Si le fichier du serveur
     distant doit être traité sur place et affiché seulement,
     <function>readfile</function> est une fonction beaucoup plus appropriée.
     Autrement, vous devriez bien faire attention à sécuriser le script distant
     afin qu'il produise un code valide et désiré.
    </para>
   </warning>
   <para>
    Voir aussi
    <link linkend="features.remote-files">travailler avec les fichiers distants</link>,
    <function>fopen</function> et
    <function>file</function> pour des informations reliées.
   </para>
   <simpara>
    Gestion du retour : il est possible d'exécuter une commande
    <function>return</function> dans un fichier inclus pour en
    terminer le traitement et retourner au fichier appelant. De plus,
    il est possible de retourner des valeurs des fichiers inclus.
    Vous pouvez prendre et traiter la valeur retournée par la
    fonction, comme toute autre fonction. Ce n'est cependant pas possible
    lors de l'inclusion de fichier distant à moins que le fichier distant
    a des <link linkend="language.basic-syntax.phpmode">balises valides de
    début et de fin de script PHP</link> (comme avec les fichiers locaux).
    Vous pouvez déclarer les variables nécessaire dans ces tags et elles seront
    introduites à l'endroit où le fichier a été inclus.
   </simpara>
   <para>
    Comme <function>include</function> est une structure de langage particulière,
    les parenthèses ne sont pas nécessaires autour de l'argument. Faites attention
    lorsque vous comparez la valeur retournée.
    <example>
     <title>Comparaison de la valeur de retour d'un include</title>
     <programlisting role="php">
<![CDATA[
<?php
// ne fonctionne pas, évaluer comme include(('vars.php') == 'OK'), i.e. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// fonctionne
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title><function>include</function> et <function>return</function></title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // affiche 'PHP'

$bar = include 'noreturn.php';

echo $bar; // affiche 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> a la valeur de &one; car
    l'inclusion était réussie. Notez la différence entre les deux
    exemples ci-dessus. Le premier utilise la commande <function>return</function>
    dans le fichier inclus, alors que le second ne le fait pas.
    Si le fichier ne peut être inclus, &false; est retourné et une erreur
    de niveau <literal>E_WARNING</literal> est envoyée.
   </simpara>
   <para>
    S'il y a des fonctions de définies dans le fichier inclus, elles peuvent être
    utilisées dans le fichier principal si elles sont avant le <function>return</function>
    ou après. Si le fichier est inclus deux fois, PHP 5 enverra une erreur fatale car
    les fonctions seront déjà déclarées, tandis que PHP 4 ne se plaindra pas
    des fonctions définies après <function>return</function>.
    Il est recommandé d'utiliser <function>include_once</function> au lieu de vérifier
    si le fichier a déjà été inclus et donc de retourner conditonnellement l'inclusion du fichier.
   </para>
   <simpara>
    Une autre façon d'inclure un fichier PHP dans une variable est de capturer
    la sortie en utilisant les fonctions de <link linkend="ref.outcontrol">contrôle de sortie
    </link> avec <function>include</function>. Par exemple :
   </simpara>
   <para>
    <example>
     <title>Utilisation de la sortie du buffer pour inclure un fichier PHP dans une chaîne</title>
      <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
      </programlisting>
    </example>
   </para>
   <para>
    Pour automatiquement inclure des fichiers dans vos scripts, voyez également
    les options de configuration
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> et
    <link linkend="ini.auto-append-file">auto_append_file</link>
    du &php.ini;.
   </para>

   &note.language-construct;

   <simpara>
    Voir aussi
    <function>require</function>,
    <function>require_once</function>,
    <function>include_once</function>,
    <function>get_included_files</function>,
    <function>readfile</function>,
    <function>virtual</function> et
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 xml:id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    La commande <function>require_once</function> se remplace elle-même
    par le fichier spécifié, un peu comme les commandes de
    préprocesseur C <literal>#include</literal>, et ressemble sur
    ce point à <function>require</function>. La principale
    différence est qu'avec <function>require_once</function>,
    vous êtes assurés que ce code ne sera ajouté
    qu'une seule fois, évitant de ce fait les redéfinitions de
    variables ou de fonctions, génératrices d'alertes.
   </para>
   <para>
    <function>require_once</function> doit être utilisée dans les cas
    où le même fichier risque d'être inclus et évalué plusieurs fois
    durant l'exécution d'un script. Vous serez alors sûrs qu'il ne sera inclus qu'une fois
    et vous éviterez les problèmes de déclarations multiples de fonctions ou autres.
   </para>
   <para>
    Pour des exemples avec <function>require_once</function> et
    <function>include_once</function>, reportez-vous au code
    <link xlink:href="&url.php.pear;">PEAR</link> inclus dans les
    dernières distributions PHP.
   </para>
   <para>
    Les valeurs retournées sont les mêmes que lors de l'utilisation de
    <function>include</function>. Si le fichier a déjà été inclus, cette fonction
    retourne &true;.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> a été ajouté en PHP 4.0.1
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Attention, <function>require_once</function> et
      <function>include_once</function> sont insensibles à la casse
      sous les systèmes comme Windows.
      <example>
       <title><function>require_once</function> est insensible à la casse sur Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once "a.php"; // ceci inclut le fichier a.php
require_once "A.php"; // ceci inclut encore le fichier a.php sous Windows! (uniquement en PHP 4)
?>
]]>
        </programlisting>
      </example>
      Ce comportement a changé en PHP 5 - le chemin est normalisé d'abord, donc,
      le fichier <filename>C:\PROGRA~1\A.php</filename> est reconnu
      comme étant identique au fichier
      <filename>C:\Program Files\a.php</filename> et le fichier ne sera
      requis qu'une seule fois.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi
    <function>require</function>,
    <function>include</function>,
    <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>,
    <function>readfile</function> et
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    La commande <function>include_once</function> inclut et
    évalue le fichier spécifié durant
    l'exécution du script. Le comportement est similaire à
    <function>include</function>, mais la différence est que si
    le code a déjà été inclus, il ne le
    sera pas une seconde fois.
   </para>
   <para>
    La fonction <function>include_once</function> est utilisée de
    préférence lorsque le fichier doit être
    inclus ou évalué plusieurs fois dans un script,
    ou bien lorsque vous voulez être sûr qu'il ne sera inclus
    qu'une seule fois, pour éviter des redéfinitions
    de fonction.
   </para>
   <para>
    Pour plus d'exemples avec <function>require_once</function> et
    <function>include_once</function>, jetez un oeil dans le code de PEAR
    inclus dans la dernière distribution de PHP.
   </para>
   <para>
    Les valeurs retournées sont les mêmes que lors de l'utilisation de
    <function>include</function>. Si le fichier a déjà été inclus, cette fonction
    retourne &true;.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> a été ajouté en PHP 4.0.1
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
      Attention, <function>require_once</function> et
      <function>include_once</function> sont insensibles à la casse
      sous les systèmes comme Windows.
      <example>
       <title><function>include_once</function> est insensible à la casse sous Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once "a.php"; // ceci inclut le fichier a.php
include_once "A.php"; // ceci inclut encore le fichier a.php sous Windows! (uniquement en PHP 4)
?>
]]>
        </programlisting>
      </example>
      Ce comportement a changé en PHP 5 - le chemin est normalisé d'abord, donc,
      le fichier <filename>C:\PROGRA~1\A.php</filename> est reconnu
      comme étant identique au fichier
      <filename>C:\Program Files\a.php</filename> et le fichier ne sera
      inclus qu'une seule fois.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi
    <function>require</function>,
    <function>include</function>,
    <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>,
    <function>readfile</function> et
    <function>virtual</function>.
   </para>
  </sect1>
  
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
